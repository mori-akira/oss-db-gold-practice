<!DOCTYPE html>
<html dir="ltr" lang="ja">

<head>
    <meta charset="utf-8">
    <title>OSS-DB Gold Practice</title>
    <meta name="author" content="Moriaki Kogure">
    <link rel="stylesheet" href="./asset/style.css">
    <link rel="icon" href="./asset/favicon.ico">
</head>

<body>
    <h1>OSS-DB Gold Practice</h1>

    <h4>
        以下書籍の内容まとめ + 調査したことまとめ
    </h4>
    <blockquote>
        <a href="https://gihyo.jp/book/2022/978-4-297-13206-4" target="_blank">
            ［改訂3版］内部構造から学ぶPostgreSQL ― 設計・運用計画の鉄則
        </a>
    </blockquote>

    <h4>コンテンツ</h4>
    <div id="page-tree"></div>

    <h2>2章 アーキテクチャの基本</h2>

    <h3>プロセスの構成</h3>
    <table>
        <thead>
            <tr>
                <th>プロセス名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>マスタサーバ</mask-block></td>
                <td>最初に起動される親プロセス</td>
            </tr>
            <tr>
                <td><mask-block>ロガー</mask-block></td>
                <td>サーバログを書き出す</td>
            </tr>
            <tr>
                <td><mask-block>チェックポインタ</mask-block></td>
                <td>すべてのダーティページをデータファイルに書き出す</td>
            </tr>
            <tr>
                <td><mask-block>ライタ</mask-block></td>
                <td>共有バッファの内容をデータファイルに書き出す</td>
            </tr>
            <tr>
                <td><mask-block>WALライタ</mask-block></td>
                <td>WALバッファの内容をWALファイルに書き出す</td>
            </tr>
            <tr>
                <td><mask-block>自動バキュームランチャ</mask-block></td>
                <td>設定に従って自動バキュームワーカを起動する</td>
            </tr>
            <tr>
                <td><mask-block>自動バキュームワーカ</mask-block></td>
                <td>設定に従って自動バキューム処理を行う</td>
            </tr>
            <tr>
                <td><mask-block>統計情報コレクタ</mask-block></td>
                <td>データベースの活動状況に関する統計情報を収集する</td>
            </tr>
            <tr>
                <td><mask-block>バックグラウンドワーカ</mask-block></td>
                <td>ロジカルレプリケーション用、またはユーザ定義のワーカ</td>
            </tr>
            <tr>
                <td><mask-block>バックエンドプロセス</mask-block></td>
                <td>クライアントからの接続要求に対して起動され、クエリを処理する</td>
            </tr>
            <tr>
                <td><mask-block>パラレルワーカ</mask-block></td>
                <td>パラレルスキャン実行時に起動され、クエリを処理する</td>
            </tr>
        </tbody>
    </table>

    <h3>共有メモリ域</h3>
    <table>
        <thead>
            <tr>
                <th>メモリ名</th>
                <th>物理名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>共有バッファ</mask-block></td>
                <td><mask-block>shared_buffers</mask-block></td>
                <td>テーブルやインデックスのデータをキャッシュする領域</td>
            </tr>
            <tr>
                <td><mask-block>WALバッファ</mask-block></td>
                <td><mask-block>wal_buffers</mask-block></td>
                <td>ディスクに書き込まれていないトランザクションログをキャッシュする領域</td>
            </tr>
            <tr>
                <td><mask-block>空き領域マップ</mask-block></td>
                <td><mask-block>Free Space Map</mask-block></td>
                <td>テーブル上の利用可能な領域を示す情報を扱う領域</td>
            </tr>
            <tr>
                <td><mask-block>可視性マップ</mask-block></td>
                <td><mask-block>Visibility Map</mask-block></td>
                <td>テーブルのデータが可視であるか否かを管理する情報を扱う領域</td>
            </tr>
        </tbody>
    </table>

    <h3>プロセスメモリ</h3>
    <table>
        <thead>
            <tr>
                <th>メモリ名</th>
                <th>物理名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>作業メモリ</mask-block></td>
                <td><mask-block>work_mem</mask-block></td>
                <td>クエリ実行時に行われる、並び替えとハッシュテーブル操作のために使われる領域</td>
            </tr>
            <tr>
                <td><mask-block>メンテナンス用作業メモリ</mask-block></td>
                <td><mask-block>maintenance_work_mem</mask-block></td>
                <td>バキューム、インデックス作成、外部キー作成などの、データベースメンテナンスの操作で使用する領域</td>
            </tr>
            <tr>
                <td><mask-block>一時バッファ</mask-block></td>
                <td><mask-block>temp_buffers</mask-block></td>
                <td>バックエンドプロセス毎に作成される一時テーブルにアクセスするときに用いるメモリ領域</td>
            </tr>
        </tbody>
    </table>

    <h3>主なディレクトリ</h3>
    <table>
        <thead>
            <tr>
                <th>ディレクトリ名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>base</mask-block></td>
                <td>
                    データベースごとに作成されるディレクトリがまとめて格納されるディレクトリ<br>
                    データベースごとのディレクトリは、データベースの<m-b>oid</m-b>で命名される。
                </td>
            </tr>
            <tr>
                <td><mask-block>global</mask-block></td>
                <td>データベースクラスタで共有するテーブルを保有するディレクトリ</td>
            </tr>
            <tr>
                <td><mask-block>pg_wal</mask-block></td>
                <td>WALファイルを格納するディレクトリ</td>
            </tr>
            <tr>
                <td><mask-block>pg_xact</mask-block></td>
                <td>トランザクションのコミット状態を管理するファイルが格納されるディレクトリ</td>
            </tr>
            <tr>
                <td><mask-block>pg_tblspc</mask-block></td>
                <td>テーブル空間として作成されたディレクトリへのシンボリックリンクを格納するディレクトリ</td>
            </tr>
        </tbody>
    </table>

    <h3>主なファイル</h3>
    <table>
        <thead>
            <tr>
                <th>ファイル</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>PG_VERSION</mask-block></td>
                <td>PostgreSQLのメジャーバージョンが書き込まれるテキストファイル</td>
            </tr>
            <tr>
                <td><mask-block>テーブルファイル</mask-block></td>
                <td>
                    テーブルデータの実態が格納されているファイル<br>
                    <mask-block>8192</mask-block>バイトの<mask-block>ページ</mask-block>と呼ばれる単位で構成される。
                </td>
            </tr>
            <tr>
                <td><mask-block>インデックスファイル</mask-block></td>
                <td>
                    インデックスの情報が格納されているファイル<br>
                    <mask-block>8192</mask-block>バイトの<mask-block>ページ</mask-block>と呼ばれる単位で構成される。
                </td>
            </tr>
            <tr>
                <td><mask-block>TOASTファイル</mask-block></td>
                <td>
                    テーブル内に長大な行を格納する場合に生成される特殊なファイル<br>
                    このファイルが作られるとき、テーブルの格納領域には<mask-block>oid</mask-block>が格納される。
                </td>
            </tr>
            <tr>
                <td><mask-block>Free Space Mapファイル</mask-block></td>
                <td>
                    空き領域を追跡するための情報が格納されたファイル<br>
                    ファイル名は、「テーブル/インデックスのoid_<mask-block>fsm</mask-block>」となる。
                </td>
            </tr>
            <tr>
                <td><mask-block>Visibility Mapファイル</mask-block></td>
                <td>
                    テーブルの可視性を管理するファイル<br>
                    ファイル名は、「テーブルのoid_<mask-block>vm</mask-block>」となる。
                </td>
            </tr>
            <tr>
                <td><mask-block>WALファイル</mask-block></td>
                <td>
                    PostgreSQLに対して行われた更新操作を記録するファイル<br>
                    ファイルは固定サイズで、initdbやpg_ctlコマンド等を用いてクラスタを作成する際に指定する。<br>
                    デフォルトサイズは<mask-block>16MB</mask-block>である。
                </td>
            </tr>
            <tr>
                <td><mask-block>postgresql.conf</mask-block></td>
                <td>PostgreSQL全体の動作を設定するファイル</td>
            </tr>
            <tr>
                <td><mask-block>pg_hba.conf</mask-block></td>
                <td>クライアントからの接続を管理する設定ファイル</td>
            </tr>
            <tr>
                <td><mask-block>postmaster.pid</mask-block></td>
                <td>PostgreSQLの稼働中に作成されるロックファイル</td>
            </tr>
        </tbody>
    </table>

    <h2>3章 各種設定ファイルと基本設定</h2>

    <h3>PostgreSQLの設定ファイル</h3>
    <table>
        <thead>
            <tr>
                <th>ファイル名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>postgresql.conf</mask-block></td>
                <td>PostgreSQL全体の動作を制御する</td>
            </tr>
            <tr>
                <td><mask-block>pg_hba.conf</mask-block></td>
                <td>クライアントからの接続を制御する</td>
            </tr>
            <tr>
                <td><mask-block>pg_ident.conf</mask-block></td>
                <td>ident認証およびGSSAPI認証で使用する</td>
            </tr>
            <tr>
                <td><mask-block>recovery.conf</mask-block></td>
                <td>アーカイブリカバリ用の設定ファイル</td>
            </tr>
            <tr>
                <td><mask-block>pg_service.conf</mask-block></td>
                <td>libpqライブラリの接続情報をサービスとしてまとめて管理する設定ファイル</td>
            </tr>
        </tbody>
    </table>

    <h3>設定ファイルで設定できる型</h3>
    <table>
        <thead>
            <tr>
                <th>型名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>論理型(boolean)</m-b></td>
                <td>
                    真偽値<br>
                    <m-b>on/off</m-b>、<m-b>true/false</m-b>、<m-b>yes/no</m-b>、<m-b>1/0</m-b>を指定できる。<br>
                    大文字と小文字を区別しない。
                </td>
            </tr>
            <tr>
                <td><m-b>浮動小数点型(floating point)</m-b></td>
                <td>小数点を含む数値</td>
            </tr>
            <tr>
                <td><m-b>整数型(integer)</m-b></td>
                <td>
                    小数点を含まない数値<br>
                    PostgreSQL12以降は、整数型の項目にも小数値を指定できる。その場合、最も近い整数値に丸められる。
                </td>
            </tr>
            <tr>
                <td><m-b>文字型(string)</m-b></td>
                <td>
                    任意の文字列<br>
                    空白を含む場合は<m-b>単一引用符</m-b>で囲む必要がある。(含まない場合は囲む必要はない)<br>
                    値に単一引用符を含む場合は、<m-b>二重引用符</m-b>または<m-b>逆引用符</m-b>で囲む。
                </td>
            </tr>
            <tr>
                <td><m-b>列挙型(enum)</m-b></td>
                <td>限定された値の集合</td>
            </tr>
        </tbody>
    </table>

    <h3>単位を指定する文字</h3>
    <table>
        <thead>
            <tr>
                <th>指定対象</th>
                <th>指定する文字</th>
                <th>意味</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="5">メモリ</td>
                <td><m-b>B</m-b></td>
                <td>バイト</td>
            </tr>
            <tr>
                <td><m-b>kB</m-b></td>
                <td>キロバイト</td>
            </tr>
            <tr>
                <td><m-b>MB</m-b></td>
                <td>メガバイト</td>
            </tr>
            <tr>
                <td><m-b>GB</m-b></td>
                <td>ギガバイト</td>
            </tr>
            <tr>
                <td><m-b>TB</m-b></td>
                <td>テラバイト</td>
            </tr>
            <tr>
                <td rowspan="5">時間</td>
                <td><m-b>ms</m-b></td>
                <td>ミリ秒</td>
            </tr>
            <tr>
                <td><m-b>s</m-b></td>
                <td>秒</td>
            </tr>
            <tr>
                <td><m-b>min</m-b></td>
                <td>分</td>
            </tr>
            <tr>
                <td><m-b>h</m-b></td>
                <td>時間</td>
            </tr>
            <tr>
                <td><m-b>d</m-b></td>
                <td>日</td>
            </tr>
        </tbody>
    </table>

    <h3>pg_hba.confの接続方式に指定できるキーワード</h3>
    <table>
        <thead>
            <tr>
                <th>キーワード</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>local</m-b></td>
                <td>Unixドメインソケットを使用する接続方式</td>
            </tr>
            <tr>
                <td><m-b>host</m-b></td>
                <td>
                    TCP/IPを利用した接続方式<br>
                    SSL通信の有無は問わない。
                </td>
            </tr>
            <tr>
                <td><m-b>hostssl</m-b></td>
                <td>SSLを用いた通信方式</td>
            </tr>
            <tr>
                <td><m-b>hostnossl</m-b></td>
                <td>SSLを用いない通信方式</td>
            </tr>
            <tr>
                <td><m-b>hostgssenc</m-b></td>
                <td>TCP/IPを使用し、かつGSSAPI通信を使用した接続方式</td>
            </tr>
            <tr>
                <td><m-b>hostnogssenc</m-b></td>
                <td>TCP/IPを使用し、かつGSSAPI通信を使用しない接続方式</td>
            </tr>
        </tbody>
    </table>

    <h3>pg_hba.confの接続データベースに指定できるキーワード</h3>
    <table>
        <thead>
            <tr>
                <th>キーワード</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>all</m-b></td>
                <td>すべてのデータベースへの接続に対応する</td>
            </tr>
            <tr>
                <td><m-b>sameuser</m-b></td>
                <td>指定したユーザと同名のデータベースへの接続に対応する</td>
            </tr>
            <tr>
                <td><m-b>samerole</m-b></td>
                <td>指定したユーザが所属するロールと同名のデータベースへの接続に対応する</td>
            </tr>
            <tr>
                <td><m-b>replication</m-b></td>
                <td>レプリケーション接続に対応する</td>
            </tr>
            <tr>
                <td><m-b>@ファイルパス</m-b></td>
                <td>
                    データベース名を含むファイルを指定する<br>
                    pg_hba.confファイルが存在するディレクトリからの相対パス、または絶対パスで指定する。
                </td>
            </tr>
        </tbody>
    </table>

    <h3>特殊な名前のデータベース名/ユーザ名について</h3>
    <p>
        PostgreSQLでは、データベース名やユーザ名に<code>all</code>などの予約語を指定することを禁止していない。
        予約語のデータベース名/ユーザ名が存在する場合も、設定ファイルに予約語を指定した場合の挙動は変わらない。
        設定ファイルで予約語のデータベース名/ユーザ名を指定する場合、<m-b>二重引用符</m-b>を用いることができる。
    </p>

    <h3>pg_hba.confの認証方式に指定できるキーワード</h3>
    <table>
        <thead>
            <tr>
                <th>種別</th>
                <th>キーワード</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="2">無条件</td>
                <td><m-b>trust</m-b></td>
                <td>接続を無条件で許可する</td>
            </tr>
            <tr>
                <td><m-b>reject</m-b></td>
                <td>接続を無条件で拒否する</td>
            </tr>
            <tr>
                <td rowspan="3">パスワード認証</td>
                <td><m-b>md5</m-b></td>
                <td>
                    md5暗号化によるパスワード認証を行う<br>
                    主に、scram-sha-256による暗号化が使用できない環境で使用する。
                </td>
            </tr>
            <tr>
                <td><m-b>password</m-b></td>
                <td>
                    平文によるパスワード認証を行う<br>
                    非推奨
                </td>
            </tr>
            <tr>
                <td><m-b>scram-sha-256</m-b></td>
                <td>
                    scram-sha-256暗号化によるパスワード認証を行う<br>
                    パスワード認証方式で推奨される認証方式
                </td>
            </tr>
            <tr>
                <td><m-b>GSSAPI認証</m-b></td>
                <td><m-b>gss</m-b></td>
                <td>
                    GSSAPIによる認証を行う<br>
                    <m-b>Linux</m-b>環境かつTCP/IP接続でのみ使用できる。
                </td>
            </tr>
            <tr>
                <td><m-b>SSPI認証</m-b></td>
                <td><m-b>sspi</m-b></td>
                <td>
                    sspiによる認証を行う<br>
                    <m-b>Windows</m-b>環境でのみ使用できる。
                </td>
            </tr>
            <tr>
                <td><m-b>Ident認証</m-b></td>
                <td><m-b>ident</m-b></td>
                <td>
                    クライアントOSの<m-b>ユーザ名</m-b>をidentサーバから入手してデータベース接続ユーザ名として使用する
                </td>
            </tr>
            <tr>
                <td><m-b>Peer認証</m-b></td>
                <td><m-b>peer</m-b></td>
                <td>
                    OSの<m-b>ユーザ名</m-b>をカーネルから入手してデータベース接続ユーザ名として使用する
                </td>
            </tr>
            <tr>
                <td><m-b>LDAP認証</m-b></td>
                <td><m-b>ldap</m-b></td>
                <td>
                    パスワード認証のためにLDAPサーバを使用する
                </td>
            </tr>
            <tr>
                <td><m-b>RADIUS認証</m-b></td>
                <td><m-b>radius</m-b></td>
                <td>
                    パスワード認証のためにRADIUSサーバを使用する
                </td>
            </tr>
            <tr>
                <td><m-b>証明書認証</m-b></td>
                <td><m-b>cert</m-b></td>
                <td>
                    SSLクライアント証明書を使った認証を行う
                </td>
            </tr>
            <tr>
                <td><m-b>PAM認証</m-b></td>
                <td><m-b>pam</m-b></td>
                <td>
                    パスワード認証のためにPAMを使用する
                </td>
            </tr>
            <tr>
                <td><m-b>BSD認証</m-b></td>
                <td><m-b>bsd</m-b></td>
                <td>
                    OSによって提供されたBSD認証サービスを使用する
                </td>
            </tr>
        </tbody>
    </table>

    <h3>pg_ident.confの使い方</h3>
    <p>
        マッピング名を<code>foo_ident</code>、OSユーザ名を<code>foo</code>、マッピングするデータベース名を<code>user1</code>とするとき、
        pg_ident.confは次のように記述する。
    </p>
    <h4>pg_ident.conf</h4>
    <pre><code>
# map-name system-user-name database-user-name
<m-b>foo_ident</m-b> <m-b>foo</m-b> <m-b>user1</m-b>
    </code></pre>
    <p>また、ident認証で上記のマッピングを使用する場合、pg_hba.confには次のように記述する。</p>
    <h4>pg_hba.conf</h4>
    <pre><code>
# TYPE DATABASE USER METHOD
host all all 192.168.10.0/24 <m-b>ident map=foo_indent</m-b>
    </code></pre>

    <h2>4章 処理/制御の基本</h2>

    <h3>問い合わせ処理の流れ</h3>
    <table>
        <thead>
            <tr>
                <th>処理名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>パーサ</m-b></td>
                <td>
                    問い合わせのはじめに、字句解析と構文解析を行う処理<br>
                    字句解析では、OSSである<m-b>flex</m-b>を用いて処理を行い、
                    <m-b>./backend/parser/scan.l</m-b>というファイルにルールを定義する。<br>
                    構文解析では、OSSである<m-b>bison</m-b>を用いて処理を行い、
                    <m-b>./backend/parser/gram.y</m-b>というファイルにルールを定義する。<br>
                    字句解析と構文解析に成功した場合、<m-b>問い合わせツリー</m-b>という構造を生成し、次の処理へと渡す。
                </td>
            </tr>
            <tr>
                <td><m-b>リライタ</m-b></td>
                <td>
                    SQLを実行するデータベースにルールが定義されている場合に、そのルールを参照して問い合わせツリーを書き換える処理<br>
                    PostgreSQLのビューは、このルールを用いて実現されている。
                </td>
            </tr>
            <tr>
                <td><m-b>プランナ/オプティマイザ</m-b></td>
                <td>問い合わせツリーをもとに最適な実行計画を生成する処理</td>
            </tr>
            <tr>
                <td><m-b>エグゼキュータ</m-b></td>
                <td>実行計画に従って必要な行の集合を抽出する処理</td>
            </tr>
        </tbody>
    </table>

    <h3>トランザクションの特性</h3>
    <table>
        <thead>
            <tr>
                <th>特性</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>原子性(Atomicity)</m-b></td>
                <td>処理の最小単位を定義し、それらの処理がすべて実行されたか、まったく実行されないかのどちらかの結果となること</td>
            </tr>
            <tr>
                <td><m-b>一貫性(Consistency)</m-b></td>
                <td>トランザクションの開始及び終了時点で、業務として規定された整合性を満たすこと</td>
            </tr>
            <tr>
                <td><m-b>独立性(Isolation)</m-b></td>
                <td>作業中のトランザクションによる更新は、確定するまで他のトランザクションから不可視となること</td>
            </tr>
            <tr>
                <td><m-b>永続性(Durability)</m-b></td>
                <td>確定したトランザクションの結果は永続的に保存されること</td>
            </tr>
        </tbody>
    </table>

    <h3>トランザクション分離レベル</h3>
    <table>
        <thead>
            <tr>
                <th>分離レベル</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>READ UNCOMMITED</m-b></td>
                <td>
                    別トランザクションのコミットされていないデータが参照される可能性がある<br>
                    PostgreSQLにおいてはこの実装は存在せず、指定しても<m-b>READ COMMITED</m-b>として扱われる。
                </td>
            </tr>
            <tr>
                <td><m-b>READ COMMITED</m-b></td>
                <td>
                    問い合わせを実行する直前までにコミットされたデータのみを参照する<br>
                    PostgreSQLにおいては、デフォルトの分離レベルとなる。
                </td>
            </tr>
            <tr>
                <td><m-b>REPEATABLE READ</m-b></td>
                <td>トランザクションが開始する直前までにコミットされたデータのみを参照する</td>
            </tr>
            <tr>
                <td><m-b>SERIALIZABLE</m-b></td>
                <td>並列実行された複数のトランザクションの実行であっても、逐次的に扱われたものと同じ結果を要求する</td>
            </tr>
        </tbody>
    </table>

    <h3>分離レベルが不十分な場合に起きる事象</h3>
    <table>
        <thead>
            <tr>
                <th>事象</th>
                <th>抑止できる分離レベル</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>ダーティリード</m-b></td>
                <td><m-b>READ COMMITED</m-b></td>
                <td>
                    同時に実行されている他のトランザクションが書き込んだ、コミット前のデータを読み込んでしまうこと
                </td>
            </tr>
            <tr>
                <td><m-b>反復不能読み取り</m-b></td>
                <td><m-b>REPEATABLE READ</m-b></td>
                <td>
                    同一トランザクション内で複数回読み取りを行い、その結果が別トランザクションの更新の影響で変わってしまうこと
                </td>
            </tr>
            <tr>
                <td><m-b>ファントムリード</m-b></td>
                <td><m-b>SERIALIZABLE</m-b></td>
                <td>
                    同一トランザクション内で複数回読み取りを行い、その結果が別トランザクションの挿入の影響で変わってしまうこと
                </td>
            </tr>
        </tbody>
    </table>

    <h3>ロックモード一覧</h3>
    <table>
        <thead>
            <tr>
                <th>ロックモード</th>
                <th>獲得タイミング</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>ACCESS SHARE</m-b></td>
                <td>
                    <ul>
                        <li>SELECT</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>ROW SHARE</m-b></td>
                <td>
                    <ul>
                        <li>SELECT FOR UPDATE</li>
                        <li>SELECT FOR SHARE</li>
                        <li>SELECT FOR NO KEY UPDATE</li>
                        <li>SELECT FOR KEY SHARE</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>ROW EXCLUSIVE</m-b></td>
                <td>
                    <ul>
                        <li>INSERT</li>
                        <li>UPDATE</li>
                        <li>DELETE</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>SHARE UPDATE EXCLUSIVE</m-b></td>
                <td>
                    <ul>
                        <li>VACUUM</li>
                        <li>ANALYZE</li>
                        <li>CREATE INDEX CONCURRENTLY</li>
                        <li>ALTER TABLE(SET STATISTICS)</li>
                        <li>SET(attr = value)</li>
                        <li>RESET(attr = value)</li>
                        <li>VALIDATE CONSTRAINT</li>
                        <li>CLUSTER ON</li>
                        <li>SET WITHOUT CLUSTER</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>SHARE</m-b></td>
                <td>
                    <ul>
                        <li>CREATE INDEX</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>SHARE ROW EXCLUSIVE</m-b></td>
                <td>
                    同一セッション内での競合を防ぐためのロックモード<br>
                    明示的にこのロックモードを獲得するコマンドはない。
                </td>
            </tr>
            <tr>
                <td><m-b>EXCLUSIVE</m-b></td>
                <td>
                    明示的にこのロックモードを獲得するコマンドはない。
                </td>
            </tr>
            <tr>
                <td><m-b>ACCESS EXCLUSIVE</m-b></td>
                <td>
                    <ul>
                        <li>ALTER TABLE</li>
                        <li>DROP TABLE</li>
                        <li>TRUNCATE</li>
                        <li>REINDEX</li>
                        <li>CLUSTER</li>
                        <li>VACUUM FULL</li>
                        <li>LOCK TABLE</li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>

    <h3>同時実行制御</h3>
    <p>
        PostgreSQLでは、<m-b>追記型アーキテクチャ</m-b>というアーキテクチャを採用することで、
        <m-b>MVCC(Multi Version Concurrency Control)</m-b>と呼ばれる同時実行制御を実現している。
        追記型アーキテクチャとは、データ更新時にデータを直接書き換えるのではなく、
        トランザクションごとに発行されるID(<m-b>XID</m-b>)をテーブルの各行に保持することで、
        トランザクションごとのデータを保持する仕組みである。<br>
        追記型アーキテクチャの仕様上、不要となるタプルが発生するが、これを整理する処理が<m-b>バキューム</m-b>であり、
        更新前の古いタプルを<m-b>空き領域マップ</m-b>に記録することで、再利用可能とする。<br>
        以前のPostgreSQLではこのバキューム処理の運用が重要な課題となっていたが、PostgreSQL8.3で採用された<m-b>HOT(Heap Only Tuple)</m-b>や、
        自動バキューム機能の強化により、バキューム処理を意識する必要がなくなった。
    </p>

    <h2>5章 テーブル設計</h2>

    <h3>文字型</h3>
    <table>
        <thead>
            <tr>
                <th>型名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    <m-b>character varying(n)</m-b>、
                    <m-b>varchar(n)</m-b>
                </td>
                <td>上限n文字まで格納可能な可変長データ型</td>
            </tr>
            <tr>
                <td>
                    <m-b>character(n)</m-b>、
                    <m-b>char(n)</m-b>
                </td>
                <td>
                    上限n文字までを格納可能な固定長データ型<br>
                    格納時にn文字に満たない場合は<m-b>末尾</m-b>に空白を付与して格納する。
                    検索時にも空白が付与された結果が取得される。
                </td>
            </tr>
            <tr>
                <td><m-b>text</m-b></td>
                <td>上限指定なしの可変長データ型(最大<m-b>1GB</m-b>まで格納可能)</td>
            </tr>
        </tbody>
    </table>
    <p>
        データ格納時に、次のルールに従ってヘッダ情報が付与される。
    </p>
    <ul>
        <li>文字列長が<m-b>126バイト</m-b>以下の場合、ヘッダ情報として<m-b>1バイト</m-b>使用する</li>
        <li>文字列長が<m-b>127バイト</m-b>以上の場合、ヘッダ情報として<m-b>4バイト</m-b>使用する</li>
        <li>
            非常に長い文字列の(テーブル内に格納される値が<m-b>2kB</m-b>を超える)場合、<m-b>TOAST領域</m-b>に分割して格納される<br>
            特に要件が無ければ、PostgreSQLにおいて文字型として用いることが推奨される。
        </li>
    </ul>

    <h3>char型に対する文字列操作の注意点</h3>
    <p>
        char型の文字列を文字列関数や文字列操作演算子で扱う場合、空白の扱いが異なる場合があるため注意が必要である。<br>
        例えば、char(8)のカラム<code>c</code>と、varchar(8)のカラム<code>v</code>をもつテーブル<code>example</code>に対し、
        concat関数と||演算子を用いた結合では次のような差が生まれる。
    </p>
    <h4>exampleテーブルのタプル</h4>
    <pre><code>
SELECT * FROM example;
    </code></pre>
    <h4>結果</h4>
    <pre><code>
  c |  v
----+-----
hoge|fuga

(1 rows)
    </code></pre>
    <h4>concat関数を用いた場合</h4>
    <pre><code>
SELECT concat(c, v) FROM example;
    </code></pre>
    <h4>結果</h4>
    <pre><code>
  concat
----------
<m-b>hoge    fuga</m-b>

(1 rows)
    </code></pre>
    <h4>||演算子を用いた場合</h4>
    <pre><code>
SELECT c || v FROM example;
    </code></pre>
    <h4>結果</h4>
    <pre><code>
  concat
----------
<m-b>hogefuga</m-b>

(1 rows)
    </code></pre>

    <h3>数値型</h3>
    <table>
        <thead>
            <tr>
                <th>型名</th>
                <th>
                    <nobr>格納サイズ</nobr><br>(バイト)
                </th>
                <th>説明</th>
                <th>範囲</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>smallint</m-b></td>
                <td><m-b>2</m-b></td>
                <td>整数データ型</td>
                <td>-32768~32767</td>
            </tr>
            <tr>
                <td><m-b>integer</m-b></td>
                <td><m-b>4</m-b></td>
                <td>整数データ型</td>
                <td>-2147483648~2147483647</td>
            </tr>
            <tr>
                <td><m-b>bigint</m-b></td>
                <td><m-b>8</m-b></td>
                <td>整数データ型</td>
                <td>-9223372036854775808~9223372036854775807</td>
            </tr>
            <tr>
                <td><m-b>decimal</m-b></td>
                <td>可変長</td>
                <td>正確な精度を保持する(小数も指定可)</td>
                <td>整数部は131072桁まで、小数部は16383桁まで</td>
            </tr>
            <tr>
                <td><m-b>numeric</m-b></td>
                <td>可変長</td>
                <td>正確な精度を保持する(小数も指定可)</td>
                <td>整数部は131072桁まで、小数部は16383桁まで</td>
            </tr>
            <tr>
                <td><m-b>real</m-b></td>
                <td><m-b>4</m-b></td>
                <td colspan="2">
                    <m-b>6</m-b>桁の精度を持つ不正確なデータ型(小数も指定可)<br>
                    IEEE規格754の形式で格納する。
                </td>
            </tr>
            <tr>
                <td><m-b>double precision</m-b></td>
                <td><m-b>8</m-b></td>
                <td colspan="2">
                    <m-b>15</m-b>桁の精度を持つ不正確なデータ型(小数も指定可)<br>
                    IEEE規格754の形式で格納する。
                </td>
            </tr>
            <tr>
                <td><m-b>smallserial</m-b></td>
                <td><m-b>2</m-b></td>
                <td rowspan="3" colspan="2">
                    連番型<br>
                    内部にシーケンスを作成し、デフォルト値としてシーケンスから払い出された値を設定する。
                </td>
            </tr>
            <tr>
                <td><m-b>serial</m-b></td>
                <td><m-b>4</m-b></td>
            </tr>
            <tr>
                <td><m-b>bigserial</m-b></td>
                <td><m-b>8</m-b></td>
            </tr>
        </tbody>
    </table>

    <h3>日付/時刻データ型</h3>
    <table>
        <thead>
            <tr>
                <th>型名</th>
                <th>
                    <nobr>格納サイズ</nobr><br>(バイト)
                </th>
                <th>説明</th>
                <th>範囲</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>timestamp [without timezone]</m-b></td>
                <td><m-b>8</m-b></td>
                <td>日付と時刻を保持する<br>(タイムゾーンなし)</td>
                <td>紀元前4713年~西暦294276年</td>
            </tr>
            <tr>
                <td><m-b>timestamp with time zone</m-b></td>
                <td><m-b>8</m-b></td>
                <td>日付と時刻を保持する<br>(タイムゾーンあり)</td>
                <td>紀元前4713年~西暦294276年</td>
            </tr>
            <tr>
                <td><m-b>date</m-b></td>
                <td><m-b>4</m-b></td>
                <td>日付を保持する</td>
                <td>紀元前4713年~西暦5874897年</td>
            </tr>
            <tr>
                <td><m-b>time [without timezone]</m-b></td>
                <td><m-b>8</m-b></td>
                <td>時刻を保持する</td>
                <td>00:00:00~24:00:00</td>
            </tr>
            <tr>
                <td><m-b>time with time zone</m-b></td>
                <td><m-b>12</m-b></td>
                <td>時刻を保持する</td>
                <td>00:00:00+1459~24:00:00-1459</td>
            </tr>
            <tr>
                <td><m-b>interval [fields]</m-b></td>
                <td><m-b>16</m-b></td>
                <td>時間間隔を保持する</td>
                <td>-178000000年~178000000年</td>
            </tr>
        </tbody>
    </table>

    <h3>タイムゾーンの指定方式</h3>
    <table>
        <thead>
            <tr>
                <th>指定方式</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>正式名</m-b>の指定</td>
                <td>
                    大文字/小文字を区別しない。<br>
                    対象の一覧は、システムカタログの<m-b>pg_timezone_names</m-b>ビューから確認できる。
                </td>
            </tr>
            <tr>
                <td><m-b>略称</m-b>の指定</td>
                <td>
                    大文字/小文字を区別しない。<br>
                    対象の一覧は、システムカタログの<m-b>pg_timezone_names</m-b>ビュー、
                    または<m-b>pg_timezone_abbrevs</m-b>ビューから確認できる。
                </td>
            </tr>
            <tr>
                <td><m-b>オフセット</m-b>の指定</td>
                <td>
                    略称とオフセットを指定する。
                </td>
            </tr>
        </tbody>
    </table>

    <h3>バイナリ列データ型</h3>
    <p>
        バイナリ列データ型を扱う場合は、基本的に<m-b>bytea</m-b>型を使用するが、
        格納するデータサイズが非常に大きい場合や、データの一部のみを書き換える使い方を想定する場合、
        <m-b>ラージオブジェクト</m-b>の使用を検討する。
        bytea型では、<m-b>1GB</m-b>までしか格納できないが、ラージオブジェクトでは<m-b>4TB</m-b>まで格納できる。
        性能の観点から、格納するデータ量が<m-b>100kB</m-b>までの場合はbytea型を、
        それ以上の場合はラージオブジェクトを使用することが推奨されている。
    </p>

    <h3>ラージオブジェクトについて</h3>
    <p>
        ラージオブジェクトは管理方法やアクセス方法がbytea型とは根本的に異なる。
        テーブル定義上は、ラージオブジェクトへのポインタとなる<m-b>oid</m-b>の列を定義する。<br>
        ラージオブジェクトの実体は、システムカタログの<m-b>pg_largeobject</m-b>にある。
        ここでは、<m-b>2kB</m-b>のチャンクに分割して格納されている。<br>
        また、ラージオブジェクトのメタ情報を扱うシステムカタログとして、<m-b>pg_largeobject_metadata</m-b>がある。
        ここでは、所有者やアクセス権限を管理する。
    </p>

    <h3>JSON型とJSONB型について</h3>
    <p>
        PostgreSQL9.4より、JSON型のみでなくJSONB型が追加された。
        JSON型とJSONB型はどちらもJSONデータを扱うデータ型だが、格納方法に違いがある。
        JSONB型では、JSON演算を高速にするため<m-b>バイナリ</m-b>形式に変換されて格納される。
        このため、挿入処理は<m-b>JSON型</m-b>の方が、演算子を用いた検索処理は<m-b>JSONB型</m-b>の方が高速となる。
        用途に応じて使い分ける。
    </p>

    <h3>型名のエイリアス</h3>
    <p>
        PostgreSQLでは、異なる名称で同じ意味を示すデータ型がいくつか存在する。<br>
        例えば、数値型では、<m-b>int2</m-b>(smallintと同義)、<m-b>int4</m-b>(integherと同義)、
        <m-b>int8</m-b>(bigintと同義)、<m-b>decimal</m-b>(numericと同義)、<m-b>float</m-b>(double precisionと同義)
        などがある。<br>
        なお、PostgreSQLのシステムカタログ(<m-b>pg_type.typename</m-b>)上では、SQL標準規定でない型名が定義されている場合がある。
        しかしその場合でも、psqlの<code>\d</code>メタコマンド等で列情報を確認すると、SQL標準規定の型名で表示される。
        これは、<m-b>pg_catalog.format_type()</m-b>で変換を行っているためである。
    </p>

    <h3>外部キー制約について</h3>
    <h4>参照先の削除/更新時の動作指定</h4>
    <p>
        外部キー制約を指定する際、参照先のタプルを削除/更新するときの動作を、
        それぞれ<m-b>ON DELETE</m-b>句、<m-b>ON UPDATE</m-b>句で指定することができる。
        指定できる具体的な操作は、次の表の通り。
    </p>
    <table>
        <thead>
            <tr>
                <th>キーワード</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>CASCADE</m-b></td>
                <td>参照先のタプルが削除されたとき、伴って参照しているタプルも削除する</td>
            </tr>
            <tr>
                <td><m-b>RESTRICT</m-b></td>
                <td>
                    参照するタプルが残っている状態で、参照先のタプルが削除されることを防ぐ<br>
                    削除処理が行われたタイミングでエラーが発生する。
                </td>
            </tr>
            <tr>
                <td><m-b>NO ACTION</m-b></td>
                <td>
                    参照するタプルが残っている状態で、参照先のタプルが削除されても何もしない<br>
                    ただし、これは同一トランザクション内の後続処理で整合性が取られることを前提としている。
                    トランザクションがコミットされたタイミングで外部キーの整合性がとれていない場合、エラーが発生しトランザクションはロールバックされる。
                </td>
            </tr>
            <tr>
                <td><m-b>SET NULL</m-b></td>
                <td>参照先のタプルが削除されたとき、参照しているタプルの外部キー列にNULLを設定する</td>
            </tr>
            <tr>
                <td><m-b>SET DEFAULT</m-b></td>
                <td>
                    参照先のタプルが削除されたとき、参照しているタプルの外部キー列にデフォルト値を設定する<br>
                    ただし、デフォルト値が外部キー制約を満たさない場合、エラーが発生する。
                </td>
            </tr>
        </tbody>
    </table>
    <h4>外部キー制約の注意点</h4>
    <p>
        外部キー制約を用いる場合、次の2点に注意する必要がある。<br>
        1点目は、外部キーには暗黙的な<m-b>インデックス</m-b>が設定されないため、明示的に<m-b>インデックス</m-b>を作成する必要があることである。
        参照先の列が主キーの場合でも、参照元の外部キー列で暗黙的にインデックスが作成されることはない。<br>
        2点目は、テーブル間で外部キーの<m-b>型</m-b>を一致させることである。
        通常、異なる型で外部キーを作成することはできないが、<m-b>型変換</m-b>や<m-b>関数</m-b>を用いることで異なる型の外部キーを設定することも可能である。
    </p>

    <h3>生成列について</h3>
    <p>
        生成列はPostgreSQL12から追加された機能で、他の列を用いて計算した値をデフォルト値として設定できる。
        例えば、以下のようにScoreの合計列totalを定義することができる。
    </p>
    <pre><code>
CREATE TABLE score(
    student_id bigint UNIQUE,
    japanese integer DEFAULT 0,
    math integer DEFAULT 0,
    english integer DEFAULT 0,
    total integer <m-b>GENERATED ALWAYS AS</m-b> (japanese + math + english) <m-b>STORED</m-b>
)
    </code></pre>
    <p>
        生成列に値を指定することはできないが、キーワード<m-b>DEFAULT</m-b>を指定することができ、生成列の定義に則った値の計算が行われる。<br>
        生成列は、次の制約が存在する。
    </p>
    <ul>
        <li>生成列は不変関数のみを使用でき、副問い合わせや現在のタプル以外への参照は使用できない</li>
        <li>生成列は他の生成列を参照できない</li>
        <li>生成列は<m-b>tableoid</m-b>以外のシステム列を参照できない</li>
    </ul>

    <h3>TOASTを意識したテーブル設計</h3>
    <p>
        TOASTとは、<m-b>The Oversized-Attribute Storage Technique</m-b>の略で、<m-b>過大属性格納技法</m-b>の意である。
        大きな列の値を格納する際の実装技法である。<br>
        TOAST化は、行のサイズが<m-b>2kB</m-b>を超えるときに実行され、TOASTと呼ばれる特殊領域にデータを配置し、テーブルブロックではその参照情報を持つ。
        TOAST化の処理では、行サイズが<m-b>2kB</m-b>より小さくなるまで個々の列の値を圧縮し、別領域に移動しようとする。
        TOASTの格納方法は次の4種類があり、データタイプごとにデフォルトが決められている。
    </p>
    <table>
        <thead>
            <tr>
                <th>格納方法</th>
                <th>対応する主なデータ型</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>PLAIN</m-b></td>
                <td>
                    <ul>
                        <li><m-b>INTEGER</m-b></li>
                        <li><m-b>FLOAT</m-b></li>
                        <li><m-b>DOUBLE PRECISION</m-b></li>
                        <li><m-b>DATE</m-b></li>
                        <li><m-b>TIMESTAMP</m-b></li>
                    </ul>
                </td>
                <td>
                    圧縮や行外への格納を行わない<br>
                    固定長データ型など、TOAST不可能なデータ型に適用する。
                </td>
            </tr>
            <tr>
                <td><m-b>EXTENDED</m-b></td>
                <td>
                    <ul>
                        <li><m-b>CHAR(n)</m-b></li>
                        <li><m-b>VARCHAR(n)</m-b></li>
                        <li><m-b>TEXT</m-b></li>
                        <li><m-b>BYTEA</m-b></li>
                        <li><m-b>JSON/JSONB</m-b></li>
                    </ul>
                </td>
                <td>
                    圧縮と行外の格納を行う<br>
                    ほとんどのTOAST可能なデータ型のデフォルトはこの方法である。
                </td>
            </tr>
            <tr>
                <td><m-b>EXTERNAL</m-b></td>
                <td></td>
                <td>
                    非圧縮の行外格納を行う<br>
                    TEXTとBYTEAに対して設定すると、格納領域が増加する代わりに列全体に対する部分文字列操作が高速化される。
                </td>
            </tr>
            <tr>
                <td><m-b>MAIN</m-b></td>
                <td>
                    <ul>
                        <li><m-b>NUMERIC</m-b></li>
                    </ul>
                </td>
                <td>圧縮を行うが、行外の格納は極力行わない</td>
            </tr>
        </tbody>
    </table>
    <p>
        テーブル作成後に格納方法を指定する場合、次のコマンドを実行すればよい。
    </p>
    <pre><code>
ALTER TALBE テーブル名 ALTER 列名 <m-b>SET STORAGE 格納方法</m-b>
    </code></pre>

    <h3>遺伝的問い合わせ最適化</h3>
    <p>
        PostgreSQLのプランナでは、結合方式の最適化のために実行計画を総当たりで評価する。
        このため、テーブルの結合数が増加すると、指数関数的に最適化処理のコストが増加する。<br>
        このため、クエリ内で扱うテーブル数が一定の閾値(通常は<m-b>12</m-b>)を超過すると、<m-b>遺伝的問い合わせ最適化</m-b>という手法で
        実行計画を生成するようになる。
    </p>
    <blockquote>
        <a href="https://www.postgresql.jp/document/8.1/html/geqo-pg-intro.html" target="_blank">
            47.3. PostgreSQLの遺伝的問い合わせ最適化（GEQO）
        </a>
    </blockquote>

    <h3>宣言的パーティショニング</h3>
    <h4>メリット</h4>
    <p>
        宣言的パーティショニングを用いるメリットは、次のようなものがある。
    </p>
    <ul>
        <li>物理的な分割によってデータアクセスの範囲を絞り込めるため、特定条件下でI/O負荷を低減し参照性能の改善が見込める。</li>
        <li>パーティションのDROP/TRUNCATEによって一括削除ができるため、特定条件のDELETEよりも処理時間やマシンリソース消費を抑えることができる。</li>
    </ul>
    <h4>分割方式</h4>
    <table>
        <thead>
            <tr>
                <th>分割方式</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>範囲パーティショニング</m-b></td>
                <td>
                    パーティションキーの範囲に基づいて振り分けを行う方式<br>
                    パーティションキーに指定できる型は<m-b>B-tree</m-b>演算子クラスを持つ型である。
                </td>
            </tr>
            <tr>
                <td><m-b>リストパーティショニング</m-b></td>
                <td>
                    パーティションキーが事前に列挙されたリストに基づいて振り分けを行う方式<br>
                    パーティションキーに指定できる型は<m-b>B-tree</m-b>演算子クラスを持つ型である。
                </td>
            </tr>
            <tr>
                <td><m-b>範囲パーティショニング</m-b></td>
                <td>
                    パーティションキーに対しハッシュ値を計算しその余りで振り分けを行うことで、ほぼ均等な振り分けを行う方式<br>
                    パーティションキーに指定できる型は<m-b>ハッシュ</m-b>演算子クラスを持つ型である。
                </td>
            </tr>
        </tbody>
    </table>
    <h4>範囲パーティションニングでパーティションテーブルとパーティションを作成</h4>
    <pre><code>
/* logdateカラムをパーティションキーに指定し、パーティションテーブル作成 */
CREATE TABLE log (
    id bigserial PRIMARY KEY,
    kind text NOT NULL,
    logdate date NOT NULL
) <m-b>PARTITION BY RANGE (logdate)</m-b>;

/* 月ごとの範囲パーティションを作成 */
CREATE TABLE log_202206 <m-b>PARTITION OF log FOR VALUES FROM ('2022-06-01') TO ('2022-07-01')</m-b>;
CREATE TABLE log_202207 <m-b>PARTITION OF log FOR VALUES FROM ('2022-07-01') TO ('2022-08-01')</m-b>;
    </code></pre>
    <h4>リストパーティションニングでパーティションテーブルとパーティションを作成</h4>
    <pre><code>
/* kindカラムをパーティションキーに指定し、パーティションテーブル作成 */
CREATE TABLE log (
    id bigserial PRIMARY KEY,
    kind text NOT NULL,
    logdate date NOT NULL
) <m-b>PARTITION BY LIST (kind)</m-b>;

/* 種別ごとのリストパーティションを作成 */
CREATE TABLE log_app <m-b>PARTITION OF log FOR VALUES IN ('app')</m-b>;
CREATE TABLE log_error <m-b>PARTITION OF log FOR VALUES IN ('error')</m-b>;
    </code></pre>
    <h4>ハッシュパーティションニングでパーティションテーブルとパーティションを作成</h4>
    <pre><code>
/* idカラムをパーティションキーに指定し、パーティションテーブル作成 */
CREATE TABLE log (
    id bigserial PRIMARY KEY,
    kind text NOT NULL,
    logdate date NOT NULL
) <m-b>PARTITION BY HASH (id)</m-b>;

/* idのハッシュ値で均等にパーティションを作成 */
CREATE TABLE log_1 <m-b>PARTITION OF log FOR VALUES WITH (MODULUS 2, REMAINDER 0)</m-b>;
CREATE TABLE log_2 <m-b>PARTITION OF log FOR VALUES WITH (MODULUS 2, REMAINDER 1)</m-b>;
    </code></pre>
    <h4>パーティショニングの要否の判断基準</h4>
    <p>
        次のいずれかの条件を満たす場合、パーティショニングの使用を検討することが推奨される。
    </p>
    <ul>
        <li>テーブルが巨大であるか</li>
        <li>パーティションキーを使用した検索が行われるか</li>
        <li>一括削除の運用が行われるか</li>
    </ul>
    <h4>パーティショニングの設計方針</h4>
    <p>
        <m-b>更新の可能性がある</m-b>カラムはパーティションキーに指定するべきでない。
        これは、パーティションキーが更新されて条件に合うパーティションに移動する処理は、オーバーヘッドが大きいためである。<br>
        パーティションをパーティショニングテーブルとして定義し、そのパーティションのことを<m-b>サブパーティション</m-b>と呼ぶ。
        データ量が多く1度のパーティショニングで絞り込みが不足する場合、より細かな単位に分割するサブパーティションの利用を検討する。<br>
        運用の中で参照することはないが、要件上削除することができないパーティションが存在する場合、
        パーティションテーブルから<m-b>DETACH</m-b>することも検討する。
    </p>

    <h2>6章 物理設計</h2>

    <h3>データファイルの実体</h3>
    <p>
        PostgreSQLでは、テーブルもインデックスも<m-b>ファイルノード番号</m-b>で命名されるファイルが実体となる。
        このファイルは基本的に<m-b>8192バイト</m-b>の<m-b>ページ</m-b>と呼ばれる固定長領域が連続して配置されている。
        また、ファイルサイズは最大約<m-b>1GB</m-b>で、これを超える場合は<m-b>連番</m-b>を拡張子とするファイルに分割される。
        そのため、1ファイルの最大ページ数は<m-b>131,072</m-b>ページとなる。<br>
        あるテーブルのファイルノード番号を調べたい場合、次のSQLを実行すればよい。
    </p>
    <pre><code>
SELECT relname, <m-b>relfilenode</m-b>
FROM <m-b>pg_class</m-b>
WHERE relname = 'テーブル名';
    </code></pre>
    <p>
        なお、PostgreSQLで管理できる1つのテーブルやインデックスの最大サイズは<m-b>32TB</m-b>である。
        ただし、テーブルの<m-b>パーティショニング</m-b>を用いれば、それよりも大きいサイズのテーブルを管理することもできる。
    </p>

    <h3>テーブルファイル</h3>
    <h4>テーブルファイルのページ構成</h4>
    <table>
        <thead>
            <tr>
                <th>領域名</th>
                <th>サイズ</th>
                <th>内容</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>ページヘッダ</m-b></td>
                <td><m-b>24バイト</m-b></td>
                <td>
                    ページ内の管理情報と次ページに対する最近の更新情報(<m-b>WAL</m-b>に関する情報)
                </td>
            </tr>
            <tr>
                <td><m-b>アイテムIDデータ</m-b></td>
                <td><m-b>可変</m-b></td>
                <td>
                    アイテムのオフセットや長さ、アイテムの属性情報
                </td>
            </tr>
            <tr>
                <td><m-b>空き領域</m-b></td>
                <td><m-b>可変</m-b></td>
                <td>
                    アイテムデータ末尾とアイテム先頭の間の使用されない領域<br>
                    <m-b>FILLFACTOR</m-b>の設定で、データ挿入時に使用可能な空き領域の割合が変動する。
                </td>
            </tr>
            <tr>
                <td><m-b>アイテム</m-b></td>
                <td><m-b>可変</m-b></td>
                <td>
                    タプルの実体<br>
                    空き領域の末尾から格納される。格納の向きは、<m-b>ページ末尾からページ先頭</m-b>に向かう方向。
                </td>
            </tr>
            <tr>
                <td><m-b>特殊な空間</m-b></td>
                <td><m-b>可変</m-b></td>
                <td>
                    空き領域の後に配置される<br>
                    ページ内容が<m-b>インデックス</m-b>の場合に配置される。
                </td>
            </tr>
        </tbody>
    </table>
    <h4>ページヘッダの構成</h4>
    <table>
        <thead>
            <tr>
                <th>領域名</th>
                <th>長さ(バイト)</th>
                <th>内容</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>pd_lsn</m-b></td>
                <td><m-b>8</m-b></td>
                <td><m-b>LSN</m-b>(<m-b>Log Sequence Number</m-b>:このページに対して行われた最後の更新ログの位置)</td>
            </tr>
            <tr>
                <td><m-b>pd_checksum</m-b></td>
                <td><m-b>2</m-b></td>
                <td>ページのチェックサム</td>
            </tr>
            <tr>
                <td><m-b>pg_flags</m-b></td>
                <td><m-b>2</m-b></td>
                <td>フラグ(ビット列)の格納領域</td>
            </tr>
            <tr>
                <td><m-b>pg_lower</m-b></td>
                <td><m-b>2</m-b></td>
                <td><m-b>空き領域</m-b>の開始個所のページ先頭からのオフセット</td>
            </tr>
            <tr>
                <td><m-b>pg_upper</m-b></td>
                <td><m-b>2</m-b></td>
                <td><m-b>空き領域</m-b>の終了個所のページ先頭からのオフセット</td>
            </tr>
            <tr>
                <td><m-b>pg_special</m-b></td>
                <td><m-b>2</m-b></td>
                <td><m-b>特殊な空間</m-b>のページ先頭からのオフセット</td>
            </tr>
            <tr>
                <td><m-b>pg_pagesize_version</m-b></td>
                <td><m-b>2</m-b></td>
                <td>ページサイズおよびレイアウトのバージョン番号の情報</td>
            </tr>
            <tr>
                <td><m-b>pg_prune_xid</m-b></td>
                <td><m-b>4</m-b></td>
                <td>ページ内で最古のトランザクションID</td>
            </tr>
        </tbody>
    </table>
    <h4>アイテムIDデータの構成</h4>
    <table>
        <thead>
            <tr>
                <th>領域名</th>
                <th>長さ(ビット)</th>
                <th>内容</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>lp_off</m-b></td>
                <td><m-b>15</m-b></td>
                <td>対応するタプルの開始オフセット(<m-b>バイト数</m-b>)</td>
            </tr>
            <tr>
                <td><m-b>lp_flags</m-b></td>
                <td><m-b>2</m-b></td>
                <td>
                    タプルの状態を示すビットフラグ
                    <ul class="no-style">
                        <li>0: <m-b>未使用</m-b></li>
                        <li>1: <m-b>使用中</m-b></li>
                        <li>2: <m-b>HOT更新でリダイレクトされている</m-b></li>
                        <li>3: <m-b>無効</m-b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>lp_len</m-b></td>
                <td><m-b>15</m-b></td>
                <td>対応するタプルの長さ(<m-b>バイト数</m-b>)</td>
            </tr>
        </tbody>
    </table>
    <p>
        上記のため、アイテムIDデータ領域全体のサイズは、次式で求められる。
    </p>
    <pre><code>
<m-b>32ビット</m-b>(<m-b>4バイト</m-b>) × ページ内に格納されている行数
    </code></pre>
    <h4>ページ数の概算</h4>
    <p>
        ページサイズを8192バイト、行の想定平均サイズをTS、想定レコード数をRN、FILLFACTORをFFとすると、総ページ数の概算値は次式で求められる。
    </p>
    <pre><code>
総ページの概算値 = <m-b>(RN * TS) / ((8192 * FF) - 24)</m-b>
    </code></pre>

    <h3>テーブルアクセスメソッド</h3>
    <p>
        PostgreSQL12からテーブルアクセスメソッドが導入された。
        これにより、デフォルトのテーブルファイルとは別形式のテーブルファイルを扱うことが可能となった。
        現在PostgreSQLに組み込まれているアクセスメソッドは<m-b>heap</m-b>形式テーブル用のものだけであるが、
        サードパーティが提供している拡張機能では、列指向のテーブルアクセスメソッドなども実装されている。
    </p>

    <h2>その他調査まとめ</h2>

    <h3>関数の変動性分類</h3>
    <p>
        すべての関数は変動性区分を持ち、CREATE FUNCTIONコマンドで指定することができる。
        変動性に関する分類は、オプティマイザによる処理の最適化に影響する。<br>
        変動性の区分は次のものがある。
    </p>
    <table>
        <thead>
            <tr>
                <th>区分</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>VOLATILE</m-b></td>
                <td>
                    データベースの変更を含む、すべてを行うことができる。
                    また、同一引数で呼び出したとしても異なる結果を返すことがある。
                </td>
            </tr>
            <tr>
                <td><m-b>STABLE</m-b></td>
                <td>
                    データベースを変更することができない。
                    また、単一の文内ですべての行に対して同一の引数を渡した場合に同一の結果を返すことが保証される。
                </td>
            </tr>
            <tr>
                <td><m-b>IMMUTABLE</m-b></td>
                <td>
                    データベースを変更することができない。
                    また、同一引数に対する呼び出しは常に同一の結果となる。
                </td>
            </tr>
        </tbody>
    </table>
    <blockquote>
        <a href="https://www.postgresql.jp/docs/9.2/xfunc-volatility.html" target="_blank">
            35.6. 関数の変動性分類
        </a>
    </blockquote>

    <h3>テーブルサイズの取得</h3>
    <p>
        テーブルサイズ(テーブルで使用されるディスク領域)を取得するシステム管理関数は、<m-b>pg_relation_size</m-b>である。
        テーブル名またはテーブルの<m-b>oid</m-b>を引数に渡す。<br>
        ビューを引数に指定した場合、結果は<m-b>0</m-b>となる。
    </p>

    <script src="https://code.jquery.com/jquery-3.7.1.slim.min.js"
        integrity="sha256-kmHvs0B+OpCW5GVHUNjv9rOmY0IvSIRcf7zGUDTDQM8=" crossorigin="anonymous"></script>
    <script src="./asset/script.js"></script>
</body>

</html>