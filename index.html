<!DOCTYPE html>
<html dir="ltr" lang="ja">

<head>
    <meta charset="utf-8">
    <title>OSS-DB Gold Practice</title>
    <meta name="author" content="Moriaki Kogure">
    <link rel="stylesheet" href="./asset/style.css">
    <link rel="icon" href="./asset/favicon.ico">
</head>

<body>
    <h1>OSS-DB Gold Practice</h1>

    <h4>資格概要</h4>
    <blockquote>
        <a href="https://oss-db.jp/outline/gold/v2" target="_blank">OSS-DB Goldのご紹介（Ver.2.0）</a>
    </blockquote>

    <h4>
        以下書籍の内容まとめ + 調査したことまとめ
    </h4>
    <blockquote>
        <a href="https://gihyo.jp/book/2022/978-4-297-13206-4" target="_blank">
            ［改訂3版］内部構造から学ぶPostgreSQL ― 設計・運用計画の鉄則
        </a>
    </blockquote>

    <h4>学習進捗</h4>
    <div>
        <span id="practice-progress"></span>
        <button id="reset-btn">進捗リセット</button>
    </div>

    <h4>
        <span>コンテンツ</span>
        <div class="toggle-box-wrapper">
            <input type="checkbox" class="toggle-box" id="toggle-show-complete-content">
            <label for="toggle-show-complete-content" class="toggle-box-label">学習済みコンテンツを表示</label>
        </div>
    </h4>
    <div id="page-tree"></div>

    <h2>2章 アーキテクチャの基本</h2>

    <h3>プロセスの構成</h3>
    <table>
        <thead>
            <tr>
                <th>プロセス名</th>
                <th>psコマンドの表示</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>マスタサーバ</mask-block></td>
                <td>起動コマンドそのものが表示</td>
                <td>最初に起動される親プロセス</td>
            </tr>
            <tr>
                <td><mask-block>ロガー</mask-block></td>
                <td><m-b>logger</m-b></td>
                <td>サーバログを書き出す</td>
            </tr>
            <tr>
                <td><mask-block>チェックポインタ</mask-block></td>
                <td><m-b>checkpointer</m-b></td>
                <td>すべてのダーティページをデータファイルに書き出す</td>
            </tr>
            <tr>
                <td><mask-block>ライタ</mask-block></td>
                <td><m-b>background writer</m-b></td>
                <td>共有バッファの内容をデータファイルに書き出す</td>
            </tr>
            <tr>
                <td><mask-block>WALライタ</mask-block></td>
                <td><m-b>walwriter</m-b></td>
                <td>WALバッファの内容をWALファイルに書き出す</td>
            </tr>
            <tr>
                <td><mask-block>自動バキュームランチャ</mask-block></td>
                <td><m-b>autovacuum launcher</m-b></td>
                <td>設定に従って自動バキュームワーカを起動する</td>
            </tr>
            <tr>
                <td><mask-block>自動バキュームワーカ</mask-block></td>
                <td><m-b>autovacuum worker</m-b></td>
                <td>設定に従って自動バキューム処理を行う</td>
            </tr>
            <tr>
                <td><mask-block>統計情報コレクタ</mask-block></td>
                <td><m-b>stats collector</m-b></td>
                <td>データベースの活動状況に関する統計情報を収集する</td>
            </tr>
            <tr>
                <td><mask-block>バックグラウンドワーカ</mask-block></td>
                <td>モジュール名が表示される</td>
                <td>ロジカルレプリケーション用、またはユーザ定義のワーカ</td>
            </tr>
            <tr>
                <td><mask-block>バックエンドプロセス</mask-block></td>
                <td class="wrappable">
                    <nobr><m-b>ユーザ名 データベース名 [接続] 状態</m-b></nobr><br>というフォーマットで出力される
                </td>
                <td>クライアントからの接続要求に対して起動され、クエリを処理する</td>
            </tr>
            <tr>
                <td><mask-block>パラレルワーカ</mask-block></td>
                <td class="wrappable"><m-b>parallel workder for プロセスID</m-b><br>というフォーマットで出力される</td>
                <td>パラレルスキャン実行時に起動され、クエリを処理する</td>
            </tr>
        </tbody>
    </table>

    <h3>共有メモリ域</h3>
    <table>
        <thead>
            <tr>
                <th>メモリ名</th>
                <th>物理名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>共有バッファ</mask-block></td>
                <td><mask-block>shared_buffers</mask-block></td>
                <td>テーブルやインデックスのデータをキャッシュする領域</td>
            </tr>
            <tr>
                <td><mask-block>WALバッファ</mask-block></td>
                <td><mask-block>wal_buffers</mask-block></td>
                <td>ディスクに書き込まれていないトランザクションログをキャッシュする領域</td>
            </tr>
            <tr>
                <td><mask-block>空き領域マップ</mask-block></td>
                <td><mask-block>Free Space Map</mask-block></td>
                <td>テーブル上の利用可能な領域を示す情報を扱う領域</td>
            </tr>
            <tr>
                <td><mask-block>可視性マップ</mask-block></td>
                <td><mask-block>Visibility Map</mask-block></td>
                <td>テーブルのデータが可視であるか否かを管理する情報を扱う領域</td>
            </tr>
        </tbody>
    </table>

    <h3>プロセスメモリ域</h3>
    <table>
        <thead>
            <tr>
                <th>メモリ名</th>
                <th>物理名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>作業メモリ</mask-block></td>
                <td><mask-block>work_mem</mask-block></td>
                <td>クエリ実行時に行われる、並び替えとハッシュテーブル操作のために使われる領域</td>
            </tr>
            <tr>
                <td><mask-block>メンテナンス用作業メモリ</mask-block></td>
                <td><mask-block>maintenance_work_mem</mask-block></td>
                <td>バキューム、インデックス作成、外部キー作成などの、データベースメンテナンスの操作で使用する領域</td>
            </tr>
            <tr>
                <td><mask-block>一時バッファ</mask-block></td>
                <td><mask-block>temp_buffers</mask-block></td>
                <td>バックエンドプロセス毎に作成される一時テーブルにアクセスするときに用いるメモリ領域</td>
            </tr>
        </tbody>
    </table>

    <h3>主なディレクトリ</h3>
    <table>
        <thead>
            <tr>
                <th>ディレクトリ名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>base</mask-block></td>
                <td>
                    データベースごとに作成されるディレクトリがまとめて格納されるディレクトリ<br>
                    データベースごとのディレクトリは、データベースの<m-b>oid</m-b>で命名される。
                </td>
            </tr>
            <tr>
                <td><mask-block>global</mask-block></td>
                <td>データベースクラスタで共有するテーブルを保有するディレクトリ</td>
            </tr>
            <tr>
                <td><mask-block>pg_wal</mask-block></td>
                <td>WALファイルを格納するディレクトリ</td>
            </tr>
            <tr>
                <td><mask-block>pg_xact</mask-block></td>
                <td>トランザクションのコミット状態を管理するファイルが格納されるディレクトリ</td>
            </tr>
            <tr>
                <td><mask-block>pg_tblspc</mask-block></td>
                <td>テーブル空間として作成されたディレクトリへのシンボリックリンクを格納するディレクトリ</td>
            </tr>
        </tbody>
    </table>

    <h3>主なファイル</h3>
    <table>
        <thead>
            <tr>
                <th>ファイル</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>PG_VERSION</mask-block></td>
                <td>PostgreSQLのメジャーバージョンが書き込まれるテキストファイル</td>
            </tr>
            <tr>
                <td><mask-block>テーブルファイル</mask-block></td>
                <td>
                    テーブルデータの実態が格納されているファイル<br>
                    <mask-block>8192</mask-block>バイトの<mask-block>ページ</mask-block>と呼ばれる単位で構成される。
                </td>
            </tr>
            <tr>
                <td><mask-block>インデックスファイル</mask-block></td>
                <td>
                    インデックスの情報が格納されているファイル<br>
                    <mask-block>8192</mask-block>バイトの<mask-block>ページ</mask-block>と呼ばれる単位で構成される。
                </td>
            </tr>
            <tr>
                <td><mask-block>TOASTファイル</mask-block></td>
                <td>
                    テーブル内に長大な行を格納する場合に生成される特殊なファイル<br>
                    このファイルが作られるとき、テーブルの格納領域には<mask-block>oid</mask-block>が格納される。
                </td>
            </tr>
            <tr>
                <td><mask-block>Free Space Mapファイル</mask-block></td>
                <td>
                    空き領域を追跡するための情報が格納されたファイル<br>
                    ファイル名は、「テーブル/インデックスのoid_<mask-block>fsm</mask-block>」となる。
                </td>
            </tr>
            <tr>
                <td><mask-block>Visibility Mapファイル</mask-block></td>
                <td>
                    テーブルの可視性を管理するファイル<br>
                    ファイル名は、「テーブルのoid_<mask-block>vm</mask-block>」となる。
                </td>
            </tr>
            <tr>
                <td><mask-block>WALファイル</mask-block></td>
                <td>
                    PostgreSQLに対して行われた更新操作を記録するファイル<br>
                    ファイルは固定サイズで、initdbやpg_ctlコマンド等を用いてクラスタを作成する際に指定する。<br>
                    デフォルトサイズは<mask-block>16MB</mask-block>である。
                </td>
            </tr>
            <tr>
                <td><mask-block>postgresql.conf</mask-block></td>
                <td>PostgreSQL全体の動作を設定するファイル</td>
            </tr>
            <tr>
                <td><mask-block>pg_hba.conf</mask-block></td>
                <td>クライアントからの接続を管理する設定ファイル</td>
            </tr>
            <tr>
                <td><mask-block>postmaster.pid</mask-block></td>
                <td>PostgreSQLの稼働中に作成されるロックファイル</td>
            </tr>
        </tbody>
    </table>

    <h2>3章 各種設定ファイルと基本設定</h2>

    <h3>PostgreSQLの設定ファイル</h3>
    <table>
        <thead>
            <tr>
                <th>ファイル名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>postgresql.conf</mask-block></td>
                <td>PostgreSQL全体の動作を制御する</td>
            </tr>
            <tr>
                <td><mask-block>pg_hba.conf</mask-block></td>
                <td>クライアントからの接続を制御する</td>
            </tr>
            <tr>
                <td><mask-block>pg_ident.conf</mask-block></td>
                <td>ident認証およびGSSAPI認証で使用する</td>
            </tr>
            <tr>
                <td><mask-block>recovery.conf</mask-block></td>
                <td>アーカイブリカバリ用の設定ファイル</td>
            </tr>
            <tr>
                <td><mask-block>pg_service.conf</mask-block></td>
                <td>libpqライブラリの接続情報をサービスとしてまとめて管理する設定ファイル</td>
            </tr>
        </tbody>
    </table>

    <h3>設定ファイルで設定できる型</h3>
    <table>
        <thead>
            <tr>
                <th>型名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>論理型(boolean)</m-b></td>
                <td>
                    真偽値<br>
                    <m-b>on/off</m-b>、<m-b>true/false</m-b>、<m-b>yes/no</m-b>、<m-b>1/0</m-b>を指定できる。<br>
                    大文字と小文字を区別しない。
                </td>
            </tr>
            <tr>
                <td><m-b>浮動小数点型(floating point)</m-b></td>
                <td>小数点を含む数値</td>
            </tr>
            <tr>
                <td><m-b>整数型(integer)</m-b></td>
                <td>
                    小数点を含まない数値<br>
                    PostgreSQL12以降は、整数型の項目にも小数値を指定できる。その場合、最も近い整数値に丸められる。
                </td>
            </tr>
            <tr>
                <td><m-b>文字型(string)</m-b></td>
                <td>
                    任意の文字列<br>
                    空白を含む場合は<m-b>単一引用符</m-b>で囲む必要がある。(含まない場合は囲む必要はない)<br>
                    値に単一引用符を含む場合は、<m-b>二重引用符</m-b>または<m-b>逆引用符</m-b>で囲む。
                </td>
            </tr>
            <tr>
                <td><m-b>列挙型(enum)</m-b></td>
                <td>限定された値の集合</td>
            </tr>
        </tbody>
    </table>

    <h3>単位を指定する文字</h3>
    <table>
        <thead>
            <tr>
                <th>指定対象</th>
                <th>指定する文字</th>
                <th>意味</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="5">メモリ</td>
                <td><m-b>B</m-b></td>
                <td>バイト</td>
            </tr>
            <tr>
                <td><m-b>kB</m-b></td>
                <td>キロバイト</td>
            </tr>
            <tr>
                <td><m-b>MB</m-b></td>
                <td>メガバイト</td>
            </tr>
            <tr>
                <td><m-b>GB</m-b></td>
                <td>ギガバイト</td>
            </tr>
            <tr>
                <td><m-b>TB</m-b></td>
                <td>テラバイト</td>
            </tr>
            <tr>
                <td rowspan="5">時間</td>
                <td><m-b>ms</m-b></td>
                <td>ミリ秒</td>
            </tr>
            <tr>
                <td><m-b>s</m-b></td>
                <td>秒</td>
            </tr>
            <tr>
                <td><m-b>min</m-b></td>
                <td>分</td>
            </tr>
            <tr>
                <td><m-b>h</m-b></td>
                <td>時間</td>
            </tr>
            <tr>
                <td><m-b>d</m-b></td>
                <td>日</td>
            </tr>
        </tbody>
    </table>

    <h3>pg_hba.confの接続方式に指定できるキーワード</h3>
    <table>
        <thead>
            <tr>
                <th>キーワード</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>local</m-b></td>
                <td>Unixドメインソケットを使用する接続方式</td>
            </tr>
            <tr>
                <td><m-b>host</m-b></td>
                <td>
                    TCP/IPを利用した接続方式<br>
                    SSL通信の有無は問わない。
                </td>
            </tr>
            <tr>
                <td><m-b>hostssl</m-b></td>
                <td>SSLを用いた通信方式</td>
            </tr>
            <tr>
                <td><m-b>hostnossl</m-b></td>
                <td>SSLを用いない通信方式</td>
            </tr>
            <tr>
                <td><m-b>hostgssenc</m-b></td>
                <td>TCP/IPを使用し、かつGSSAPI通信を使用した接続方式</td>
            </tr>
            <tr>
                <td><m-b>hostnogssenc</m-b></td>
                <td>TCP/IPを使用し、かつGSSAPI通信を使用しない接続方式</td>
            </tr>
        </tbody>
    </table>

    <h3>pg_hba.confの接続データベースに指定できるキーワード</h3>
    <table>
        <thead>
            <tr>
                <th>キーワード</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>all</m-b></td>
                <td>すべてのデータベースへの接続に対応する</td>
            </tr>
            <tr>
                <td><m-b>sameuser</m-b></td>
                <td>指定したユーザと同名のデータベースへの接続に対応する</td>
            </tr>
            <tr>
                <td><m-b>samerole</m-b></td>
                <td>指定したユーザが所属するロールと同名のデータベースへの接続に対応する</td>
            </tr>
            <tr>
                <td><m-b>replication</m-b></td>
                <td>レプリケーション接続に対応する</td>
            </tr>
            <tr>
                <td><m-b>@ファイルパス</m-b></td>
                <td>
                    データベース名を含むファイルを指定する<br>
                    pg_hba.confファイルが存在するディレクトリからの相対パス、または絶対パスで指定する。
                </td>
            </tr>
        </tbody>
    </table>

    <h3>特殊な名前のデータベース名/ユーザ名について</h3>
    <p>
        PostgreSQLでは、データベース名やユーザ名に<code>all</code>などの予約語を指定することを禁止していない。
        予約語のデータベース名/ユーザ名が存在する場合も、設定ファイルに予約語を指定した場合の挙動は変わらない。
        設定ファイルで予約語のデータベース名/ユーザ名を指定する場合、<m-b>二重引用符</m-b>を用いることができる。
    </p>

    <h3>pg_hba.confの認証方式に指定できるキーワード</h3>
    <table>
        <thead>
            <tr>
                <th>種別</th>
                <th>キーワード</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="2">無条件</td>
                <td><m-b>trust</m-b></td>
                <td>接続を無条件で許可する</td>
            </tr>
            <tr>
                <td><m-b>reject</m-b></td>
                <td>接続を無条件で拒否する</td>
            </tr>
            <tr>
                <td rowspan="3">パスワード認証</td>
                <td><m-b>md5</m-b></td>
                <td>
                    md5暗号化によるパスワード認証を行う<br>
                    主に、scram-sha-256による暗号化が使用できない環境で使用する。
                </td>
            </tr>
            <tr>
                <td><m-b>password</m-b></td>
                <td>
                    平文によるパスワード認証を行う<br>
                    非推奨
                </td>
            </tr>
            <tr>
                <td><m-b>scram-sha-256</m-b></td>
                <td>
                    scram-sha-256暗号化によるパスワード認証を行う<br>
                    パスワード認証方式で推奨される認証方式
                </td>
            </tr>
            <tr>
                <td><m-b>GSSAPI認証</m-b></td>
                <td><m-b>gss</m-b></td>
                <td>
                    GSSAPIによる認証を行う<br>
                    <m-b>Linux</m-b>環境かつTCP/IP接続でのみ使用できる。
                </td>
            </tr>
            <tr>
                <td><m-b>SSPI認証</m-b></td>
                <td><m-b>sspi</m-b></td>
                <td>
                    sspiによる認証を行う<br>
                    <m-b>Windows</m-b>環境でのみ使用できる。
                </td>
            </tr>
            <tr>
                <td><m-b>Ident認証</m-b></td>
                <td><m-b>ident</m-b></td>
                <td>
                    クライアントOSの<m-b>ユーザ名</m-b>をidentサーバから入手してデータベース接続ユーザ名として使用する
                </td>
            </tr>
            <tr>
                <td><m-b>Peer認証</m-b></td>
                <td><m-b>peer</m-b></td>
                <td>
                    OSの<m-b>ユーザ名</m-b>をカーネルから入手してデータベース接続ユーザ名として使用する
                </td>
            </tr>
            <tr>
                <td><m-b>LDAP認証</m-b></td>
                <td><m-b>ldap</m-b></td>
                <td>
                    パスワード認証のためにLDAPサーバを使用する
                </td>
            </tr>
            <tr>
                <td><m-b>RADIUS認証</m-b></td>
                <td><m-b>radius</m-b></td>
                <td>
                    パスワード認証のためにRADIUSサーバを使用する
                </td>
            </tr>
            <tr>
                <td><m-b>証明書認証</m-b></td>
                <td><m-b>cert</m-b></td>
                <td>
                    SSLクライアント証明書を使った認証を行う
                </td>
            </tr>
            <tr>
                <td><m-b>PAM認証</m-b></td>
                <td><m-b>pam</m-b></td>
                <td>
                    パスワード認証のためにPAMを使用する
                </td>
            </tr>
            <tr>
                <td><m-b>BSD認証</m-b></td>
                <td><m-b>bsd</m-b></td>
                <td>
                    OSによって提供されたBSD認証サービスを使用する
                </td>
            </tr>
        </tbody>
    </table>

    <h3>pg_ident.confの使い方</h3>
    <p>
        マッピング名を<code>foo_ident</code>、OSユーザ名を<code>foo</code>、マッピングするデータベース名を<code>user1</code>とするとき、
        pg_ident.confは次のように記述する。
    </p>
    <h4>pg_ident.conf</h4>
    <pre><code>
# map-name system-user-name database-user-name
<m-b>foo_ident</m-b> <m-b>foo</m-b> <m-b>user1</m-b>
    </code></pre>
    <p>また、ident認証で上記のマッピングを使用する場合、pg_hba.confには次のように記述する。</p>
    <h4>pg_hba.conf</h4>
    <pre><code>
# TYPE DATABASE USER METHOD
host all all 192.168.10.0/24 <m-b>ident map=foo_indent</m-b>
    </code></pre>

    <h2>4章 処理/制御の基本</h2>

    <h3>問い合わせ処理の流れ</h3>
    <table>
        <thead>
            <tr>
                <th>処理名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>パーサ</m-b></td>
                <td>
                    問い合わせのはじめに、字句解析と構文解析を行う処理<br>
                    字句解析では、OSSである<m-b>flex</m-b>を用いて処理を行い、
                    <m-b>./backend/parser/scan.l</m-b>というファイルにルールを定義する。<br>
                    構文解析では、OSSである<m-b>bison</m-b>を用いて処理を行い、
                    <m-b>./backend/parser/gram.y</m-b>というファイルにルールを定義する。<br>
                    字句解析と構文解析に成功した場合、<m-b>問い合わせツリー</m-b>という構造を生成し、次の処理へと渡す。
                </td>
            </tr>
            <tr>
                <td><m-b>リライタ</m-b></td>
                <td>
                    SQLを実行するデータベースにルールが定義されている場合に、そのルールを参照して問い合わせツリーを書き換える処理<br>
                    PostgreSQLのビューは、このルールを用いて実現されている。
                </td>
            </tr>
            <tr>
                <td><m-b>プランナ/オプティマイザ</m-b></td>
                <td>問い合わせツリーをもとに最適な実行計画を生成する処理</td>
            </tr>
            <tr>
                <td><m-b>エグゼキュータ</m-b></td>
                <td>実行計画に従って必要な行の集合を抽出する処理</td>
            </tr>
        </tbody>
    </table>

    <h3>トランザクションの特性</h3>
    <table>
        <thead>
            <tr>
                <th>特性</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>原子性(Atomicity)</m-b></td>
                <td>処理の最小単位を定義し、それらの処理がすべて実行されたか、まったく実行されないかのどちらかの結果となること</td>
            </tr>
            <tr>
                <td><m-b>一貫性(Consistency)</m-b></td>
                <td>トランザクションの開始及び終了時点で、業務として規定された整合性を満たすこと</td>
            </tr>
            <tr>
                <td><m-b>独立性(Isolation)</m-b></td>
                <td>作業中のトランザクションによる更新は、確定するまで他のトランザクションから不可視となること</td>
            </tr>
            <tr>
                <td><m-b>永続性(Durability)</m-b></td>
                <td>確定したトランザクションの結果は永続的に保存されること</td>
            </tr>
        </tbody>
    </table>

    <h3>トランザクション分離レベル</h3>
    <table>
        <thead>
            <tr>
                <th>分離レベル</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>READ UNCOMMITED</m-b></td>
                <td>
                    別トランザクションのコミットされていないデータが参照される可能性がある<br>
                    PostgreSQLにおいてはこの実装は存在せず、指定しても<m-b>READ COMMITED</m-b>として扱われる。
                </td>
            </tr>
            <tr>
                <td><m-b>READ COMMITED</m-b></td>
                <td>
                    問い合わせを実行する直前までにコミットされたデータのみを参照する<br>
                    PostgreSQLにおいては、デフォルトの分離レベルとなる。
                </td>
            </tr>
            <tr>
                <td><m-b>REPEATABLE READ</m-b></td>
                <td>トランザクションが開始する直前までにコミットされたデータのみを参照する</td>
            </tr>
            <tr>
                <td><m-b>SERIALIZABLE</m-b></td>
                <td>並列実行された複数のトランザクションの実行であっても、逐次的に扱われたものと同じ結果を要求する</td>
            </tr>
        </tbody>
    </table>

    <h3>分離レベルが不十分な場合に起きる事象</h3>
    <table>
        <thead>
            <tr>
                <th>事象</th>
                <th>抑止できる分離レベル</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>ダーティリード</m-b></td>
                <td><m-b>READ COMMITED</m-b></td>
                <td>
                    同時に実行されている他のトランザクションが書き込んだ、コミット前のデータを読み込んでしまうこと
                </td>
            </tr>
            <tr>
                <td><m-b>反復不能読み取り</m-b></td>
                <td><m-b>REPEATABLE READ</m-b></td>
                <td>
                    同一トランザクション内で複数回読み取りを行い、その結果が別トランザクションの更新の影響で変わってしまうこと
                </td>
            </tr>
            <tr>
                <td><m-b>ファントムリード</m-b></td>
                <td><m-b>SERIALIZABLE</m-b></td>
                <td>
                    同一トランザクション内で複数回読み取りを行い、その結果が別トランザクションの挿入の影響で変わってしまうこと
                </td>
            </tr>
        </tbody>
    </table>

    <h3>ロックモード一覧</h3>
    <table>
        <thead>
            <tr>
                <th>ロックモード</th>
                <th>獲得タイミング</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>ACCESS SHARE</m-b></td>
                <td>
                    <ul>
                        <li>SELECT</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>ROW SHARE</m-b></td>
                <td>
                    <ul>
                        <li>SELECT FOR UPDATE</li>
                        <li>SELECT FOR SHARE</li>
                        <li>SELECT FOR NO KEY UPDATE</li>
                        <li>SELECT FOR KEY SHARE</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>ROW EXCLUSIVE</m-b></td>
                <td>
                    <ul>
                        <li>INSERT</li>
                        <li>UPDATE</li>
                        <li>DELETE</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>SHARE UPDATE EXCLUSIVE</m-b></td>
                <td>
                    <ul>
                        <li>VACUUM</li>
                        <li>ANALYZE</li>
                        <li>CREATE INDEX CONCURRENTLY</li>
                        <li>ALTER TABLE(SET STATISTICS)</li>
                        <li>SET(attr = value)</li>
                        <li>RESET(attr = value)</li>
                        <li>VALIDATE CONSTRAINT</li>
                        <li>CLUSTER ON</li>
                        <li>SET WITHOUT CLUSTER</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>SHARE</m-b></td>
                <td>
                    <ul>
                        <li>CREATE INDEX</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>SHARE ROW EXCLUSIVE</m-b></td>
                <td>
                    同一セッション内での競合を防ぐためのロックモード<br>
                    明示的にこのロックモードを獲得するコマンドはない。
                </td>
            </tr>
            <tr>
                <td><m-b>EXCLUSIVE</m-b></td>
                <td>
                    明示的にこのロックモードを獲得するコマンドはない。
                </td>
            </tr>
            <tr>
                <td><m-b>ACCESS EXCLUSIVE</m-b></td>
                <td>
                    <ul>
                        <li>ALTER TABLE</li>
                        <li>DROP TABLE</li>
                        <li>TRUNCATE</li>
                        <li>REINDEX</li>
                        <li>CLUSTER</li>
                        <li>VACUUM FULL</li>
                        <li>LOCK TABLE</li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>

    <h3>同時実行制御</h3>
    <p>
        PostgreSQLでは、<m-b>追記型アーキテクチャ</m-b>というアーキテクチャを採用することで、
        <m-b>MVCC</m-b>(<m-b>Multi Version Concurrency Control</m-b>)と呼ばれる同時実行制御を実現している。
        追記型アーキテクチャとは、データ更新時にデータを直接書き換えるのではなく、
        トランザクションごとに発行されるID(<m-b>XID</m-b>)をテーブルの各行に保持することで、
        トランザクションごとのデータを保持する仕組みである。<br>
        追記型アーキテクチャの仕様上、不要となるタプルが発生するが、これを整理する処理が<m-b>バキューム</m-b>であり、
        更新前の古いタプルを<m-b>空き領域マップ</m-b>に記録することで、再利用可能とする。<br>
        以前のPostgreSQLではこのバキューム処理の運用が重要な課題となっていたが、PostgreSQL8.3で採用された<m-b>HOT</m-b>(<m-b>Heap Only Tuple</m-b>)や、
        自動バキューム機能の強化により、バキューム処理を意識する必要がなくなった。
    </p>

    <h2>5章 テーブル設計</h2>

    <h3>文字型</h3>
    <table>
        <thead>
            <tr>
                <th>型名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    <m-b>character varying(n)</m-b>、
                    <m-b>varchar(n)</m-b>
                </td>
                <td>上限n文字まで格納可能な可変長データ型</td>
            </tr>
            <tr>
                <td>
                    <m-b>character(n)</m-b>、
                    <m-b>char(n)</m-b>
                </td>
                <td>
                    上限n文字までを格納可能な固定長データ型<br>
                    格納時にn文字に満たない場合は<m-b>末尾</m-b>に空白を付与して格納する。
                    検索時にも空白が付与された結果が取得される。
                </td>
            </tr>
            <tr>
                <td><m-b>text</m-b></td>
                <td>上限指定なしの可変長データ型(最大<m-b>1GB</m-b>まで格納可能)</td>
            </tr>
        </tbody>
    </table>
    <p>
        データ格納時に、次のルールに従ってヘッダ情報が付与される。
    </p>
    <ul>
        <li>文字列長が<m-b>126バイト</m-b>以下の場合、ヘッダ情報として<m-b>1バイト</m-b>使用する</li>
        <li>文字列長が<m-b>127バイト</m-b>以上の場合、ヘッダ情報として<m-b>4バイト</m-b>使用する</li>
        <li>
            非常に長い文字列の(テーブル内に格納される値が<m-b>2kB</m-b>を超える)場合、<m-b>TOAST領域</m-b>に分割して格納される<br>
            特に要件が無ければ、PostgreSQLにおいて文字型として用いることが推奨される。
        </li>
    </ul>

    <h4>char型に対する文字列操作の注意点</h4>
    <p>
        char型の文字列を文字列関数や文字列操作演算子で扱う場合、空白の扱いが異なる場合があるため注意が必要である。<br>
        例えば、char(8)のカラム<code>c</code>と、varchar(8)のカラム<code>v</code>をもつテーブル<code>example</code>に対し、
        concat関数と||演算子を用いた結合では次のような差が生まれる。
    </p>
    <h4>exampleテーブルのタプル</h4>
    <pre><code>
SELECT * FROM example;
    </code></pre>
    <h4>結果</h4>
    <pre><code>
  c |  v
----+-----
hoge|fuga

(1 rows)
    </code></pre>
    <h4>concat関数を用いた場合</h4>
    <pre><code>
SELECT concat(c, v) FROM example;
    </code></pre>
    <h4>結果</h4>
    <pre><code>
  concat
----------
<m-b>hoge    fuga</m-b>

(1 rows)
    </code></pre>
    <h4>||演算子を用いた場合</h4>
    <pre><code>
SELECT c || v FROM example;
    </code></pre>
    <h4>結果</h4>
    <pre><code>
  concat
----------
<m-b>hogefuga</m-b>

(1 rows)
    </code></pre>

    <h3>数値型</h3>
    <table>
        <thead>
            <tr>
                <th>型名</th>
                <th>
                    <nobr>格納サイズ</nobr><br>(バイト)
                </th>
                <th>説明</th>
                <th>範囲</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>smallint</m-b></td>
                <td><m-b>2</m-b></td>
                <td>整数データ型</td>
                <td>-32768~32767</td>
            </tr>
            <tr>
                <td><m-b>integer</m-b></td>
                <td><m-b>4</m-b></td>
                <td>整数データ型</td>
                <td>-2147483648~2147483647</td>
            </tr>
            <tr>
                <td><m-b>bigint</m-b></td>
                <td><m-b>8</m-b></td>
                <td>整数データ型</td>
                <td>-9223372036854775808~9223372036854775807</td>
            </tr>
            <tr>
                <td><m-b>decimal</m-b></td>
                <td>可変長</td>
                <td>正確な精度を保持する(小数も指定可)</td>
                <td>整数部は131072桁まで、小数部は16383桁まで</td>
            </tr>
            <tr>
                <td><m-b>numeric</m-b></td>
                <td>可変長</td>
                <td>正確な精度を保持する(小数も指定可)</td>
                <td>整数部は131072桁まで、小数部は16383桁まで</td>
            </tr>
            <tr>
                <td><m-b>real</m-b></td>
                <td><m-b>4</m-b></td>
                <td colspan="2">
                    <m-b>6</m-b>桁の精度を持つ不正確なデータ型(小数も指定可)<br>
                    IEEE規格754の形式で格納する。
                </td>
            </tr>
            <tr>
                <td><m-b>double precision</m-b></td>
                <td><m-b>8</m-b></td>
                <td colspan="2">
                    <m-b>15</m-b>桁の精度を持つ不正確なデータ型(小数も指定可)<br>
                    IEEE規格754の形式で格納する。
                </td>
            </tr>
            <tr>
                <td><m-b>smallserial</m-b></td>
                <td><m-b>2</m-b></td>
                <td rowspan="3" colspan="2">
                    連番型<br>
                    内部にシーケンスを作成し、デフォルト値としてシーケンスから払い出された値を設定する。
                </td>
            </tr>
            <tr>
                <td><m-b>serial</m-b></td>
                <td><m-b>4</m-b></td>
            </tr>
            <tr>
                <td><m-b>bigserial</m-b></td>
                <td><m-b>8</m-b></td>
            </tr>
        </tbody>
    </table>

    <h3>日付/時刻データ型</h3>
    <table>
        <thead>
            <tr>
                <th>型名</th>
                <th>
                    <nobr>格納サイズ</nobr><br>(バイト)
                </th>
                <th>説明</th>
                <th>範囲</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>timestamp [without timezone]</m-b></td>
                <td><m-b>8</m-b></td>
                <td>日付と時刻を保持する<br>(タイムゾーンなし)</td>
                <td>紀元前4713年~西暦294276年</td>
            </tr>
            <tr>
                <td><m-b>timestamp with time zone</m-b></td>
                <td><m-b>8</m-b></td>
                <td>日付と時刻を保持する<br>(タイムゾーンあり)</td>
                <td>紀元前4713年~西暦294276年</td>
            </tr>
            <tr>
                <td><m-b>date</m-b></td>
                <td><m-b>4</m-b></td>
                <td>日付を保持する</td>
                <td>紀元前4713年~西暦5874897年</td>
            </tr>
            <tr>
                <td><m-b>time [without timezone]</m-b></td>
                <td><m-b>8</m-b></td>
                <td>時刻を保持する</td>
                <td>00:00:00~24:00:00</td>
            </tr>
            <tr>
                <td><m-b>time with time zone</m-b></td>
                <td><m-b>12</m-b></td>
                <td>時刻を保持する</td>
                <td>00:00:00+1459~24:00:00-1459</td>
            </tr>
            <tr>
                <td><m-b>interval [fields]</m-b></td>
                <td><m-b>16</m-b></td>
                <td>時間間隔を保持する</td>
                <td>-178000000年~178000000年</td>
            </tr>
        </tbody>
    </table>

    <h3>タイムゾーンの指定方式</h3>
    <table>
        <thead>
            <tr>
                <th>指定方式</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>正式名</m-b>の指定</td>
                <td>
                    大文字/小文字を区別しない。<br>
                    対象の一覧は、システムカタログの<m-b>pg_timezone_names</m-b>ビューから確認できる。
                </td>
            </tr>
            <tr>
                <td><m-b>略称</m-b>の指定</td>
                <td>
                    大文字/小文字を区別しない。<br>
                    対象の一覧は、システムカタログの<m-b>pg_timezone_names</m-b>ビュー、
                    または<m-b>pg_timezone_abbrevs</m-b>ビューから確認できる。
                </td>
            </tr>
            <tr>
                <td><m-b>オフセット</m-b>の指定</td>
                <td>
                    略称とオフセットを指定する。
                </td>
            </tr>
        </tbody>
    </table>

    <h3>バイナリ列データ型</h3>
    <p>
        バイナリ列データ型を扱う場合は、基本的に<m-b>bytea</m-b>型を使用するが、
        格納するデータサイズが非常に大きい場合や、データの一部のみを書き換える使い方を想定する場合、
        <m-b>ラージオブジェクト</m-b>の使用を検討する。
        bytea型では、<m-b>1GB</m-b>までしか格納できないが、ラージオブジェクトでは<m-b>4TB</m-b>まで格納できる。
        性能の観点から、格納するデータ量が<m-b>100kB</m-b>までの場合はbytea型を、
        それ以上の場合はラージオブジェクトを使用することが推奨されている。
    </p>

    <h3>ラージオブジェクトについて</h3>
    <p>
        ラージオブジェクトは管理方法やアクセス方法がbytea型とは根本的に異なる。
        テーブル定義上は、ラージオブジェクトへのポインタとなる<m-b>oid</m-b>の列を定義する。<br>
        ラージオブジェクトの実体は、システムカタログの<m-b>pg_largeobject</m-b>にある。
        ここでは、<m-b>2kB</m-b>のチャンクに分割して格納されている。<br>
        また、ラージオブジェクトのメタ情報を扱うシステムカタログとして、<m-b>pg_largeobject_metadata</m-b>がある。
        ここでは、所有者やアクセス権限を管理する。
    </p>

    <h3>JSON型とJSONB型について</h3>
    <p>
        PostgreSQL9.4より、JSON型のみでなくJSONB型が追加された。
        JSON型とJSONB型はどちらもJSONデータを扱うデータ型だが、格納方法に違いがある。
        JSONB型では、JSON演算を高速にするため<m-b>バイナリ</m-b>形式に変換されて格納される。
        このため、挿入処理は<m-b>JSON型</m-b>の方が、演算子を用いた検索処理は<m-b>JSONB型</m-b>の方が高速となる。
        用途に応じて使い分ける。
    </p>

    <h3>型名のエイリアス</h3>
    <p>
        PostgreSQLでは、異なる名称で同じ意味を示すデータ型がいくつか存在する。<br>
        例えば、数値型では、<m-b>int2</m-b>(smallintと同義)、<m-b>int4</m-b>(integherと同義)、
        <m-b>int8</m-b>(bigintと同義)、<m-b>decimal</m-b>(numericと同義)、<m-b>float</m-b>(double precisionと同義)
        などがある。<br>
        なお、PostgreSQLのシステムカタログ(<m-b>pg_type.typename</m-b>)上では、SQL標準規定でない型名が定義されている場合がある。
        しかしその場合でも、psqlの<code>\d</code>メタコマンド等で列情報を確認すると、SQL標準規定の型名で表示される。
        これは、<m-b>pg_catalog.format_type()</m-b>で変換を行っているためである。
    </p>

    <h3>外部キー制約について</h3>
    <h4>参照先の削除/更新時の動作指定</h4>
    <p>
        外部キー制約を指定する際、参照先のタプルを削除/更新するときの動作を、
        それぞれ<m-b>ON DELETE</m-b>句、<m-b>ON UPDATE</m-b>句で指定することができる。
        指定できる具体的な操作は、次の表の通り。
    </p>
    <table>
        <thead>
            <tr>
                <th>キーワード</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>CASCADE</m-b></td>
                <td>参照先のタプルが削除されたとき、伴って参照しているタプルも削除する</td>
            </tr>
            <tr>
                <td><m-b>RESTRICT</m-b></td>
                <td>
                    参照するタプルが残っている状態で、参照先のタプルが削除されることを防ぐ<br>
                    削除処理が行われたタイミングでエラーが発生する。
                </td>
            </tr>
            <tr>
                <td><m-b>NO ACTION</m-b></td>
                <td>
                    参照するタプルが残っている状態で、参照先のタプルが削除されても何もしない<br>
                    ただし、これは同一トランザクション内の後続処理で整合性が取られることを前提としている。
                    トランザクションがコミットされたタイミングで外部キーの整合性がとれていない場合、エラーが発生しトランザクションはロールバックされる。
                </td>
            </tr>
            <tr>
                <td><m-b>SET NULL</m-b></td>
                <td>参照先のタプルが削除されたとき、参照しているタプルの外部キー列にNULLを設定する</td>
            </tr>
            <tr>
                <td><m-b>SET DEFAULT</m-b></td>
                <td>
                    参照先のタプルが削除されたとき、参照しているタプルの外部キー列にデフォルト値を設定する<br>
                    ただし、デフォルト値が外部キー制約を満たさない場合、エラーが発生する。
                </td>
            </tr>
        </tbody>
    </table>
    <h4>外部キー制約の注意点</h4>
    <p>
        外部キー制約を用いる場合、次の2点に注意する必要がある。<br>
        1点目は、外部キーには暗黙的な<m-b>インデックス</m-b>が設定されないため、明示的に<m-b>インデックス</m-b>を作成する必要があることである。
        参照先の列が主キーの場合でも、参照元の外部キー列で暗黙的にインデックスが作成されることはない。<br>
        2点目は、テーブル間で外部キーの<m-b>型</m-b>を一致させることである。
        通常、異なる型で外部キーを作成することはできないが、<m-b>型変換</m-b>や<m-b>関数</m-b>を用いることで異なる型の外部キーを設定することも可能である。
    </p>

    <h3>生成列について</h3>
    <p>
        生成列はPostgreSQL12から追加された機能で、他の列を用いて計算した値をデフォルト値として設定できる。
        例えば、以下のようにScoreの合計列totalを定義することができる。
    </p>
    <pre><code>
CREATE TABLE score(
    student_id bigint UNIQUE,
    japanese integer DEFAULT 0,
    math integer DEFAULT 0,
    english integer DEFAULT 0,
    total integer <m-b>GENERATED ALWAYS AS</m-b> (japanese + math + english) <m-b>STORED</m-b>
)
    </code></pre>
    <p>
        挿入/更新時、生成列に値を指定することはできないが、キーワード<m-b>DEFAULT</m-b>を指定することができ、生成列の定義に則った値の計算が行われる。<br>
        生成列は、次の制約が存在する。
    </p>
    <ul>
        <li>生成列は不変関数のみを使用でき、副問い合わせや現在のタプル以外への参照は使用できない</li>
        <li>生成列は他の生成列を参照できない</li>
        <li>生成列は<m-b>tableoid</m-b>以外のシステム列を参照できない</li>
    </ul>

    <h3>TOASTを意識したテーブル設計</h3>
    <p>
        TOASTとは、<m-b>The Oversized-Attribute Storage Technique</m-b>の略で、<m-b>過大属性格納技法</m-b>の意である。
        大きな列の値を格納する際の実装技法である。<br>
        TOAST化は、行のサイズが<m-b>2kB</m-b>を超えるときに実行され、TOASTと呼ばれる特殊領域にデータを配置し、テーブルブロックではその参照情報を持つ。
        TOAST化の処理では、行サイズが<m-b>2kB</m-b>より小さくなるまで個々の列の値を圧縮し、別領域に移動しようとする。
        TOASTの格納方法は次の4種類があり、データタイプごとにデフォルトが決められている。
    </p>
    <table>
        <thead>
            <tr>
                <th>格納方法</th>
                <th>対応する主なデータ型</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>PLAIN</m-b></td>
                <td>
                    <ul>
                        <li><m-b>INTEGER</m-b></li>
                        <li><m-b>FLOAT</m-b></li>
                        <li><m-b>DOUBLE PRECISION</m-b></li>
                        <li><m-b>DATE</m-b></li>
                        <li><m-b>TIMESTAMP</m-b></li>
                    </ul>
                </td>
                <td>
                    圧縮や行外への格納を行わない<br>
                    固定長データ型など、TOAST不可能なデータ型に適用する。
                </td>
            </tr>
            <tr>
                <td><m-b>EXTENDED</m-b></td>
                <td>
                    <ul>
                        <li><m-b>CHAR(n)</m-b></li>
                        <li><m-b>VARCHAR(n)</m-b></li>
                        <li><m-b>TEXT</m-b></li>
                        <li><m-b>BYTEA</m-b></li>
                        <li><m-b>JSON/JSONB</m-b></li>
                    </ul>
                </td>
                <td>
                    圧縮と行外の格納を行う<br>
                    ほとんどのTOAST可能なデータ型のデフォルトはこの方法である。
                </td>
            </tr>
            <tr>
                <td><m-b>EXTERNAL</m-b></td>
                <td></td>
                <td>
                    非圧縮の行外格納を行う<br>
                    TEXTとBYTEAに対して設定すると、格納領域が増加する代わりに列全体に対する部分文字列操作が高速化される。
                </td>
            </tr>
            <tr>
                <td><m-b>MAIN</m-b></td>
                <td>
                    <ul>
                        <li><m-b>NUMERIC</m-b></li>
                    </ul>
                </td>
                <td>圧縮を行うが、行外の格納は極力行わない</td>
            </tr>
        </tbody>
    </table>
    <p>
        テーブル作成後に格納方法を指定する場合、次のコマンドを実行すればよい。
    </p>
    <pre><code>
ALTER TALBE テーブル名 ALTER 列名 <m-b>SET STORAGE 格納方法</m-b>
    </code></pre>

    <h3>遺伝的問い合わせ最適化</h3>
    <p>
        PostgreSQLのプランナでは、結合方式の最適化のために実行計画を総当たりで評価する。
        このため、テーブルの結合数が増加すると、指数関数的に最適化処理のコストが増加する。<br>
        このため、クエリ内で扱うテーブル数が一定の閾値(通常は<m-b>12</m-b>)を超過すると、<m-b>遺伝的問い合わせ最適化</m-b>という手法で
        実行計画を生成するようになる。
    </p>
    <blockquote>
        <a href="https://www.postgresql.jp/document/8.1/html/geqo-pg-intro.html" target="_blank">
            47.3. PostgreSQLの遺伝的問い合わせ最適化（GEQO）
        </a>
    </blockquote>

    <h3>宣言的パーティショニング</h3>
    <h4>メリット</h4>
    <ul>
        <li>物理的な分割によってデータアクセスの範囲を絞り込めるため、特定条件下でI/O負荷を低減し参照性能の改善が見込める。</li>
        <li>パーティションのDROP/TRUNCATEによって一括削除ができるため、特定条件のDELETEよりも処理時間やマシンリソース消費を抑えることができる。</li>
    </ul>
    <h4>分割方式</h4>
    <table>
        <thead>
            <tr>
                <th>分割方式</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>範囲パーティショニング</m-b></td>
                <td>
                    パーティションキーの範囲に基づいて振り分けを行う方式<br>
                    パーティションキーに指定できる型は<m-b>B-tree</m-b>演算子クラスを持つ型である。
                </td>
            </tr>
            <tr>
                <td><m-b>リストパーティショニング</m-b></td>
                <td>
                    パーティションキーが事前に列挙されたリストに基づいて振り分けを行う方式<br>
                    パーティションキーに指定できる型は<m-b>B-tree</m-b>演算子クラスを持つ型である。
                </td>
            </tr>
            <tr>
                <td><m-b>ハッシュパーティショニング</m-b></td>
                <td>
                    パーティションキーに対しハッシュ値を計算しその余りで振り分けを行うことで、ほぼ均等な振り分けを行う方式<br>
                    パーティションキーに指定できる型は<m-b>ハッシュ</m-b>演算子クラスを持つ型である。
                </td>
            </tr>
        </tbody>
    </table>
    <h4>範囲パーティションニングでパーティションテーブルとパーティションを作成</h4>
    <pre><code>
/* logdateカラムをパーティションキーに指定し、パーティションテーブル作成 */
CREATE TABLE log (
    id bigserial PRIMARY KEY,
    kind text NOT NULL,
    logdate date NOT NULL
) <m-b>PARTITION BY RANGE (logdate)</m-b>;

/* 月ごとの範囲パーティションを作成 */
CREATE TABLE log_202206 <m-b>PARTITION OF log FOR VALUES FROM ('2022-06-01') TO ('2022-07-01')</m-b>;
CREATE TABLE log_202207 <m-b>PARTITION OF log FOR VALUES FROM ('2022-07-01') TO ('2022-08-01')</m-b>;
    </code></pre>
    <h4>リストパーティションニングでパーティションテーブルとパーティションを作成</h4>
    <pre><code>
/* kindカラムをパーティションキーに指定し、パーティションテーブル作成 */
CREATE TABLE log (
    id bigserial PRIMARY KEY,
    kind text NOT NULL,
    logdate date NOT NULL
) <m-b>PARTITION BY LIST (kind)</m-b>;

/* 種別ごとのリストパーティションを作成 */
CREATE TABLE log_app <m-b>PARTITION OF log FOR VALUES IN ('app')</m-b>;
CREATE TABLE log_error <m-b>PARTITION OF log FOR VALUES IN ('error')</m-b>;
    </code></pre>
    <h4>ハッシュパーティションニングでパーティションテーブルとパーティションを作成</h4>
    <pre><code>
/* idカラムをパーティションキーに指定し、パーティションテーブル作成 */
CREATE TABLE log (
    id bigserial PRIMARY KEY,
    kind text NOT NULL,
    logdate date NOT NULL
) <m-b>PARTITION BY HASH (id)</m-b>;

/* idのハッシュ値で均等にパーティションを作成 */
CREATE TABLE log_1 <m-b>PARTITION OF log FOR VALUES WITH (MODULUS 2, REMAINDER 0)</m-b>;
CREATE TABLE log_2 <m-b>PARTITION OF log FOR VALUES WITH (MODULUS 2, REMAINDER 1)</m-b>;
    </code></pre>
    <h4>パーティショニングの要否の判断基準</h4>
    <p>
        次のいずれかの条件を満たす場合、パーティショニングの使用を検討することが推奨される。
    </p>
    <ul>
        <li>テーブルが巨大であるか</li>
        <li>パーティションキーを使用した検索が行われるか</li>
        <li>一括削除の運用が行われるか</li>
    </ul>
    <h4>パーティショニングの設計方針</h4>
    <p>
        <m-b>更新の可能性がある</m-b>カラムはパーティションキーに指定するべきでない。
        これは、パーティションキーが更新されて条件に合うパーティションに移動する処理は、オーバヘッドが大きいためである。<br>
        パーティションをパーティショニングテーブルとして定義し、そのパーティションのことを<m-b>サブパーティション</m-b>と呼ぶ。
        データ量が多く1度のパーティショニングで絞り込みが不足する場合、より細かな単位に分割するサブパーティションの利用を検討する。<br>
        運用の中で参照することはないが、要件上削除することができないパーティションが存在する場合、
        パーティションテーブルから<m-b>DETACH</m-b>することも検討する。
    </p>

    <h2>6章 物理設計</h2>

    <h3>データファイルの実体</h3>
    <p>
        PostgreSQLでは、テーブルもインデックスも<m-b>ファイルノード番号</m-b>で命名されるファイルが実体となる。
        このファイルは基本的に<m-b>8192バイト</m-b>の<m-b>ページ</m-b>と呼ばれる固定長領域が連続して配置されている。
        また、ファイルサイズは最大約<m-b>1GB</m-b>で、これを超える場合は<m-b>連番</m-b>を拡張子とするファイルに分割される。
        そのため、1ファイルの最大ページ数は<m-b>131,072</m-b>ページとなる。<br>
        あるテーブルのファイルノード番号を調べたい場合、次のSQLを実行すればよい。
    </p>
    <pre><code>
SELECT relname, <m-b>relfilenode</m-b>
FROM <m-b>pg_class</m-b>
WHERE relname = 'テーブル名';
    </code></pre>
    <p>
        なお、PostgreSQLで管理できる1つのテーブルやインデックスの最大サイズは<m-b>32TB</m-b>である。
        ただし、テーブルの<m-b>パーティショニング</m-b>を用いれば、それよりも大きいサイズのテーブルを管理することもできる。
    </p>

    <h3>テーブルファイル</h3>
    <h4>テーブルファイルのページ構成</h4>
    <table>
        <thead>
            <tr>
                <th>領域名</th>
                <th>サイズ</th>
                <th>内容</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>ページヘッダ</m-b></td>
                <td><m-b>24バイト</m-b></td>
                <td>
                    ページ内の管理情報と次ページに対する最近の更新情報(<m-b>WAL</m-b>に関する情報)
                </td>
            </tr>
            <tr>
                <td><m-b>アイテムIDデータ</m-b></td>
                <td><m-b>可変</m-b></td>
                <td>
                    アイテムのオフセットや長さ、アイテムの属性情報
                </td>
            </tr>
            <tr>
                <td><m-b>空き領域</m-b></td>
                <td><m-b>可変</m-b></td>
                <td>
                    アイテムデータ末尾とアイテム先頭の間の使用されない領域<br>
                    <m-b>FILLFACTOR</m-b>の設定で、データ挿入時に使用可能な空き領域の割合が変動する。
                </td>
            </tr>
            <tr>
                <td><m-b>アイテム</m-b></td>
                <td><m-b>可変</m-b></td>
                <td>
                    タプルの実体<br>
                    空き領域の末尾から格納される。格納の向きは、<m-b>ページ末尾からページ先頭</m-b>に向かう方向。
                </td>
            </tr>
            <tr>
                <td><m-b>特殊な空間</m-b></td>
                <td><m-b>可変</m-b></td>
                <td>
                    空き領域の後に配置される<br>
                    ページ内容が<m-b>インデックス</m-b>の場合に配置される。
                </td>
            </tr>
        </tbody>
    </table>
    <h4>ページヘッダの構成</h4>
    <table>
        <thead>
            <tr>
                <th>領域名</th>
                <th>長さ(バイト)</th>
                <th>内容</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>pd_lsn</m-b></td>
                <td><m-b>8</m-b></td>
                <td><m-b>LSN</m-b>(<m-b>Log Sequence Number</m-b>:このページに対して行われた最後の更新ログの位置)</td>
            </tr>
            <tr>
                <td><m-b>pd_checksum</m-b></td>
                <td><m-b>2</m-b></td>
                <td>ページのチェックサム</td>
            </tr>
            <tr>
                <td><m-b>pg_flags</m-b></td>
                <td><m-b>2</m-b></td>
                <td>フラグ(ビット列)の格納領域</td>
            </tr>
            <tr>
                <td><m-b>pg_lower</m-b></td>
                <td><m-b>2</m-b></td>
                <td><m-b>空き領域</m-b>の開始個所のページ先頭からのオフセット</td>
            </tr>
            <tr>
                <td><m-b>pg_upper</m-b></td>
                <td><m-b>2</m-b></td>
                <td><m-b>空き領域</m-b>の終了個所のページ先頭からのオフセット</td>
            </tr>
            <tr>
                <td><m-b>pg_special</m-b></td>
                <td><m-b>2</m-b></td>
                <td><m-b>特殊な空間</m-b>のページ先頭からのオフセット</td>
            </tr>
            <tr>
                <td><m-b>pg_pagesize_version</m-b></td>
                <td><m-b>2</m-b></td>
                <td>ページサイズおよびレイアウトのバージョン番号の情報</td>
            </tr>
            <tr>
                <td><m-b>pg_prune_xid</m-b></td>
                <td><m-b>4</m-b></td>
                <td>ページ内で最古のトランザクションID</td>
            </tr>
        </tbody>
    </table>
    <h4>アイテムIDデータの構成</h4>
    <table>
        <thead>
            <tr>
                <th>領域名</th>
                <th>長さ(ビット)</th>
                <th>内容</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>lp_off</m-b></td>
                <td><m-b>15</m-b></td>
                <td>対応するタプルの開始オフセット(<m-b>バイト数</m-b>)</td>
            </tr>
            <tr>
                <td><m-b>lp_flags</m-b></td>
                <td><m-b>2</m-b></td>
                <td>
                    タプルの状態を示すビットフラグ
                    <ul class="no-style">
                        <li>0: <m-b>未使用</m-b></li>
                        <li>1: <m-b>使用中</m-b></li>
                        <li>2: <m-b>HOT更新でリダイレクトされている</m-b></li>
                        <li>3: <m-b>無効</m-b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>lp_len</m-b></td>
                <td><m-b>15</m-b></td>
                <td>対応するタプルの長さ(<m-b>バイト数</m-b>)</td>
            </tr>
        </tbody>
    </table>
    <p>
        上記のため、アイテムIDデータ領域全体のサイズは、次式で求められる。
    </p>
    <pre><code>
<m-b>32ビット</m-b>(<m-b>4バイト</m-b>) × ページ内に格納されている行数
    </code></pre>
    <h4>ページ数の概算</h4>
    <p>
        ページサイズを8192バイト、行の想定平均サイズをTS、想定レコード数をRN、FILLFACTORをFFとすると、総ページ数の概算値は次式で求められる。
    </p>
    <pre><code>
総ページの概算値 = <m-b>(RN * TS) / ((8192 * FF) - 24)</m-b>
    </code></pre>

    <h3>テーブルアクセスメソッド</h3>
    <p>
        PostgreSQL12からテーブルアクセスメソッドが導入された。
        これにより、デフォルトのテーブルファイルとは別形式のテーブルファイルを扱うことが可能となった。
        現在PostgreSQLに組み込まれているアクセスメソッドは<m-b>heap</m-b>形式テーブル用のものだけであるが、
        サードパーティが提供している拡張機能では、列指向のテーブルアクセスメソッドなども実装されている。
    </p>

    <h3>インデックスファイル</h3>
    <p>
        インデックスファイルにおけるページ構成は、テーブルファイルとほぼ同じであるが、
        各ページの末尾に<m-b>特別な領域</m-b>を持ち、行の代わりに<m-b>インデックスエントリ</m-b>が格納される点で異なる。<br>
        また、ファイルは次のページ群で構成される。
    </p>
    <table>
        <thead>
            <tr>
                <th>ページ種別</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>メタページ</m-b></td>
                <td>メタ情報を扱う</td>
            </tr>
            <tr>
                <td><m-b>ルートページ</m-b></td>
                <td>インデックスを構成するツリーの根ノードにあたる</td>
            </tr>
            <tr>
                <td><m-b>インターナルページ</m-b></td>
                <td>インデックスを構成するツリーの枝ノードにあたる</td>
            </tr>
            <tr>
                <td><m-b>リーフページ</m-b></td>
                <td>インデックスを構成するツリーの葉ノードにあたる</td>
            </tr>
        </tbody>
    </table>

    <h3>テーブルファイルに対するアクセス</h3>
    <table>
        <thead>
            <tr>
                <th>アクセス方法</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>シーケンシャルアクセス</m-b></td>
                <td>
                    テーブルファイルのすべてのページを順々に参照するアクセス方法<br>
                    条件を与えない検索や、インデックスを使用しない場合に使用される。
                    テーブルファイルのサイズに応じてほぼ線形に処理時間が増大し、更新によって発生した不要タプルの影響も受ける。
                </td>
            </tr>
            <tr>
                <td><m-b>インデックスアクセス</m-b></td>
                <td>
                    インデックスを用いたアクセス方法<br>
                    インデックスをたどり、インデックスの<m-b>葉ノード</m-b>に設定されたテーブルファイルへのポインタから
                    テーブルファイルの特定のページを取得する。
                    テーブルサイズによる性能の影響は小さくなるが、ファイルに対する<m-b>ランダムアクセス</m-b>が頻発することになる。
                </td>
            </tr>
        </tbody>
    </table>

    <h3>WALファイル</h3>
    <p>
        WALファイルは<m-b>先行書き込みログ</m-b>(<m-b>WAL</m-b>:<m-b>Write Ahead Logging</m-b>)が格納される非常に重要なログファイルである。
        更新要求があった場合、まず更新ログをWALバッファに書き込む。
        そして<m-b>トランザクションがコミット</m-b>される、または<m-b>WALバッファがあふれる</m-b>場合に、WALバッファの内容をWALファイルに書き込む。<br>
        WALファイルは固定長(デフォルト:<m-b>16MB</m-b>)単位のファイルとして作成され、サイズは変動しない。
        サイズを変更する場合、initdbやpg_ctl等でデータベースクラスタを作成するときに、<m-b>--wal-segsize</m-b>オプションを指定する。
        書き込み方式は<m-b>シーケンシャルライト</m-b>である。<br>
        WALファイルの総ファイルサイズの上限は、パラメータ<m-b>max_wal_size</m-b>によって決まる。
        WALファイルの領域は、少なくとも<m-b>max_wal_size</m-b>分の容量が必要であるが、書き込み負荷状況やアーカイブに失敗するケースなどで上限を超過する場合もある。
        レプリケーション構成の場合、パラメータ<m-b>wal_keep_size</m-b>の設定も考慮したWALファイル領域の容量を設計する必要がある。
        チェックポイントが動作するWALファイル数には、パラメータ<m-b>checkpoint_completion_target</m-b>も関与していて、次式で求められる。
    </p>
    <pre><code>
チェックポイントが動作するWALファイル数 = <m-b>(max_wal_size / 16MB) / (1 + checkpoint_completion_target)</m-b>
    </code></pre>
    <p>
        アーカイブされたWALファイルは不要となり、<m-b>チェックポイント</m-b>を契機に削除または再利用される。
        再利用とは、WALファイル自体を削除せず、今後発生するWALの書き込み用ファイルとして残すことである。
        上書きするとき、ファイル名はリネームされる。<br>
        パラメータ<m-b>min_wal_size</m-b>の設定が<m-b>max_wal_size</m-b>より小さい場合、チェックポイント契機で<m-b>min_wal_size</m-b>を超えるWALファイルは削除される。
    </p>

    <h3>アーカイブファイル</h3>
    <p>
        アーカイブファイルは、<m-b>PITR</m-b>(<m-b>Point In Time Recovery</m-b>)で必要となる過去の更新ログファイルである。
        設定でアーカイブモードを有効にしている場合に、<m-b>WALファイル</m-b>のコピーとして作成され、内容も同一となる。<br>
        アーカイブファイルは、最新の<m-b>ベースバックアップ</m-b>取得後のもののみが使用されるため、それ以前のアーカイブファイルは保存する意味がない。
        そのため、古いアーカイブファイルを削除する運用が必要となる。<br>
        アーカイブファイルはWALファイルと異なり循環的に利用ができないため、ディスク上限まで増加する。
        この状態では、WALファイルの<m-b>アーカイブ化が失敗</m-b>し、WALファイルが格納領域に残ったままとなる。
        最終的にはWALファイル格納領域がディスク上限に達し、PostgreSQLは<m-b>PANIC</m-b>を起こして停止してしまう。
    </p>

    <h3>HOT</h3>
    <p>
        HOTとは、<m-b>Heap Only Tuple</m-b>の略で、PostgreSQL8.3から導入された仕組みである。
        これにより、<m-b>更新</m-b>性能が大幅に向上した。
        また、<m-b>バキューム</m-b>の対象となる<m-b>不要領域</m-b>そのものの発生量が減少した。<br>
        HOTは次の処理を行う。
    </p>
    <ul>
        <li>UPDATE時の<m-b>インデックスエントリの追加</m-b>をスキップする</li>
        <li>VACUUM処理を待つことなく<m-b>不要領域</m-b>を再利用可能とする</li>
    </ul>
    <p>
        次のような場合には、HOTは動作しない。
    </p>
    <ul>
        <li><m-b>DELETE</m-b>+<m-b>INSERT</m-b>のような更新シーケンス</li>
        <li><m-b>インデックス列</m-b>を更新するUPDATE</li>
        <li><m-b>一度に大量の行</m-b>を更新するUPDATE</li>
        <li>更新対象の行と同じページ内に<m-b>空きがない</m-b></li>
    </ul>
    <p>
        また、TOAST対象となった列へのUPDATEでは、HOT機能のうち<m-b>インデックスエントリの追加をスキップする</m-b>処理は機能しない。
        これは、TOASTの更新が<m-b>削除</m-b>と<m-b>挿入</m-b>の組み合わせで実装されているためである。
        一方、<m-b>不要領域を即時再利用とする</m-b>処理は機能する。<br>
        HOT機能自体は、UPDATE実行時に制御できるものではないため、効果的に活用するためには<m-b>FILLFACTOR</m-b>による物理設計を考慮する必要がある。
    </p>

    <h3>FILLFACTOR</h3>
    <p>
        FILLFACTORは、ページ内の<m-b>空き領域</m-b>をどの程度データ挿入時に使用するのかを示すパラメータである。
        パラメータを小さくすると<m-b>空き領域</m-b>が増え、データ挿入時に使用できる領域は<m-b>減る</m-b>が、更新時に<m-b>空き領域</m-b>を有効活用できる。<br>
        FILLFACTORのデフォルト値は、テーブルの場合<m-b>100%</m-b>、インデックスの場合<m-b>90%</m-b>となる。
        FILLFACTORは次の考え方で設計するとよい。
    </p>
    <ul>
        <li>該当テーブルに対して削除や更新がない場合、<m-b>100%</m-b>のままとする。</li>
        <li>
            更新がある場合、当該テーブルの平均的なレコード長の<m-b>2倍</m-b>程度の空き領域を確保できるように設定する。
            これにより、ページ内で空き領域を交互に使う可能性が高まり、更新処理による<m-b>新規ページ</m-b>の作成を低減することが見込める。
        </li>
        <li>
            FILLFACTORをあまり小さくしすぎると、各ページで多くの空き領域を抱えることになり、<m-b>キャッシュヒット率</m-b>が低下してしまう。
            一般的にFILLFACTORを<m-b>90%</m-b>程度に設定すればHOTは十分機能するといわれ、下限は<m-b>70%</m-b>程度が適切と考えられる。
        </li>
    </ul>
    <h4>CREATE TABLE文でFILLFACTORを指定</h4>
    <pre><code>
CREATE TABLE tbl(
    id bigserial PRIMARY KEY,
    hoge text
) <m-b>WITH (FILLFACTOR = 90)</m-b>;
    </code></pre>
    <h4>ALTER TABLE文でFILLFACTORを指定</h4>
    <pre><code>
ALTER TABLE tbl <m-b>SET (FILLFACTOR = 85)</m-b>;
    </code></pre>
    <h4>FILLFACTORの確認</h4>
    <p>
        FILLFACTORの設定値を確認する場合、システムカタログ<m-b>pg_class</m-b>を参照すればよい。
        列<m-b>reloptions</m-b>に<m-b>fillfactor=xx</m-b>のフォーマットで格納されている。
        FILLFACTORやその他オプションを明示的に指定していない場合、この列は<m-b>空白</m-b>となる。
    </p>
    <h4>FILLFACTORを確認する例</h4>
    <pre><code>
CREATE TABLE sample1(hoge text) WITH (FILLFACTOR=90);
CREATE TABLE sample2(hoge text);
SELECT relname, <m-b>reloptions</m-b> FROM <m-b>pg_class</m-b> WHERE relname LIKE 'sample%';
    </code></pre>
    <h4>結果</h4>
    <pre><code>
relname |   reloptions
--------+-----------------
sample1 | <m-b>{fillfactor=90}</m-b>
sample2 | <m-b>    (空白)    </m-b>

(2 rows)
    </code></pre>

    <h3>データ配置のポイント</h3>
    <p>
        PostgreSQLの各種ファイルは、通常データベースクラスタ配下に格納する。
        しかし、設定により格納先を変えることもできる。
        次に、各領域のファイルをデータベースクラスタ外に格納する場合の、ポイントと注意点を示す。
    </p>
    <table>
        <thead>
            <tr>
                <th>領域名</th>
                <th>ポイントと注意点</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>base領域</td>
                <td>
                    データベースディレクトリが格納され、その配下にデータファイルやインデックスファイルが格納される。
                    この領域のサイズは、初期時の想定サイズだけでなく、運用開始後のデータ増分予測も踏まえて検討する必要がある。
                    <m-b>テーブル空間機能</m-b>によって、テーブルやインデックスの物理的なディスク配置場所を変えることも可能である。
                </td>
            </tr>
            <tr>
                <td>WAL領域</td>
                <td>
                    WALファイルが格納される領域で、更新時にWALが生成されると増加する。
                    ただし、増加数には上限があり、領域全体の最大サイズは基本的に一定となる。<br>
                    WALファイルはリカバリに使用する重要なファイルのため、データベースクラスタとは別の<m-b>ディスク</m-b>に配置したり、
                    <m-b>二重化</m-b>が可能なストレージ上に配置するなどを検討する。<br>
                    WAL領域をデータベースクラスタ外に配置する場合、initdbやpg_ctlコマンドのオプションとして、<m-b>--waldir</m-b>または<m-b>-X</m-b>を指定する。
                </td>
            </tr>
            <tr>
                <td>アーカイブ領域</td>
                <td>
                    パラメータ<m-b>archive_command</m-b>で設定されたコピー先のディレクトリがアーカイブ領域となる。
                    アーカイブ領域はディスクの上限まで増加し、上限に達して使用できなくなるとアーカイブ処理に失敗し、異常終了の原因となる。
                    そのため、アーカイブ領域は<m-b>WAL領域</m-b>とは別領域に配置することを検討する。
                </td>
            </tr>
        </tbody>
    </table>

    <h3>テーブル空間</h3>
    <p>
        テーブルファイルやインデックスファイルを格納する領域を、テーブル空間として定義することができる。
        PostgreSQLでは、<m-b>シンボリックリンク</m-b>をデータベースクラスタ上に配置する実装となっている。<br>
        I/O分散を考慮した物理設計を行う場合、<m-b>PostgreSQLのテーブル空間</m-b>を用いる方法と、<m-b>ストレージの機能</m-b>を用いる方法がある。
        前者の場合、テーブル空間を別々のディスクに分散することで、ディスクI/Oを分散する。
        後者の場合、ストレージの<m-b>ストライピング</m-b>を構成し、ディスクI/Oを分散する。
        このとき、耐障害性の要件として、<m-b>ミラーリング</m-b>も含めて検討する。
    </p>
    <h4>テーブルパーティショニングとの組み合わせ</h4>
    <p>
        通常、同じテーブルを別々のテーブル空間に配置することはできないが、
        テーブルパーティショニングを用いて<m-b>パーティション</m-b>を別々のテーブル空間に配置することで、これを実現することができる。
    </p>
    <h4>テーブル空間の作成</h4>
    <pre><code>
CREATE <m-b>TABLESPACE</m-b> テーブル空間名 <m-b>LOCATION</m-b> 'テーブル空間のディレクトリパス'
    </code></pre>
    <h4>テーブル空間を指定してテーブルを作成</h4>
    <pre><code>
CREATE TABLE tbl(hoge text) <m-b>TABLESPACE</m-b> テーブル空間名;
    </code></pre>
    <h4>テーブル空間の変更</h4>
    <pre><code>
<m-b>ALTER TABLE</m-b> 変更対象のテーブル名 <m-b>SET TABLESPACE</m-b> テーブル空間名
    </code></pre>
    <h4>テーブル空間配下のテーブルをまとめて変更</h4>
    <pre><code>
<m-b>ALTER TALBE ALL IN TABLESPACE</m-b> 元のテーブル空間名 <m-b>SET TABLESPACE</m-b> 新しいテーブル空間名
    </code></pre>

    <h3>インデックスの設計</h3>
    <h4>複数列インデックス</h4>
    <p>
        PostgreSQLでは複数の列に対しインデックスを作成することができるが、検索時の条件として指定した列をすべて条件に含まないと、
        インデックスは使用されない場合がある。
        これは、<m-b>プランナ</m-b>が先頭側に記述した列による絞り込みの効果が高いと判断するかどうかで決まる。
        複数列インデックスを作成する場合、この点に注意して設計する必要がある。
    </p>
    <h4>関数インデックス</h4>
    <p>
        インデックスの対象となるのは、列値そのものだけでなく、列値を用いた<m-b>演算結果</m-b>や<m-b>関数の戻り値</m-b>に対しても適用することができる。
        これを関数インデックスと呼ぶ。
        関数インデックスを使用する場合、発行するクエリ側でも同じ形式で関数を呼び出す必要がある。
        関数インデックスは、列値のままでは評価する演算子を持たない<m-b>XML</m-b>型の列を評価するときなどにも使用する。
    </p>
    <h4>部分インデックス</h4>
    <p>
        部分インデックスは、特定の条件を満たす行の値のみをインデックス化の対象とし、列値の分布に偏りがある場合に有効である。
        列値の分布に偏りがあり、出現頻度の高い値で検索を行い場合、プランナはインデックスを使用しない。
        つまり、出現頻度の高い値のインデックスは無駄になる。
        部分インデックスを用いることで、出現頻度の低い値に対してのみインデックスを作成できる。<br>
        部分インデックスを作成する場合、CREATE INDEX文に<m-b>WHERE</m-b>句を付加し、条件を指定する。
    </p>
    <h4>インデックスの種別</h4>
    <table>
        <thead>
            <tr>
                <th>
                    <nobr>インデックス種別</nobr>
                </th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>B-tree</m-b></td>
                <td>
                    もっとも一般的なインデックス<br>
                    ある順でソート可能なデータに対する等価性や範囲を問い合わせる場合に用いる。
                    デフォルトのインデックス種別であり、多くの場合でこの種別のインデックスを用いることになる。
                </td>
            </tr>
            <tr>
                <td><m-b>Hash</m-b></td>
                <td>単純な等価比較で問い合わせる場合に用いる</td>
            </tr>
            <tr>
                <td><m-b>GiST</m-b></td>
                <td>汎用的なインデックス実装の基盤となるインデックス種別</td>
            </tr>
            <tr>
                <td><m-b>SP-GiST</m-b></td>
                <td>
                    GiSTと同様に、汎用的なインデックス実装の基盤となるインデックス種別<br>
                    SPとは<m-b>空間分割</m-b>(<m-b>Space Partitioned</m-b>)を示し、主に分割管理されるデータ構造をインデックスファイルとして格納する。
                </td>
            </tr>
            <tr>
                <td><m-b>GIN</m-b></td>
                <td>
                    汎用転置インデックス種別<br>
                    インデックスの対象となる項目が<m-b>複数</m-b>存在するデータに使用する。
                </td>
            </tr>
            <tr>
                <td><m-b>BRIN</m-b></td>
                <td>
                    ブロックレンジインデックス<br>
                    論理的な値の並びと物理的な値の並びに強い相関があり、大規模なテーブルに対する範囲検索で有効となる。
                </td>
            </tr>
            <tr>
                <td><m-b>bloom</m-b></td>
                <td>
                    contribモジュールとして提供されるブルームフィルターを利用したインデックス
                </td>
            </tr>
        </tbody>
    </table>

    <h3>エンコーディング</h3>
    <p>
        PostgreSQLでは、<m-b>サーバ</m-b>側と<m-b>クライアント</m-b>側で別々のエンコーディングを設定できるが、
        変換コストのため性能上のロスが発生するため、なるべく同一のエンコーディングを設定することが望ましい。
        特に、Javaなどの一般的なアプリケーションでは<m-b>UTF-8</m-b>が使用されるため、これを指定するのが無難である。
    </p>
    <h4>日本語をサポートしているエンコーディング</h4>
    <table>
        <thead>
            <tr>
                <th>エンコーディング名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>EUC_JP</m-b></td>
                <td>日本語拡張Unixコード</td>
            </tr>
            <tr>
                <td><m-b>EUC_JP_2004</m-b></td>
                <td>日本語拡張Unixコードの一種</td>
            </tr>
            <tr>
                <td><m-b>SJIS</m-b></td>
                <td>Shift JISコード</td>
            </tr>
            <tr>
                <td><m-b>SHIFT_JIS_2004</m-b></td>
                <td>Shift JISコードの一種</td>
            </tr>
            <tr>
                <td><m-b>UTF-8</m-b></td>
                <td>UTF8 Unicodeで定義された文字列を表現するコード</td>
            </tr>
        </tbody>
    </table>

    <h3>ロケール</h3>
    <p>
        ロケールとは、地域(国)によって異なる<m-b>単位</m-b>、<m-b>記号</m-b>、<m-b>日付</m-b>、<m-b>通貨</m-b>などの表記や比較規則を指す概念である。
        PostgreSQLではこのロケールの概念をサポートし、<m-b>データベースクラスタ全体</m-b>または<m-b>データベース単位</m-b>で指定することができる。<br>
        データベースクラスタに対しロケールを設定する場合、initdbやpg_ctlコマンドで<m-b>--locale</m-b>オプションを指定する。
        ロケールを使用しない場合は<m-b>--no-locale</m-b>オプションを指定する。
        また、データベースごとにロケールを指定する場合、createdbコマンドの<m-b>--locale</m-b>オプションを指定する。
    </p>
    <h4>メリット</h4>
    <ul>
        <li>文字列関数などで、<m-b>半角</m-b>/<m-b>全角</m-b>英数字を等価に扱えるようになる</li>
        <li><m-b>ORDER BY</m-b>を指定する際に、バイトコード順でなくロケールの辞書による順序で並び変えられる</li>
        <li><m-b>通貨</m-b>型を参照するときに、ロケールに従った<m-b>通貨</m-b>記号が付与される</li>
    </ul>
    <h4>デメリット</h4>
    <ul>
        <li><m-b>並び替え</m-b>や<m-b>インデックス作成</m-b>処理などで、ロケール処理によるオーバヘッドが発生する</li>
        <li><m-b>前方一致検索</m-b>でインデックスが使用できなくなる</li>
        <li><m-b>OS</m-b>のロケールに依存するため、<m-b>OS</m-b>の環境に依存して挙動が変わる可能性がある</li>
        <li>ロケールを指定することで、指定できる<m-b>エンコーディング</m-b>が固定される可能性がある</li>
    </ul>

    <h2>7章 ロール設計</h2>

    <h3>データベースセキュリティの概要</h3>
    <h4>データベースセキュリティの4要素</h4>
    <ol>
        <li><m-b>認証</m-b></li>
        <li><m-b>認可</m-b></li>
        <li><m-b>監査</m-b></li>
        <li><m-b>暗号化</m-b></li>
    </ol>
    <h4>ロールの役割</h4>
    <ul>
        <li><m-b>認証</m-b>:データベースへの接続を制御</li>
        <li><m-b>認可</m-b>:データベースオブジェクトの操作を制御</li>
    </ul>

    <h3>ユーザとロールの違い</h3>
    <p>
        PostgreSQLにおいては、内部的にユーザとロールは同じものとして実装されている。
        一方、CREATE USERとCREATE ROLEの違いは、内部的に<m-b>CREATE USER</m-b>を呼び出したときは<m-b>CREATE ROLE</m-b>が呼び出されていて、
        CREATE USERを呼び出したときは<m-b>LOGIN</m-b>オプションが、CREATE ROLEを呼び出したときは<m-b>NOLOGIN</m-b>オプションが付与されて
        呼び出される。
    </p>

    <h3>PUBLICロール</h3>
    <p>
        PUBLICロールは、デフォルトで存在し、削除できないロールである。
        すべてのロールはPUBLICロールを<m-b>継承</m-b>する。
        そのため、PUBLICロールが持つ権限はすべてのロールが持つことになるため注意が必要である。<br>
        PUBLICロールはロール名が表示されない。
        システムカタログのテーブル<m-b>pg_namespace</m-b>から列<m-b>nspacl</m-b>を参照すると、ロール名は<m-b>空</m-b>で表示される。
        なお、アクセスコントロール情報は<m-b>ロール名=アクセス権限/権限を付与したロール名</m-b>のフォーマットで表示される。<br>
        PostgreSQL14の時点で注意すべき仕様として、PUBLICロールは<m-b>publicスキーマ</m-b>に対するCREATE権限を持つことがあげられる。
        そのため、デフォルト設定ではすべてのロールは<m-b>publicスキーマ</m-b>にオブジェクトを作成することができる。
        PUBLICスキーマからpublicスキーマに対する権限を剥奪し、これを防ぐ場合、次のコマンドを実行する。
    </p>
    <pre><code>
<m-b>REVOKE ALL ON SCHEMA public FROM PUBLIC;</m-b>
    </code></pre>

    <h3>定義済みロール (Predefined Roles)</h3>
    <p>
        PostgreSQLではスーパーユーザにしか許可されていない操作がいくつか存在し、その中にはDBの管理者作業として必要なものが含まれている。
        しかし、これらの操作のためにスーパーユーザ権限を付与することは、権限を過剰に与えることになってしまう。
        そこで、スーパーユーザの権限の一部を一般ユーザに持たせることができるように作成された権限群が、定義済みロールである<br>
        PostgreSQL14では、次の定義済みロールが存在する。
    </p>
    <table>
        <thead>
            <tr>
                <th>ロール名</th>
                <th>許可されたアクセス</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>pg_read_all_data</m-b></td>
                <td>
                    <ul>
                        <li>すべてのスキーマへのUSAGE権限</li>
                        <li>すべてのテーブル、ビュー、シーケンスに対するSELECT権限</li>
                    </ul>
                    BYPASSRLS属性は持たない。
                </td>
            </tr>
            <tr>
                <td><m-b>pg_write_all_data</m-b></td>
                <td>
                    <ul>
                        <li>すべてのスキーマへのUSAGE権限</li>
                        <li>すべてのテーブル、ビュー、シーケンスに対するINSERT、UPDATE、DELETE権限</li>
                    </ul>
                    BYPASSRLS属性は持たない。
                </td>
            </tr>
            <tr>
                <td><m-b>pg_read_all_settings</m-b></td>
                <td>
                    すべての設定変数の参照を許可する<br>
                    スーパーユーザのみが取得できる値も参照可能
                </td>
            </tr>
            <tr>
                <td><m-b>pg_read_all_stats</m-b></td>
                <td>
                    すべてのpg_stat_*ビューの参照を許可し、統計関連の拡張機能の使用を許可する<br>
                    スーパーユーザのみが取得できる値も参照可能
                </td>
            </tr>
            <tr>
                <td><m-b>pg_stat_scan_tables</m-b></td>
                <td>
                    長時間シェアロックを取得する可能性のあるモニタリング関数の実行を許可する
                </td>
            </tr>
            <tr>
                <td><m-b>pg_monitor</m-b></td>
                <td>
                    以下の定義済みロールを包括して許可する
                    <ul>
                        <li>pg_read_all_settings</li>
                        <li>pg_read_all_stats</li>
                        <li>pg_stat_scan_tables</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>pg_database_owner</m-b></td>
                <td>
                    暗黙的に現在のデータベース所有者メンバとして構成する
                </td>
            </tr>
            <tr>
                <td><m-b>pg_signal_backend</m-b></td>
                <td>
                    他のバックエンドクエリのキャンセルやセッションの終了を許可する
                </td>
            </tr>
            <tr>
                <td><m-b>pg_read_server_files</m-b></td>
                <td>
                    データベースサーバ上でアクセスできる場所からのファイル読み込みを許可する
                </td>
            </tr>
            <tr>
                <td><m-b>pg_write_server_files</m-b></td>
                <td>
                    データベースサーバ上でアクセスできる場所へのファイル書き込みを許可する
                </td>
            </tr>
            <tr>
                <td><m-b>pg_execute_server_program</m-b></td>
                <td>
                    データベースを実行するユーザで、COPYなどのサーバサイドプログラムを実行することを許可する
                </td>
            </tr>
        </tbody>
    </table>
    <h4>PostgreSQL15のpublicスキーマの仕様変更</h4>
    <p>
        PostgreSQL15では、publicスキーマに定義済みロールの<m-b>pg_database_owner</m-b>が適用された。
        これにより、publicスキーマへのCREATE権限を持つロールが、<m-b>データベースの所有者</m-b>に制限された。
    </p>

    <h3>ロールの設計方針</h3>
    <p>
        セキュリティ対策として一般的な考え方に、<m-b>職務分掌</m-b>と<m-b>最小権限の原則</m-b>があり、
        PostgreSQLにおいてもこれに従うことが推奨される。
        そのため、データベース作成時に作成される<m-b>スーパーユーザ</m-b>属性を持つユーザを使いまわすことは避けるべきである。
        例えば、あるロールに定義済みロールを<m-b>GRANT</m-b>することで、スーパーユーザ権限のうち一部を付与できる。
    </p>

    <h3>ロールの設計要素</h3>
    <ul>
        <li>
            <m-b>属性</m-b><br>
            変更は<m-b>ALTER ROLE</m-b>コマンドで行う。
        </li>
        <li>
            <m-b>権限</m-b><br>
            変更は<m-b>GRANT</m-b>や<m-b>REVOKE</m-b>コマンドで行う。
            データベースオブジェクト毎に設定を行い、同名の権限でもオブジェクトによって許可される操作が異なる点に注意する。
        </li>
    </ul>
    <h4>変更可能な属性 (抜粋)</h4>
    <table>
        <thead>
            <tr>
                <th>属性名</th>
                <th>内容</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>SUPERUSER</m-b></td>
                <td>スーパーユーザ属性の有無を定義する</td>
            </tr>
            <tr>
                <td><m-b>CREATEDB</m-b></td>
                <td>データベースの作成に関する属性を定義する</td>
            </tr>
            <tr>
                <td><m-b>CREATEROLE</m-b></td>
                <td>新しいロールを作成する属性を定義する</td>
            </tr>
            <tr>
                <td><m-b>INHERIT</m-b></td>
                <td>属するロールの権限を継承するかを定義する</td>
            </tr>
            <tr>
                <td><m-b>LOGIN</m-b></td>
                <td>データベースへのログイン属性を定義する</td>
            </tr>
        </tbody>
    </table>
    <h4>変更可能な権限 (抜粋)</h4>
    <table>
        <thead>
            <tr>
                <th>オブジェクト</th>
                <th>権限名</th>
                <th>内容</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="3">データベース</td>
                <td><m-b>CREATE</m-b></td>
                <td>データベース内の新たなオブジェクト作成を許可する</td>
            </tr>
            <tr>
                <td><m-b>CONNECT</m-b></td>
                <td>データベースに接続することを許可する</td>
            </tr>
            <tr>
                <td><m-b>TEMPORARY</m-b></td>
                <td>データベース内で一時テーブルの作成を許可する</td>
            </tr>
            <tr>
                <td rowspan="2">スキーマ</td>
                <td><m-b>CREATE</m-b></td>
                <td>スキーマ内に新しいオブジェクトを作ることを許可する</td>
            </tr>
            <tr>
                <td><m-b>USAGE</m-b></td>
                <td>スキーマ内に含まれるオブジェクトへのアクセスを許可する</td>
            </tr>
            <tr>
                <td rowspan="7">テーブル</td>
                <td><m-b>SELECT</m-b></td>
                <td>テーブル、ビューにSELECTすることを許可する</td>
            </tr>
            <tr>
                <td><m-b>INSERT</m-b></td>
                <td>テーブル、ビューに新しい行をINSERTすることを許可する</td>
            </tr>
            <tr>
                <td><m-b>UPDATE</m-b></td>
                <td>テーブル、ビューの列をUPDATEすることを許可する</td>
            </tr>
            <tr>
                <td><m-b>DELETE</m-b></td>
                <td>テーブル、ビューの列をDELETEすることを許可する</td>
            </tr>
            <tr>
                <td><m-b>TRUNCATE</m-b></td>
                <td>テーブル、ビューのTRUNCATEを許可する</td>
            </tr>
            <tr>
                <td><m-b>REFERENCES</m-b></td>
                <td>テーブルの列を参照する外部キー制約作成を許可する</td>
            </tr>
            <tr>
                <td><m-b>TRIGGER</m-b></td>
                <td>テーブル、ビューでのトリガ作成を許可する</td>
            </tr>
        </tbody>
    </table>

    <h2>8章 バックアップ計画</h2>

    <h3>リカバリ要件</h3>
    <p>
        バックアップ計画を立てる際は、最初にリカバリ要件を明確にする。
        具体的には、次のようなことを決定する。
    </p>
    <ul>
        <li>障害発生時に<m-b>どの時点までのデータ</m-b>を復旧するか</li>
        <li>データベースの再開までに<m-b>許容される時間</m-b>はどの程度か</li>
    </ul>

    <h3>バックアップ方式</h3>
    <table>
        <thead>
            <tr>
                <th>バックアップの種類</th>
                <th>バックアップ方式</th>
                <th>長所</th>
                <th>短所</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>オフラインバックアップ</m-b></td>
                <td><m-b>物理バックアップ</m-b></td>
                <td class="wrappable">
                    <ul>
                        <li>手順が簡易である</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>運用中にバックアップできない</li>
                        <li>復元できる時点はバックアップ取得時点のみ</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td rowspan="2"><m-b>オンラインバックアップ</m-b></td>
                <td><m-b>論理バックアップ</m-b></td>
                <td class="wrappable">
                    <ul>
                        <li>運用中にバックアップができる</li>
                        <li>手順が簡易である</li>
                        <li>データベースから部分的にバックアップできる</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>復元できる時点はバックアップ取得時点のみ</li>
                        <li>物理バックアップに比べて復元にかかる時間が長い</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>物理バックアップ</m-b></td>
                <td class="wrappable">
                    <ul>
                        <li>運用中にバックアップできる</li>
                        <li>任意の時点にリカバリできる</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>運用手順が煩雑である</li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>
    <h4>オンラインバックアップの手法</h4>
    <table>
        <thead>
            <tr>
                <th>方式</th>
                <th>バックアップ手法</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>論理バックアップ</td>
                <td>
                    <ul>
                        <li><m-b>pg_dumpコマンド</m-b></li>
                        <li><m-b>pg_dumpallコマンド</m-b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>物理バックアップ</td>
                <td>
                    <ul>
                        <li><m-b>pg_basebackupコマンド</m-b></li>
                        <li><m-b>pg_start_bakup、pg_stop_backupコマンド</m-b></li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>
    <h4>リカバリ要件とリカバリ方式の整理</h4>
    <ul>
        <li>
            バックアップ取得時点まで戻したい<br>
            <ul>
                <li>
                    PostgreSQLを停止してもよい<br>
                    ⇒<m-b>コールドバックアップ</m-b>
                </li>
                <li>
                    PostgreSQLの動作継続が必要<br>
                    ⇒<m-b>オンライン論理バックアップ</m-b>
                </li>
            </ul>
        </li>
        <li>
            問題発生直前まで戻したい<br>
            ⇒<m-b>オンライン物理バックアップ</m-b>
        </li>
    </ul>

    <h3>各バックアップ方式の注意点</h3>
    <h4>コールドバックパップ</h4>
    <p>
        PostgreSQLを停止し、DBクラスタを丸ごとバックアップすれば完了である。<br>
        任意のテーブル空間を作成している場合、DBクラスタ配下の<m-b>pg_tblspc</m-b>ディレクトリには、
        テーブル空間の実体への<m-b>シンボリックリンク</m-b>が格納される。
        そのため、リンク先のデータ実体もバックアップする必要がある。
        また、リストア時も、テーブル空間のデータをすべて元の位置に配置してからPostgreSQLを起動する必要がある。<br>
        WAL領域の位置にも気を付ける必要がある。
        DBクラスタ作成時にデフォルトと異なる位置にWAL領域を指定する場合、<m-b>pg_wal</m-b>配下は<m-b>シンボリックリンク</m-b>となる。
        そのため、実体のWAL領域のWALファイルもバックアップする必要がある。
    </p>
    <h4>オンライン論理バックアップ</h4>
    <p>
        PostgreSQL付属コマンドの<m-b>pg_dump</m-b>または<m-b>pg_dumpall</m-b>を用いて取得する。<br>
        pg_dumpでは、<m-b>プレーンテキスト</m-b>、<m-b>カスタム</m-b>、<m-b>tar</m-b>、<m-b>ディレクトリ</m-b>などの形式でバックアップを取得できる。
        <m-b>カスタム</m-b>、<m-b>tar</m-b>、<m-b>ディレクトリ</m-b>はバイナリ形式のバックアップである。
        リストア時には、プレーンテキストの場合<m-b>psql</m-b>を、バイナリ形式であれば<m-b>pg_restore</m-b>を用いる。<br>
        pg_dumpは、<m-b>データベース</m-b>または<m-b>テーブル</m-b>単位でバックアップが取得できるが、
        <m-b>ユーザ</m-b>や<m-b>データベース共通</m-b>のデータはバックアップできない。
        これらのデータをバックアップする際は、pg_dumpallを使用する。
        pg_dumpallは、<m-b>テキスト</m-b>形式のバックアップのみをサポートしているため、<m-b>psql</m-b>を用いてリストアする。<br>
        pg_dump、pg_dumpallともに、<m-b>テーブル空間</m-b>、<m-b>ラージオブジェクト</m-b>のバックアップに対応している。
        また、<m-b>設定ファイル</m-b>類のバックアップには対応していない。
    </p>
    <h4>オンライン物理バックアップ</h4>
    <p>
        コールドバックアップと同様に、WAL領域も確実にバックアップする必要がある。
        <m-b>pg_basebackup</m-b>コマンドを使用する場合、PostgreSQLが<m-b>レプリケーション</m-b>を行える設定になっている必要があるが、
        <m-b>テーブル空間</m-b>や<m-b>WAL領域</m-b>のバックアップを取得するオプションが存在するため、積極的に利用することが推奨される。
        pg_basebackupは<m-b>1</m-b>プロセスで物理バックアップを取得する仕様のため、バックアップにかかる時間はデータベースクラスタのサイズに比例する。
        要件を満たすか確認が必要である。<br>
        ベースバックアップ取得後(<m-b>pg_stop_backup</m-b>関数実行前)より前の状態へのリカバリが不要であれば、<m-b>pg_start_backup</m-b>関数実行前までの
        <m-b>アーカイブログ</m-b>が不要となる。
        PostgreSQLではこれを削除できないため、定期的に削除する運用が必要となる。
        <m-b>pg_archivecleanup</m-b>ユーティリティコマンドを用いると、比較的容易に不要なアーカイブログを特定/削除ができる。<br>
        データベースクラスタで<m-b>チェックサム</m-b>を有効にすることで、pg_basebakcup実行時にデフォルトで整合性の確認を行い、データは破損を検知できる。
        PostgreSQL13から導入されたバックアップマニフェストを取得し、<m-b>pg_verifybackup</m-b>コマンドを使用してバックアップファイルの妥当性を確認することもできる。
        これらは、データベースクラスタでチェックサムを有効にしている必要がある。
    </p>

    <h3>バックアップの世代管理について</h3>
    <p>
        PostgreSQLでは、標準機能でバックアップの世代管理は行えない。
        しかし、拡張機能として<m-b>pg_rman</m-b>、<m-b>pg_backrest</m-b>、<m-b>pg_barman</m-b>などがOSSとして公開されている。
        これらの拡張機能は、世代管理機能や増分/差分バックアップなどの機能も追加されていて、使用により運用コスト削減が見込める。
    </p>

    <h2>9章 監視計画</h2>

    <h3>監視とは</h3>
    <h4>監視計画で決定すること</h4>
    <ul>
        <li><m-b>監視項目の選定</m-b></li>
        <li><m-b>監視する間隔</m-b></li>
        <li><m-b>何をもって異常と判断するかの閾値</m-b></li>
    </ul>
    <h4>一般的な監視の間隔</h4>
    <p>
        監視する間隔は、<m-b>SLA</m-b>などのシステム要件に基づいて決定する。
        一般的に、死活監視は<m-b>数秒</m-b>間隔とし、性能監視では<m-b>数分</m-b>間隔で多くの情報を取得する。
    </p>

    <h3>監視項目</h3>
    <ul>
        <li><m-b>サーバ</m-b>に問題が起きていないか</li>
        <li><m-b>PostgreSQL</m-b>に問題が起きていないか</li>
    </ul>
    <h4>サーバの監視</h4>
    <p>
        サーバリソースとして、<m-b>CPU</m-b>、<m-b>メモリ</m-b>、<m-b>ディスク</m-b>、<m-b>ネットワーク</m-b>
        が正常に動いているかを監視する。
        これらは、OSやストレージに付属するコマンドの<m-b>sar</m-b>、<m-b>iostat</m-b>、<m-b>vmstat</m-b>、<m-b>top</m-b>、
        <m-b>netstat</m-b>などを用いて情報を収集する。
    </p>
    <h4>PostgreSQLの監視</h4>
    <ul>
        <li>必要な<m-b>プロセス</m-b>は正常に稼働しているか</li>
        <li><m-b>ディスク容量</m-b>に問題はないか</li>
        <li>想定通りの<m-b>性能</m-b>は出せているか</li>
        <li>PostgreSQLの<m-b>サーバーログ</m-b>に異常を知らせる通知はないか</li>
    </ul>
    <h4>プロセスの監視</h4>
    <table>
        <thead>
            <tr>
                <th>監視項目</th>
                <th>監視方法</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>バックエンドプロセス、<br>バックグラウンドプロセスの数や状態</td>
                <td>
                    <ul>
                        <li>OSの<m-b>ps</m-b>コマンド</li>
                        <li>PostgreSQLの<m-b>pg_stat_activity</m-b>ビュー</li>
                        <li>PostgreSQLの<m-b>pg_stat_archiver</m-b>ビュー</li>
                        <li>PostgreSQLの<m-b>pg_stat_progress_vacuum</m-b>ビュー</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>PostgreSQLに接続できるか</td>
                <td><m-b>psql</m-b>などのクライアントアプリケーションを用いた確認</td>
            </tr>
            <tr>
                <td>レプリケーション状態に異常がないか</td>
                <td>
                    <ul>
                        <li><m-b>pg_stat_replication</m-b>ビュー</li>
                        <li><m-b>pg_stat_replication_slots</m-b>ビュー</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>プロセスの実行状況</td>
                <td>
                    <ul>
                        <li><m-b>pg_stat_progress_basebackup</m-b>ビュー</li>
                        <li><m-b>pg_stat_progress_vacuum</m-b>ビュー</li>
                        <li><m-b>pg_stat_progress_analyze</m-b>ビュー</li>
                        <li><m-b>pg_stat_progress_copy</m-b>ビュー</li>
                        <li><m-b>pg_stat_progress_create_index</m-b>ビュー</li>
                        <li><m-b>pg_stat_progress_cluster</m-b>ビュー</li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>
    <h4>ディスク容量の監視</h4>
    <table>
        <thead>
            <tr>
                <th>監視項目</th>
                <th>監視方法</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>ディスク容量</td>
                <td>
                    <ul>
                        <li>OSの<m-b>df</m-b>コマンド</li>
                        <li>OSの<m-b>du</m-b>コマンド</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>データベース、テーブル、インデックスのサイズ</td>
                <td>
                    <ul>
                        <li><m-b>pg_database_size</m-b>関数</li>
                        <li><m-b>pg_total_relation_size</m-b>関数</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>テーブル、インデックスが不必要に肥大化していないか</td>
                <td>
                    <ul>
                        <li><m-b>pg_stat_user_tables</m-b>ビュー</li>
                        <li><m-b>pg_stat_user_indexes</m-b>ビュー</li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>
    <h4>性能の監視</h4>
    <table>
        <thead>
            <tr>
                <th>稼働統計情報ビュー</th>
                <th>対象</th>
                <th>内容</th>
                <th>該当列</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="3"><m-b>pg_stat_database</m-b></td>
                <td rowspan="3">データベース</td>
                <td>コミット、ロールバック数</td>
                <td>
                    <ul>
                        <li><m-b>xact_commit</m-b></li>
                        <li><m-b>xact_rollback</m-b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>データベースのキャッシュヒット率</td>
                <td>
                    <ul>
                        <li><m-b>blks_read</m-b></li>
                        <li><m-b>blks_hit</m-b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>デッドロック発生有無</td>
                <td>
                    <ul>
                        <li><m-b>deadlocks</m-b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td rowspan="2"><m-b>pg_statio_user_tables</m-b>、<br><m-b>pg_statio_user_indexes</m-b></td>
                <td rowspan="2">テーブル、インデックス</td>
                <td>テーブルのキャッシュヒット率</td>
                <td>
                    <ul>
                        <li><m-b>heap_blks_read</m-b></li>
                        <li><m-b>heap_blks_hit</m-b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>インデックスのキャッシュヒット率</td>
                <td>
                    <ul>
                        <li><m-b>idx_blks_read</m-b></li>
                        <li><m-b>idx_blks_hit</m-b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td rowspan="2"><m-b>pg_stat_activity</m-b></td>
                <td rowspan="2">活動中のバックエンドプロセス</td>
                <td>トランザクションの実行時間</td>
                <td>
                    <ul>
                        <li><m-b>backend_start</m-b></li>
                        <li><m-b>xact_start</m-b></li>
                        <li><m-b>query_start</m-b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>実行中のクエリ</td>
                <td>
                    <ul>
                        <li><m-b>wait_event_type</m-b></li>
                        <li><m-b>wait_event</m-b></li>
                        <li><m-b>state</m-b></li>
                        <li><m-b>query</m-b></li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>
    <p>
        また、設定ファイル<m-b>postgresql.conf</m-b>のパラメータ<m-b>log_min_duration_statement</m-b>を設定することで、
        想定よりも時間のかかったクエリをサーバーログに出力することも可能である。
    </p>

    <h3>サーバログ設定</h3>
    <h4>ログをどこに出力するか</h4>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>デフォルト値</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>log_destination</m-b></td>
                <td><m-b>stderr</m-b></td>
                <td>
                    ログの出力先<br>
                    次のいずれかを指定できる。<br>
                    <ul>
                        <li><m-b>stderr</m-b></li>
                        <li><m-b>csvlog</m-b></li>
                        <li><m-b>syslog</m-b></li>
                        <li><m-b>eventlog</m-b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>logging_collector</m-b></td>
                <td><m-b>on</m-b></td>
                <td><m-b>stderr</m-b>、<m-b>csvlog</m-b>の内容をファイルに保存するか</td>
            </tr>
            <tr>
                <td><m-b>log_directory</m-b></td>
                <td><m-b>'log'</m-b></td>
                <td>ログファイルの出力先のディレクトリ</td>
            </tr>
            <tr>
                <td><m-b>log_filename</m-b></td>
                <td><m-b>'postgresql-%a.log</m-b></td>
                <td>
                    ログファイル名<br>
                    <m-b>strftime</m-b>で標準的に扱われるエスケープシーケンス(%)が使用できる。
                </td>
            </tr>
        </tbody>
    </table>
    <h4>ログをいつ出力するか</h4>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>デフォルト値</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>client_min_messages</m-b></td>
                <td><m-b>NOTICE</m-b></td>
                <td>
                    クライアントに送信するレベル<br>
                    次のキーワードを設定でき、設定したレベル以上のログを送信する。
                    なお、レベルの低い順に並べている。
                    <ol>
                        <li><m-b>DEBUG5</m-b>~<m-b>DEBUG1</m-b></li>
                        <li><m-b>LOG</m-b></li>
                        <li><m-b>NOTICE</m-b></li>
                        <li><m-b>WARNING</m-b></li>
                        <li><m-b>ERROR</m-b></li>
                        <li><m-b>FATAL</m-b></li>
                        <li><m-b>PANIC</m-b></li>
                    </ol>
                </td>
            </tr>
            <tr>
                <td><m-b>log_min_messages</m-b></td>
                <td><m-b>WARNING</m-b></td>
                <td>
                    サーバログに書き込むレベル<br>
                    次のキーワードを設定でき、設定したレベル以上のログを書き込む。
                    なお、レベルの低い順に並べている。
                    <ol>
                        <li><m-b>DEBUG5</m-b>~<m-b>DEBUG1</m-b></li>
                        <li><m-b>INFO</m-b></li>
                        <li><m-b>NOTICE</m-b></li>
                        <li><m-b>WARNING</m-b></li>
                        <li><m-b>ERROR</m-b></li>
                        <li><m-b>LOG</m-b></li>
                        <li><m-b>FATAL</m-b></li>
                        <li><m-b>PANIC</m-b></li>
                    </ol>
                </td>
            </tr>
            <tr>
                <td><m-b>log_min_error_statement</m-b></td>
                <td><m-b>ERROR</m-b></td>
                <td>
                    エラー原因のSQLを書き込むレベル<br>
                    次のキーワードを設定でき、設定したレベル以上の原因を書き込む。
                    なお、レベルの低い順に並べている。
                    <ol>
                        <li><m-b>DEBUG5</m-b>~<m-b>DEBUG1</m-b></li>
                        <li><m-b>INFO</m-b></li>
                        <li><m-b>NOTICE</m-b></li>
                        <li><m-b>WARNING</m-b></li>
                        <li><m-b>ERROR</m-b></li>
                        <li><m-b>LOG</m-b></li>
                        <li><m-b>FATAL</m-b></li>
                        <li><m-b>PANIC</m-b></li>
                    </ol>
                </td>
            </tr>
        </tbody>
    </table>
    <h4>ログを何に出力するか</h4>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>デフォルト値</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>log_checkpoints</m-b></td>
                <td><m-b>off</m-b></td>
                <td>
                    チェックポイントに関する情報の出力有無<br>
                    チェックポイントにどれくらいの時間がかかったのか、どの程度書きだしたのか、などを出力する。
                </td>
            </tr>
            <tr>
                <td><m-b>log_connections</m-b></td>
                <td><m-b>off</m-b></td>
                <td>
                    サーバーへの接続に関する情報の出力有無<br>
                    誰がどこから接続してきたのかを出力する。
                </td>
            </tr>
            <tr>
                <td><m-b>log_disconnections</m-b></td>
                <td><m-b>off</m-b></td>
                <td>サーバーへの切断に関する情報の出力有無</td>
            </tr>
            <tr>
                <td><m-b>log_lock_waits</m-b></td>
                <td><m-b>off</m-b></td>
                <td>
                    ロック獲得のために、一定時間以上待機した場合の情報<br>
                    パラメータ<m-b>deadlock_timeout</m-b>で時間を設定し、データベース名、テーブル、接続などの情報を出力する。
                </td>
            </tr>
            <tr>
                <td><m-b>log_autovacuum_min_duration</m-b></td>
                <td><m-b>-1</m-b></td>
                <td>
                    自動バキュームの実行時間がこの設定値を超えた場合に、実行内容を出力<br>
                    <m-b>0</m-b>はすべて出力、<m-b>-1</m-b>は出力しない。
                </td>
            </tr>
            <tr>
                <td><m-b>log_line_prefix</m-b></td>
                <td><m-b>'%m [%p] '</m-b></td>
                <td>各ログの先頭に出力する情報</td>
            </tr>
            <tr>
                <td><m-b>log_statement</m-b></td>
                <td><m-b>none</m-b></td>
                <td>
                    どの種類のSQLの内容を出力するか指定<br>
                    <m-b>ddl</m-b>、<m-b>mod</m-b>、<m-b>all</m-b>、<m-b>none</m-b>から指定可能。
                </td>
            </tr>
            <tr>
                <td><m-b>log_min_duration_statement</m-b></td>
                <td><m-b>-1</m-b></td>
                <td>
                    SQLの実行時間がこの設定値を超えた場合に、実行内容を出力<br>
                    <m-b>0</m-b>はすべて出力、<m-b>-1</m-b>は出力しない。
                </td>
            </tr>
            <tr>
                <td><m-b>log_min_duration_sample</m-b></td>
                <td><m-b>-1</m-b></td>
                <td>
                    SQLの実行時間がこの設定値を超えた場合に、実行内容を一部出力<br>
                    <m-b>0</m-b>はすべて出力、<m-b>-1</m-b>は出力しない。
                    <m-b>log_min_duration_statement</m-b>より優先度が低いため、より大きい値を指定した場合は無視される。
                </td>
            </tr>
            <tr>
                <td><m-b>log_statement_sample_rate</m-b></td>
                <td><m-b>1.0</m-b></td>
                <td><m-b>log_min_duration_sample</m-b>による出力割合を0.0~1.0で指定</td>
            </tr>
            <tr>
                <td><m-b>log_transaction_sample_rate</m-b></td>
                <td><m-b>0.0</m-b></td>
                <td>すべてのトランザクションをログ出力する際に出力割合を0.0~1.0で指定</td>
            </tr>
        </tbody>
    </table>
    <h4>ログをどのように管理するか</h4>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>
                    <nobr>デフォルト値</nobr>
                </th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>log_rotation_age</m-b></td>
                <td><m-b>24h</m-b></td>
                <td>
                    ログローテーションの条件を時間で指定する<br>
                    単位に指定がない場合、<m-b>min</m-b>で解釈される。
                    <m-b>log_rotation_size</m-b>と併用できる。
                </td>
            </tr>
            <tr>
                <td><m-b>log_rotation_size</m-b></td>
                <td><m-b>10MB</m-b></td>
                <td>
                    ログローテーションの条件をファイルサイズで指定する<br>
                    単位に指定がない場合、<m-b>kB</m-b>で解釈される。
                    <m-b>log_rotation_age</m-b>と併用できる。
                </td>
            </tr>
            <tr>
                <td><m-b>log_truncate_on_rotation</m-b></td>
                <td><m-b>off</m-b></td>
                <td>ログローテーション時に同名のログファイルがある場合に、ファイルを上書きするか(on)、追記するか(off)</td>
            </tr>
        </tbody>
    </table>

    <h2>10章 サーバ設定</h2>

    <h3>クライアント接続設定</h3>
    <p>
        PostgreSQLでは、クライアントからの接続要求ごとに<m-b>バックエンドプロセス</m-b>が作成される。
        このプロセスへのCPU割り当てはカーネルがスケジューリングするため、CPUコア数より接続数が多くても問題はないが、
        あまりに接続数が多すぎるとプロセスの<m-b>コンテキストスイッチ</m-b>によるオーバヘッドが大きくなってしまう。<br>
        クライアントの接続に関する設定は、postgresql.confの次表に示すパラメータで設定する。
    </p>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>デフォルト値</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>max_connections</m-b></td>
                <td><m-b>100</m-b></td>
                <td>データベースの最大同時接続数</td>
            </tr>
            <tr>
                <td><m-b>superuser_reserved_connections</m-b></td>
                <td><m-b>3</m-b></td>
                <td>PostgreSQLのスーパーユーザ用に予約する接続数</td>
            </tr>
        </tbody>
    </table>
    <p>
        なお、max_connectionsで設定する接続数は、superuser_reserved_connectionsで予約される接続数も含む。
        そのため、デフォルト設定で一般ユーザの最大同時接続数は<m-b>97</m-b>となる。
        さらに、スタンバイサーバを構成している場合、その接続数もmax_connectionsに含まれる。<br>
        また、スタンバイサーバを構成する場合、スタンバイのmax_connectionsの設定をプライマリの設定値より<m-b>大きく</m-b>する必要がある。
        プライマリの接続数だけ多いと、スタンバイへの接続数が不足するためである。
    </p>

    <h3>ロックの設定</h3>
    <p>
        デッドロックの検出はデータベースに負荷のかかる処理のため、頻繁に処理が起こらないようパラメータ<m-b>deadlock_timeout</m-b>で猶予時間を指定する。
        <m-b>ミリ秒</m-b>単位で指定でき、デフォルト値は<m-b>1000ms</m-b>である。<br>
        大量のトランザクションによってロック待ちが頻発するような場合は、デッドロックの検出処理そのものが性能低下の原因になってしまうため、
        デッドロックの猶予時間を長めに設定することが推奨される。
        基準としては、トランザクションの平均的な処理時間に対し、<m-b>少し長めの時間</m-b>を設定する。
        ただし、実際にデッドロックが発生した際に、検出が遅れてしまうことにも留意する。
    </p>

    <h3>OSのメモリ設定</h3>
    <p>
        OSは、<m-b>共有メモリ</m-b>の最大容量に制限を設けている。
        Linuxにおいて、制限を受ける可能性のあるカーネルパラメータは次表の通り。
    </p>
    <table>
        <thead>
            <tr>
                <th>カーネルパラメータ</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>kernel.shmmax</m-b></td>
                <td>共有メモリセグメントの最大値(バイト単位)</td>
            </tr>
            <tr>
                <td><m-b>kernel.shmall</m-b></td>
                <td>使用可能な共有メモリサイズ(ページ単位)</td>
            </tr>
        </tbody>
    </table>
    <p>
        近年のLinuxディストリビュージョンでカーネルパラメータを設定する場合、<m-b>sysctl</m-b>コマンドが使用できる。
        共有メモリサイズを16GB(=17179869184バイト)、共有メモリサイズを4194394ページに設定する場合、次のようにコマンドを実行する。
    </p>
    <pre><code>
<m-b>sysctl -w kernel.shmmax=17179869184</m-b>
<m-b>sysctl -w kernel.shmall=4194394</m-b>
    </code></pre>
    <p>
        なお、sysctlコマンドで設定したパラメータは再起動するとデフォルト値に戻るため、
        <m-b>/etc/sysctl.conf</m-b>ファイルに設定値を保存することが推奨される。
    </p>

    <h3>PostgreSQLのメモリ設定</h3>
    <h4>共有メモリ域の設定</h4>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>デフォルト値</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>shared_buffers</m-b></td>
                <td><m-b>128MB</m-b></td>
                <td>共有バッファのメモリサイズ</td>
            </tr>
            <tr>
                <td><m-b>wal_buffers</m-b></td>
                <td><m-b>-1</m-b></td>
                <td>
                    WALデータが利用する共有メモリサイズ<br>
                    <m-b>-1</m-b>を指定した場合、<m-b>shared_buffers</m-b>の<m-b>1/32</m-b>が設定される。
                </td>
            </tr>
            <tr>
                <td><m-b>max_connections</m-b></td>
                <td><m-b>100</m-b></td>
                <td>クライアントの最大同時接続数</td>
            </tr>
            <tr>
                <td><m-b>max_prepared_transactions</m-b></td>
                <td><m-b>0</m-b></td>
                <td>プリペアドトランザクションの上限</td>
            </tr>
            <tr>
                <td><m-b>max_locks_per_transaction</m-b></td>
                <td><m-b>64</m-b></td>
                <td>トランザクションの平均取得ロック数</td>
            </tr>
            <tr>
                <td><m-b>min_dynamic_shared_memory</m-b></td>
                <td><m-b>0</m-b></td>
                <td>パラレルクエリ向けにあらかじめ確保しておく共有メモリサイズ</td>
            </tr>
        </tbody>
    </table>
    <p>
        共有メモリ域の中でも特に重要なパラメータは、<m-b>shared_buffers</m-b>である。
        デフォルトで<m-b>128MB</m-b>と比較的小さな値が設定されているため、多くの場合でチューニングが推奨される。
        1GB以上のメモリが搭載された環境では、<m-b>1/4</m-b>を目安に設定することが推奨される。<br>
        PostgreSQLでは、共有バッファを使い切ると利用されていないページをバッファから追い出す(<m-b>Clocksweepアルゴリズム</m-b>)ため、
        追い出されたデータを再読み込みする場合は性能が劣化する。
        ただし、共有バッファが大きすぎる場合は探索に時間がかかるため、大きければいいわけでもない。
        仮にバッファから追い出されても、実際は<m-b>ディスクキャッシュ</m-b>から読み出せるケースが多いことも関連する。<br>
        共有メモリ域のその他のパラメータは、デフォルト設定で十分なケースがほとんどである。
    </p>
    <h4>プロセスメモリ域の設定</h4>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>
                    <nobr>デフォルト値</nobr>
                </th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>work_mem</m-b></td>
                <td><m-b>4MB</m-b></td>
                <td>問い合わせ時のソートとハッシュデータ格納に使われるメモリサイズ</td>
            </tr>
            <tr>
                <td><m-b>maintenance_work_mem</m-b></td>
                <td><m-b>64MB</m-b></td>
                <td>VACUUM、CREATE INDEX、ALTER TABLEなどのメンテナンス操作時に使われるメモリサイズ</td>
            </tr>
            <tr>
                <td><m-b>autovacuum_work_mem</m-b></td>
                <td><m-b>-1</m-b></td>
                <td>
                    自動バキュームに使われるメモリサイズ<br>
                    <m-b>-1</m-b>を指定すると<m-b>maintenance_work_mem</m-b>が使用される。
                </td>
            </tr>
        </tbody>
    </table>
    <p>
        これらの設定値は、postgresql.confのリロード(<m-b>pg_ctl reload</m-b>コマンドなど)によって読み込まれる。<br>
        デフォルト設定では、自動バキューム時にパラメータ<m-b>autovacuum_max_workers</m-b> × <m-b>maintenance_work_mem</m-b>の分だけメモリを消費する。
        これにより大量にメモリを消費するのを防ぐため、<m-b>autovacuum_work_mem</m-b>を設定し、自動バキューム時のメモリ消費の上限を設定することが推奨されている。
    </p>

    <h3>HugePage設定</h3>
    <p>
        PostgreSQLでは、共有メモリを大きくするとメモリ管理に用いるページテーブルも肥大化し、CPU負荷の増加と性能劣化の問題が発生する。
        そこで、<m-b>Linux</m-b>環境ではHugePage機能を用いることでページテーブルを小さくすることが期待できる。
        PostgreSQLでHugePageを用いる場合、OSの設定とpostgresql.confの設定が必要となる。<br>
        OS設定では、まず前提として<m-b>CONFIG_HUGETLBFS=y</m-b>および<m-b>CONFIG_HUGETLB_PAGE=y</m-b>のLinuxカーネルが必要である。
        また、OS設定としてカーネルパラメータ<m-b>vm.nr_hugepages</m-b>を共有メモリサイズに合わせて調整する必要がある。<br>
        PostgreSQLのHugePage数は、次の手順で産出する。
    </p>
    <ol>
        <li>
            postmasterプロセスの<m-b>VmPeak</m-b>値を取得<br>
            コマンド: <m-b>grep ^VmPeak /proc/`head -1 $PGDATA/postmaster.pid`/status</m-b>
        </li>
        <li>
            HugePageサイズを取得<br>
            コマンド: <m-b>grep ^Hugepagesize /proc/meminfo</m-b>
        </li>
        <li>
            HugePageサイズとVmPeakの値から、PostgreSQLが必要とするHugePage数を算出<br>
            <m-b>VmPeak / HugePageサイズ</m-b>
        </li>
        <li>
            HugePage数を設定<br>
            コマンド: <m-b>sysctl -w vm.nr_hugepages=算出したHugePage数</m-b>
        </li>
    </ol>
    <p>
        なお、PostgreSQL以外にもHugePageを必要とするアプリケーションを実行する場合、HugePageの合計値を設定する。<br>
        PostgreSQLがHugePageを利用するかは、パラメータ<m-b>huge_pages</m-b>によって設定する。
        これは、<m-b>on</m-b>、<m-b>off</m-b>、<m-b>try</m-b>のキーワードを指定でき、デフォルト値は<m-b>try</m-b>である。
        デフォルト値で設定した場合、HugePage機能が使用できる場合に使用し、他のアプリケーションが使用していてHugePageを使用できない場合は
        HugePageを使わずにPostgreSQLを起動することを意味する。
    </p>

    <h3>OSのディスク設定</h3>
    <p>
        OS側のディスクに関連する設定は、<m-b>I/Oスケジューラ</m-b>の設定が有効である。
        これは、OS上で動作している様々なプロセスからのI/O要求をどのように処理するかを定めているパラメータである。
        設定は、次のコマンドで確認できる。
    </p>
    <pre><code>
<m-b>cat /sys/block/sda/queue/scheduler</m-b>
    </code></pre>
    <h4>設定可能なI/Oスケジューラ</h4>
    <table>
        <thead>
            <tr>
                <th>設定項目</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>none</m-b>または<m-b>noop</m-b></td>
                <td>OSはスケジュールに関与しない</td>
            </tr>
            <tr>
                <td><m-b>anticipatory</m-b></td>
                <td>I/O要求に対してドライブの中の物理的な配置が近いデータを優先して処理する</td>
            </tr>
            <tr>
                <td><m-b>mq-deadline</m-b>または<m-b>deadline</m-b></td>
                <td>I/O要求の待ち時間に上限を設け、限界に近いI/O要求を優先して処理する</td>
            </tr>
            <tr>
                <td><m-b>bfq</m-b>または<m-b>cfq</m-b></td>
                <td>I/O要求が特定のプロセスやアプリケーションに占有されないように時間や帯域を分散する</td>
            </tr>
            <tr>
                <td><m-b>kyber</m-b></td>
                <td>read/writeのレイテンシをそれぞれの目標値に近づけるように調整する</td>
            </tr>
        </tbody>
    </table>
    <p>
        PostgreSQLでは、データ書き込みプロセスやWAL書き込みプロセスといった少数のプロセスがI/O要求の大半を占め、
        データアクセスもランダムアクセスが多いため、I/Oスケジューラは<m-b>mq-deadline</m-b>に設定することが推奨される。
        一方、RAIDドライバがI/Oスケジュールを行う場合や、NVMeのような高速なデバイスを利用する場合など、
        OSのI/Oスケジューラがオーバヘッドとなってしまうことがあり、その場合は<m-b>none</m-b>に設定することも検討する。
    </p>

    <h3>PostgreSQLのディスク設定</h3>
    <h4>システムに制限を設けるパラメータ</h4>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>デフォルト値</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>temp_file_limit</m-b></td>
                <td><m-b>-1</m-b></td>
                <td>
                    あるプロセスが一時ファイルとして利用可能な最大容量<br>
                    <m-b>-1</m-b>を指定する場合、制限なし。
                </td>
            </tr>
            <tr>
                <td><m-b>max_files_per_process</m-b></td>
                <td><m-b>1000</m-b></td>
                <td>あるプロセスが同時に開くことのできるファイル数の上限</td>
            </tr>
        </tbody>
    </table>
    <h4>ライタに関して、性能に影響を与えるパラメータ</h4>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>デフォルト値</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>bgwriter_delay</m-b></td>
                <td><m-b>200ms</m-b></td>
                <td>
                    バックグラウンドライタの動作周期<br>
                    動作周期の現実的な最小単位は<m-b>10ms</m-b>で、それ未満の値を設定しても切り上がる場合が多い。
                </td>
            </tr>
            <tr>
                <td><m-b>bgwriter_lru_maxpages</m-b></td>
                <td><m-b>100</m-b></td>
                <td>一度にバックグラウンドライタが書き込むページ数の上限</td>
            </tr>
            <tr>
                <td><m-b>bgwriter_lru_multiplier</m-b></td>
                <td><m-b>2.0</m-b></td>
                <td>
                    書き込みが必要になったページのうち、どのくらいの割合を書き込むのか<br>
                    直近の書き込み量と比較して、何倍まで処理するべきか予測するのに使用する。
                </td>
            </tr>
            <tr>
                <td><m-b>bgwriter_flush_after</m-b></td>
                <td><m-b>512kB(Linux)</m-b><br>または<m-b>0(それ以外)</m-b></td>
                <td>
                    OSに対して記憶媒体への書き込みを強制する、バックグラウンドライタの書き込みの上限値<br>
                    単位省略時は<m-b>ページ数</m-b>の指定となり、<m-b>0</m-b>を指定した場合はOSへの書き込み強制を無効化する。
                </td>
            </tr>
        </tbody>
    </table>
    <h4>WALに関して、性能に影響を与えるパラメータ</h4>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>デフォルト値</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>walwriter_delay</m-b></td>
                <td><m-b>200ms</m-b></td>
                <td>
                    WALライタの動作周期<br>
                    動作周期の現実的な最小単位は<m-b>10ms</m-b>で、それ未満の値を設定しても切り上がる場合が多い。
                </td>
            </tr>
            <tr>
                <td><m-b>max_wal_size</m-b></td>
                <td><m-b>1GB</m-b></td>
                <td>
                    チェックポイント間のWALの最大サイズ<br>
                    最後のチェックポイント実行からこのサイズのWALが生成されるとチェックポイントが動作する。
                </td>
            </tr>
            <tr>
                <td><m-b>min_wal_size</m-b></td>
                <td><m-b>80MB</m-b></td>
                <td>
                    リサイクル対象となる古いWALファイルのサイズ<br>
                    チェックポイント後にこの設定値分のファイルは削除されずに、再利用可能な状態で維持される。
                </td>
            </tr>
            <tr>
                <td><m-b>checkpoint_timeout</m-b></td>
                <td><m-b>5min</m-b></td>
                <td>チェックポイントの間隔</td>
            </tr>
            <tr>
                <td><m-b>checkpoint_completion_target</m-b></td>
                <td>
                    <m-b>0.5</m-b>(~PostgreSQL13)<br>
                    <m-b>0.9</m-b>(PostgreSQL14~)
                </td>
                <td>
                    次のチェックポイント発生までのインターバルのうち、チェックポイント完了までの時間の比率<br>
                    ここで指定した比率の時間でチェックポイント処理が完了するようにI/O負荷が自動調整される。
                </td>
            </tr>
        </tbody>
    </table>

    <h2>11章 高可用性と負荷分散</h2>

    <h3>サーバの役割と呼び名</h3>
    <table>
        <thead>
            <tr>
                <th>役割</th>
                <th>呼び名</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>データの読み書きを行う</td>
                <td>
                    <ul>
                        <li><m-b>読み書きサーバ</m-b></li>
                        <li><m-b>マスタ</m-b></li>
                        <li><m-b>プライマリ</m-b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>プライマリ側の変更を追跡する</td>
                <td>
                    <ul>
                        <li><m-b>スレーブ</m-b></li>
                        <li><m-b>スタンバイ</m-b></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>昇格するまでデータを読み書きできない</td>
                <td><m-b>ウォームスタンバイ</m-b></td>
            </tr>
            <tr>
                <td>昇格しなくてもデータの読み込みができる</td>
                <td><m-b>ホットスタンバイ</m-b></td>
            </tr>
        </tbody>
    </table>

    <h3>レプリケーションの方式</h3>
    <table>
        <thead>
            <tr>
                <th>方式</th>
                <th>特徴</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>共有ディスク</m-b></td>
                <td>
                    プライマリとスタンバイでデータベースクラスタを共有する。
                    プライマリ稼働中はスタンバイは停止している必要がある。
                </td>
            </tr>
            <tr>
                <td><m-b>ファイルシステムレプリケーション</m-b></td>
                <td>共有ディスク相当の機能をソフトウェアレベルで行い、プライマリとスタンバイでデータベースクラスタを共有する。</td>
            </tr>
            <tr>
                <td><m-b>ログシッピング</m-b></td>
                <td>WALベースのレプリケーション</td>
            </tr>
            <tr>
                <td><m-b>トリガベースレプリケーション</m-b></td>
                <td>プライマリへの更新をトリガとして、スタンバイに同じ更新を伝播する。</td>
            </tr>
            <tr>
                <td><m-b>SQLベースレプリケーション</m-b></td>
                <td>プライマリとスタンバイに同じSQLを送るミドルウェアを仲介させて実現する。</td>
            </tr>
        </tbody>
    </table>

    <h3>ストリーミングレプリケーション</h3>
    <p>
        PostgreSQL本体に備わったレプリケーション機能で、WALをファイル単位でなく変更内容(<m-b>WALレコード</m-b>)単位で送信する。
        PostgreSQL9.0で<m-b>非同期レプリケーション</m-b>が導入されて以降、<m-b>同期レプリケーション</m-b>、<m-b>カスケードレプリケーション</m-b>、
        <m-b>remote_writeモードレプリケーション</m-b>が導入されてきた。
    </p>
    <h4>仕組み</h4>
    <p>
        スタンバイは、プライマリで生成された<m-b>WAL</m-b>を再実行することでレプリケーションを実現する。
        WALは、データベースの性能を担保しつつ、データの<m-b>永続性</m-b>を保証する仕組みである。
        テーブルやインデックスの更新時に、テーブルファイルやインデックスファイルに直接書き込みをすると性能が劣化するが、
        更新時は<m-b>WALレコード</m-b>のみ同期書き込みを行う。<br>
        WALレコードには、<m-b>LSN</m-b>(<m-b>Long Sequence Number</m-b>)と呼ばれる一位の値が払いだされる。
        リカバリ時は、必要なLSN位置から順に再実行される。
        これは単なる文字列ではなく、<m-b>pg_lsn</m-b>というデータ型で扱われる。
        これにより、比較演算や差分演算が容易となった。<br>
        WALレコードを出力しない<m-b>unlogged</m-b>テーブルでは、ストリーミングレプリケーションによるレプリケーションはできない。
    </p>

    <h3>ストリーミングレプリケーションの設定</h3>
    <h4>walsenderプロセスで必要な設定</h4>
    <table>
        <thead>
            <tr>
                <th>設定ファイル</th>
                <th>パラメータ</th>
                <th>設定値</th>
                <th>デフォルト値</th>
            </tr>
        </thead>
        <tbody>
        <tbody>
            <tr>
                <td rowspan="4">postgresql.conf</td>
                <td><m-b>wal_level</m-b></td>
                <td><m-b>replica</m-b></td>
                <td><m-b>replica</m-b></td>
            </tr>
            <tr>
                <td><m-b>max_wal_senders</m-b></td>
                <td><m-b>1以上</m-b></td>
                <td><m-b>10</m-b></td>
            </tr>
            <tr>
                <td><m-b>archive_mode</m-b></td>
                <td><m-b>on</m-b></td>
                <td><m-b>off</m-b></td>
            </tr>
            <tr>
                <td><m-b>archive_command</m-b></td>
                <td><m-b>WALをアーカイブ領域に移すコマンド</m-b></td>
                <td><m-b>空文字</m-b></td>
            </tr>
            <tr>
                <td><m-b>pg_hba.conf</m-b></td>
                <td colspan="3">
                    database列に<m-b>"replication"</m-b>
                </td>
            </tr>
        </tbody>
        </tbody>
    </table>
    <h4>walreceiverプロセスで必要な設定</h4>
    <table>
        <thead>
            <tr>
                <th>設定ファイル</th>
                <th>パラメータ</th>
                <th>設定値</th>
                <th>デフォルト値</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="3">postgresql.conf</td>
                <td><m-b>hot_standby</m-b></td>
                <td><m-b>on</m-b></td>
                <td><m-b>on</m-b></td>
            </tr>
            <tr>
                <td><m-b>restore_command</m-b></td>
                <td><m-b>アーカイブファイルをpg_walに移すコマンド</m-b></td>
                <td><m-b>空文字</m-b></td>
            </tr>
            <tr>
                <td><m-b>primary_conninfo</m-b></td>
                <td><m-b>プライマリへの接続情報</m-b></td>
                <td><m-b>空文字</m-b></td>
            </tr>
        </tbody>
    </table>
    <p>
        上記以外にも、スタンバイとして起動するにはデータベースクラスタに<m-b>standby.signal</m-b>ファイルを配置する。
        なお、これはPostgreSQL12以降の仕様で、11以前は<m-b>recovery.conf</m-b>に設定を記述していた。
        12以降では、データベースクラスタに<m-b>recovery.conf</m-b>というファイルが存在する場合、PostgreSQLが起動しない仕様となっている。
    </p>

    <h3>ストリーミングレプリケーションのプロセス</h3>
    <h4>walsender/walreceiverプロセスの処理</h4>
    <p>
        walsenderとwalreceiverがWALをやり取りするとき、<m-b>walreceiver</m-b>が主導して処理が行われる。
        このため、パラメータ<m-b>max_wal_receiver</m-b>の限り、動的にスタンバイを増設できる。<br>
        walreceiverがWALレコードを受け取ると、次の順に処理が行われる。
    </p>
    <ol>
        <li>walsenderプロセスにWALレコードを受け取ったことを通知する</li>
        <li>walreceiverプロセスは受け取ったWALレコードを<m-b>同期書き込み</m-b>する</li>
        <li>
            walreceiverプロセスは、<m-b>startup</m-b>プロセス(実際に<m-b>リカバリ</m-b>処理を行うプロセス)に、
            WALレコードを受け取ったことを通知する
        </li>
        <li><m-b>startup</m-b>プロセスがWALレコードを、再適用する</li>
    </ol>

    <h3>可能なレプリケーション構成</h3>
    <p>
        ストリーミングレプリケーションは、<m-b>1:n</m-b>の関係でスタンバイを構成できる、
        <m-b>マルチスタンバイ構成</m-b>と呼ばれる構成である。
        また、スタンバイに対しさらにスタンバイを接続する<m-b>カスケード構成</m-b>も構成可能である。
        これらの共通点は、<m-b>プライマリは1台</m-b>という点である。
    </p>
    <h4>同期/非同期</h4>
    <p>
        レプリケーションにおける同期/非同期の違いは、プライマリが<m-b>スタンバイへのWAL適用</m-b>を待機するかどうかである。
        同期/非同期の設定は、<m-b>プライマリ</m-b>のpostgresql.confのパラメータ<m-b>synchronous_commit</m-b>で次表のように設定できる。
    </p>
    <table>
        <thead>
            <tr>
                <th>設定値</th>
                <th>同期/非同期</th>
                <th>プライマリのWAL処理</th>
                <th>スタンバイのWAL処理</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>off</m-b></td>
                <td>非同期</td>
                <td><m-b>待たない</m-b></td>
                <td>待たない</td>
            </tr>
            <tr>
                <td><m-b>local</m-b></td>
                <td>非同期</td>
                <td><m-b>待つ</m-b></td>
                <td>待たない</td>
            </tr>
            <tr>
                <td><m-b>remote_write</m-b></td>
                <td>同期</td>
                <td><m-b>待つ</m-b></td>
                <td><m-b>メモリ</m-b>への書き込みまで待つ</td>
            </tr>
            <tr>
                <td><m-b>on</m-b></td>
                <td>同期</td>
                <td><m-b>待つ</m-b></td>
                <td><m-b>ディスク</m-b>への書き込みまで待つ</td>
            </tr>
            <tr>
                <td><m-b>remote_apply</m-b></td>
                <td>同期</td>
                <td><m-b>待つ</m-b></td>
                <td><m-b>WAL</m-b>が適用されるまで待つ</td>
            </tr>
        </tbody>
    </table>

    <h3>複数のスタンバイ設定</h3>
    <p>
        どのスタンバイを同期として扱うかは、<m-b>プライマリ</m-b>のpostgresql.confの
        パラメータ<m-b>synchronous_standby_names</m-b>で、
        スタンバイを一意に特定する文字列を<m-b>カンマ</m-b>区切りで指定する。<br>
        次に、パラメータの設定例をいくつか示す。
    </p>
    <h4>接続できた1番左のスタンバイを同期として扱う場合</h4>
    <pre><code>
<m-b>synchronous_standby_names = 'sby,sby2,sby3'</m-b>
    </code></pre>
    <h4>先頭から2つのスタンバイを同期として扱う場合</h4>
    <pre><code>
<m-b>synchronous_standby_names = 'FIRST 2 (sby,sby2,sby3)'</m-b>
    </code></pre>
    <h4>いずれか2つのスタンバイを同期として扱う場合</h4>
    <pre><code>
<m-b>synchronous_standby_names = 'ANY 2 (sby,sby2,sby3)'</m-b>
    </code></pre>
    <p>
        なお、synchronous_standby_namesが空白の場合、<m-b>どのスタンバイも同期として扱わない</m-b>として解釈されるため、注意が必要である。
        スタンバイを一意に特定する文字列は、<m-b>各スタンバイ</m-b>のpostgresql.confでパラメータ<m-b>primary_conninfo</m-b>に
        <m-b>application_name</m-b>を含めて設定する。
        次に、ユーザ=postgres、ポート番号=5432、スタンバイを一意に特定する文字列=sbyとしてパラメータを指定する例を示す。
    </p>
    <pre><code>
<m-b>primary_conninfo = 'user=postgres port=5432 application_name=sby'</m-b>
    </code></pre>

    <h3>レプリケーションの状況確認</h3>
    <ul>
        <li>
            <b><m-b>サーバーログ</m-b>の確認</b><br>
            プライマリとスタンバイのサーバーログにレプリケーションの開始ログが出力されていることを確認する。
        </li>
        <li>
            <b><m-b>プロセス</m-b>の確認</b><br>
            プライマリではwalsenderプロセス、スタンバイではwalreceiverプロセスが起動していることを<m-b>ps</m-b>コマンドなどを使って確認する。
        </li>
        <li>
            <b><m-b>レプリケーション遅延</m-b>の確認</b><br>
            プロセスが正常に動作していることを、<m-b>pg_stat_replication</m-b>ビューを見て確認する。
            pg_stat_replicationビューは次のカラムを持つ。
            <table>
                <thead>
                    <tr>
                        <th>カラム</th>
                        <th>説明</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><m-b>application_name</m-b></td>
                        <td>スタンバイを特定する文字列</td>
                    </tr>
                    <tr>
                        <td><m-b>state</m-b></td>
                        <td>プライマリの状態</td>
                    </tr>
                    <tr>
                        <td><m-b>sent_lsn</m-b></td>
                        <td>プライマリが送信したLSN</td>
                    </tr>
                    <tr>
                        <td><m-b>write_lsn</m-b></td>
                        <td>バッファへの書き込みが完了したLSN</td>
                    </tr>
                    <tr>
                        <td><m-b>flush_lsn</m-b></td>
                        <td>同期書き込みが完了したLSN</td>
                    </tr>
                    <tr>
                        <td><m-b>replay_lsn</m-b></td>
                        <td>WALの適用が完了したLSN</td>
                    </tr>
                    <tr>
                        <td><m-b>sync_state</m-b></td>
                        <td>スタンバイの同期状態</td>
                    </tr>
                </tbody>
            </table>
            <br>
            なお、LSNを比較する場合は、差分を出力する関数<m-b>pg_wal_lsn_diff</m-b>を用いるとよい。<br>
            pg_stat_replicationビューは、プライマリから接続するスタンバイの情報を各行に出力するが、<m-b>カスケード接続</m-b>には対応していない。
            その場合、walreceiverが存在する各サーバで確認する必要がある。
        </li>
    </ul>

    <h3>レプリケーションの管理</h3>
    <p>
        プライマリが停止した場合に、スタンバイを昇格する方法は次の3つがある。
    </p>
    <ul>
        <li>パラメータ<m-b>promote_trigger_file</m-b>を用いる方法</li>
        <li>コマンド<m-b>pg_ctl promote</m-b>を用いる方法</li>
        <li>関数<m-b>pg_promote</m-b>を用いる方法</li>
    </ul>
    <h4>promote_trigger_fileを用いる</h4>
    <p>
        <m-b>スタンバイ</m-b>のpostgre.sqlでパラメータpromote_trigger_fileを設定している場合、
        ファイルを生成することで昇格処理がなされる。
        PostgreSQL11以前では、<m-b>スタンバイ</m-b>のrecovery.confでパラメータ<m-b>trigger_file</m-b>を設定することでも同様の操作ができる。
        promote_trigger_fileには任意のファイルパスを指定でき、そのファイルパスにファイルが作成されると昇格処理が行われる。
    </p>
    <h4>pg_promoteを用いる</h4>
    <p>
        <m-b>スーパユーザ</m-b>権限で関数pg_promoteを実行すると、昇格処理がなされる。
        pg_promoteは引数、<m-b>Boolean</m-b>型の<m-b>wait</m-b>と<m-b>Integer</m-b>型の<m-b>wait_seconds</m-b>を
        受け取り、デフォルトは<m-b>wait=true</m-b>、<m-b>wait_seconds=60</m-b>である。
        これは、完了するのを<m-b>60</m-b>秒待ち、処理が成功すれば<m-b>True</m-b>、失敗すれば<m-b>False</m-b>を返す。
        なお、wait=Falseとする場合、処理の成否にかかわらず<m-b>True</m-b>を返す。
    </p>
    <h4>タイムラインID</h4>
    <p>
        昇格したスタンバイは、<m-b>タイムラインID</m-b>が1つ繰り上がる。
        タイムラインIDは、バックアップからのリカバリ時に過去の任意の時点に戻すことができるメリットがあるが、
        レプリケーションにおいてはプライマリとスタンバイが同じタイムラインIDを持つ必要がある。
        通常、<m-b>スタンバイ</m-b>のpostgresql.confのパラメータ<m-b>recovery_target_timeline</m-b>に<m-b>latest</m-b>を指定し、
        タイムラインの変更に追従してレプリケーションを行う設定とする。
    </p>

    <h3>ストリーミングレプリケーションの設定手順まとめ</h3>
    <h4>サーバ情報</h4>
    <ul>
        <li>プライマリ</li>
        <ul>
            <li>ホスト名: prm</li>
            <li>IPアドレス: 192.168.2.11</li>
        </ul>
        <li>スタンバイ</li>
        <ul>
            <li>ホスト名: sby</li>
            <li>IPアドレス: 192.168.2.12</li>
        </ul>
    </ul>
    <h4>設定手順</h4>
    <ol>
        <li>
            <b>プライマリの設定</b>
            <h5>postgresql.conf</h5>
            <pre><code>
wal_level = <m-b>'replica'</m-b>
max_wal_senders = 10
archive_mode = <m-b>on</m-b>
archive_command = <m-b>'cp %p /tmp/%f'</m-b>
synchronous_standby_names = <m-b>'sby'</m-b>
            </code></pre>
            <h5>pg_hba.conf</h5>
            <pre><code>
<m-b>host replication postgres 192.168.2.12/32 trust</m-b>
            </code></pre>
        </li>
        <li>
            <b>スタンバイのデータベースクラスタを用意</b>
            <h5>pg_basebackupコマンドによるデータベースクラスタのコピー</h5>
            <pre><code>
<m-b>pg_basebackup -R -D ${PGDATA} -h prm -p 5432</m-b>
            </code></pre>
        </li>
        <li>
            <b>スタンバイの設定変更</b>
            <p>
                スタンバイの設定を変更する場合、postgresql.confやpg_hba.confを変更する。
                また、スタンバイとして起動するために<m-b>standby.signal</m-b>ファイルを作成する。<br>
                なお、前述のpg_basebackupコマンドで<m-b>-R</m-b>オプションを指定する場合、
                <m-b>postgresql.auto.conf</m-b>にレプリケーション人必要な接続情報が記録され、
                自動的に<m-b>standby.signal</m-b>ファイルがデータベースクラスタ配下に作成される。
            </p>
        </li>
        <li>
            <b>動作確認</b>
            <p>
                <m-b>ログ</m-b>、<m-b>プロセス</m-b>の確認や、<m-b>pg_stat_replication</m-b>ビューの確認を行う。
            </p>
        </li>
    </ol>

    <h3>PostgreSQLで構成できる3つのスタンバイ</h3>
    <table>
        <thead>
            <tr>
                <th>スタンバイ</th>
                <th>状態</th>
                <th>メリット</th>
                <th>デメリット</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>コールドスタンバイ</m-b></td>
                <td>停止している</td>
                <td class="wrappable">運用が比較的楽である</td>
                <td><m-b>SPOF</m-b>が存在し、資源を無駄に使用するなどコストがかかる</td>
            </tr>
            <tr>
                <td><m-b>ウォームスタンバイ</m-b></td>
                <td>起動している</td>
                <td class="wrappable">特別な装置などが不要で構築できる</td>
                <td>非同期が前提となる直近のデータを参照できない</td>
            </tr>
            <tr>
                <td><m-b>ホットスタンバイ</m-b></td>
                <td>起動している</td>
                <td class="wrappable">できる限り直近のデータを参照可能で、スタンバイの資源を最大限活用できる</td>
                <td>同期のズレを意識した運用が必要となる</td>
            </tr>
        </tbody>
    </table>
    <h4>コールドスタンバイ</h4>
    <p>
        最も運用方法がシンプルな構成。
        プライマリとスタンバイが1つの<m-b>データ</m-b>を共有するため、切り替えてもデータの消失が発生することはない。
        また、通常はプライマリのみが起動していて、データベース運用はプライマリに対してのみ行えばよい。
        障害時は、スタンバイを起動するのみでよい。<br>
        一方、コールドスタンバイではスタンバイに対する<m-b>参照クエリ</m-b>が実行できなない。
        また、通常時にもスタンバイサーバ機を起動する必要があったり、<m-b>共有ディスク</m-b>など高額なディスク装置が必要であったり、
        コスト面の制約がある。<br>
        最も大きな制約は、共有ディスクが<m-b>SPOF</m-b>(<m-b>Single Point of Failure</m-b>:<m-b>単一障害点</m-b>)となることである。
        これを回避するためのディスクやファイルシステムに対する信頼性向上施策が考えられるが、コスト/運用面のインパクトが大きくなる。
    </p>
    <h4>ウォームスタンバイ</h4>
    <p>
        ストリーミングレプリケーションの<m-b>同期モード</m-b>と<m-b>非同期モード</m-b>で実現が可能。
        特別な装置やサードパーティアプリケーションがなくとも、PostgreSQL本体(および<m-b>contrib</m-b>モジュール)の機能で実現できることは、
        大きなメリットといえる。<br>
        非同期で実現する場合、データ損失につながるデメリットもあるが、スタンバイの応答を待たなくてよいメリットも存在する。
        このため、<m-b>災害対策用</m-b>にウォームスタンバイを遠隔地に配置するケースがある。
    </p>
    <h4>ホットスタンバイ</h4>
    <p>
        ホットスタンバイは、コールドスタンバイとウォームスタンバイの良いところを兼ね備えている。
        特別な装置は不要で、データ損失のリスクもほとんどない。
        スタンバイに<m-b>参照クエリ</m-b>を実行できるため、<m-b>同期モード</m-b>でのストリーミングレプリケーションが前提となる。
    </p>

    <h3>ホットスタンバイ</h3>
    <h4>実行可能なクエリ</h4>
    <p>
        ホットスタンバイでは次表に示す参照クエリのみが実行可能である。
        <m-b>トランザクションID</m-b>が払い出されず、<m-b>WAL</m-b>の書き出しも行われないため、更新処理は実行しない。
    </p>
    <table>
        <thead>
            <tr>
                <th>コマンド</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    <ul>
                        <li><m-b>SELECT</m-b></li>
                        <li><m-b>COPY TO</m-b></li>
                    </ul>
                </td>
                <td>読み取りクエリ</td>
            </tr>
            <tr>
                <td>
                    <ul>
                        <li><m-b>DECLARE</m-b></li>
                        <li><m-b>FETCH</m-b></li>
                        <li><m-b>CLOSE</m-b></li>
                    </ul>
                </td>
                <td>カーソル操作クエリ</td>
            </tr>
            <tr>
                <td>
                    <ul>
                        <li><m-b>SHOW</m-b></li>
                        <li><m-b>SET</m-b></li>
                        <li><m-b>RESET</m-b></li>
                    </ul>
                </td>
                <td>パラメータ操作クエリ</td>
            </tr>
            <tr>
                <td>
                    <ul>
                        <li><m-b>BEGIN</m-b></li>
                        <li><m-b>COMMIT</m-b></li>
                    </ul>
                </td>
                <td>DCL</td>
            </tr>
            <tr>
                <td>
                    <ul>
                        <li><m-b>ACCESS SHARE</m-b></li>
                        <li><m-b>ROW SHARE</m-b></li>
                        <li><m-b>ROW EXCLUSIVE</m-b></li>
                    </ul>
                </td>
                <td>いずれかを指定したLOCK TABLEコマンド</td>
            </tr>
            <tr>
                <td>
                    <ul>
                        <li><m-b>PREPARE</m-b></li>
                        <li><m-b>EXECUTE</m-b></li>
                        <li><m-b>DEALLOCATE</m-b></li>
                        <li><m-b>DISCARD</m-b></li>
                    </ul>
                </td>
                <td>プリペアドステートメントを操作するクエリ</td>
            </tr>
            <tr>
                <td>
                    <ul>
                        <li><m-b>LOAD</m-b></li>
                    </ul>
                </td>
                <td>ライブラリ読み込み操作</td>
            </tr>
        </tbody>
    </table>
    <h4>ベースバックアップの取得</h4>
    <p>
        スタンバイからコマンド<m-b>pg_basebackup</m-b>を用いてベースバックアップを取得できる。
        ベースバックアップは、コマンド<m-b>pg_start_backup</m-b>や<m-b>pg_stop_backup</m-b>を用いても取得できるが、
        ホットスタンバイではこれらの関数を直接実行できない。<br>
        スタンバイのバックアップからリカバリを行うとき、パラメータ<m-b>hot_standby</m-b>をonにして任意の時刻やトランザクションIDを指定してリカバリを行うと、
        完了した後に<m-b>一時停止</m-b>する。
        これは、<m-b>スタンバイ</m-b>のpostgresql.confでパラメータ<m-b>recovery_target_action</m-b>がデフォルト値の<m-b>pause</m-b>に設定されている際の挙動であり、
        適切な位置にリカバリできたかを確認するための仕様である。
        一刻も早く再開したい場合、<m-b>promote</m-b>を指定することで一時停止せずに起動させることができる。<br>
        なお、一時停止したリカバリを操作するために、次表のような関数が存在する。
    </p>
    <table>
        <thead>
            <tr>
                <th>関数</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>pg_is_wal_replay_paused()</m-b></td>
                <td>リカバリが停止中であればTrueを返す</td>
            </tr>
            <tr>
                <td><m-b>pg_wal_replay_pause()</m-b></td>
                <td>即座にリカバリを停止する</td>
            </tr>
            <tr>
                <td><m-b>pg_wal_replay_resume()</m-b></td>
                <td>リカバリ停止中であれば再開する</td>
            </tr>
        </tbody>
    </table>
    <h4>ホットスタンバイの弱点</h4>
    <p>
        ホットスタンバイの弱点は、<m-b>コンフリクト</m-b>である。
        これは、プライマリとスタンバイの操作が衝突することである。
        コンフリクトが発生した場合、デフォルトで<m-b>30秒</m-b>程度スタンバイのWAL適用を待機し、参照クエリは<m-b>エラー</m-b>となる。<br>
        コンフリクトに関する統計情報は、<m-b>pg_stat_database_conflicts</m-b>ビューを参照する。
        また、PostgreSQL14以降では、postgresql.confのパラメータ<m-b>log_recovery_conflict_waits</m-b>を設定することで、
        コンフリクト発生時にログを出力できる。(デフォルトは<m-b>off</m-b>である)
    </p>

    <h3>フェイルオーバーの対応</h3>
    <p>
        異常が発生したサーバを切り離してサービスを継続する仕組みを<m-b>フェイルオーバー</m-b>という。
        PostgreSQLには自動でフェイルオーバーを行う仕組みがないため、<m-b>Pacemaker</m-b>などのHAクラスタソフトウェアを組み合わせた運用が行われる。
        プライマリとスタンバイでフェイルオーバーの手順が異なる。
    </p>
    <h4>プライマリのフェイルオーバー</h4>
    <p>
        プライマリをフェイルオーバーする場合、コマンド<m-b>pg_ctl promote</m-b>などを用いてスタンバイを昇格する必要がある。
        なお、プライマリからクライアントにコミットが返却されない場合でも、スタンバイのWALは更新されていて、
        この状態でスタンバイを昇格するとスタンバイのWAL適用と共にコミット済みとなる可能性がある。
        これを防ぐ仕組みはPostgreSQLに用意されていないため、この場合はデータベース管理者の介入やアプリケーション側の対応が必要となる。
    </p>
    <h4>スタンバイのフェイルオーバー</h4>
    <p>
        スタンバイをフェイルオーバーする場合、<m-b>プライマリ</m-b>のpostgresql.confでパラメータ<m-b>synchronous_standby_names</m-b>をメンテナンスする必要がある。
        <m-b>synchronous_standby_names</m-b>を複数指定していて同期レプリケーションのスタンバイの数に余裕がある場合、自動で他のスタンバイを同期スタンバイとみなして動作するが、
        不足する場合は<m-b>synchronous_standby_names</m-b>を空にして設定ファイルの再読み込み(<m-b>pg_ctl reload</m-b>など)を行う必要がある。
    </p>

    <h3>プライマリ/スタンバイの監視</h3>
    <h4>walsender/walreceiverプロセスの動作確認とタイムアウト</h4>
    <p>
        walsender/walreceiverプロセスの動作確認は、プロセス自身の存在確認だけでなく、ネットワーク以上による待ちが発生していないかも確認する必要がある。
        待ち状態を確認するには、パラメータ<m-b>wal_sender_timeout</m-b>と<m-b>wal_receiver_timeout</m-b>を設定し、
        タイムアウト時間を指定する。(デフォルトは<m-b>60秒</m-b>)
        これにより、プロセスがタイムアウトした場合に<m-b>ログ</m-b>が出力され、<m-b>wal_sender</m-b>プロセスは停止する。
        また、<m-b>wal_receiver</m-b>プロセスは停止後に再起動し、レプリケーションの継続を試みる。
    </p>
    <h4>レプリケーションの状況確認</h4>
    <p>
        レプリケーションの状況を確認するには、walreceiverプロセスにおけるWAL受信位置(<m-b>receive位置</m-b>)とWAL適用位置(<m-b>replay位置</m-b>)を確認すればよい。
        位置確認には<m-b>pg_stat_replication</m-b>ビューを用いる方法があるが、次の点に注意点がある。
        このビューの更新頻度は、<m-b>write位置</m-b>または<m-b>flush位置</m-b>に変更があったとき、または<m-b>wal_receiver_status_interval</m-b>によって設定されている時間が経過したときである。
        デフォルトで<m-b>wal_receiver_status_interval</m-b>は<m-b>10秒</m-b>なので、<m-b>replay</m-b>位置は若干の差異が生じる可能性がある。<br>
        この差異が許容できない場合、スタンバイで直接replay位置を確認する必要がある。
        具体的には、最後のreceive位置を確認する関数<m-b>pg_last_wal_receive_location</m-b>と、最後のreplay位置を確認する関数<m-b>pg_last_wal_replay_location</m-b>を用いる。
    </p>

    <h3>プライマリ/スタンバイの再読み込み</h3>
    <p>
        故障したプライマリ/スタンバイをもう一度レプリケーション状態に戻す方法を見ていく。<br>
        スタンバイを再度組み込むことは比較的容易である。
        同期レプリケーションの仕組み上、スタンバイがプライマリより進んでしまうことはないため、スタンバイを再起動すればよい。
        このとき、届いていなかったプライマリの<m-b>WALレコード</m-b>が自動的にスタンバイに転送され、適用される。
        ただし、スタンバイが停止している時間が長い場合、プライマリのWAL領域に必要なWALレコードが存在しない場合が考えられる。
        このような状況を回避するために、<m-b>スタンバイ</m-b>のpostgre.sqlで<m-b>archive_mode</m-b>を<m-b>always</m-b>にしておき、
        スタンバイ側でもWALファイルをアーカイブできるようにする。
        これにより、WALファイルのコピーを行うことなくスタンバイを組み込める。<br>
        一方、プライマリを再度組み込む場合は、プライマリ/スタンバイのどちらが進んでいるかが不明なため、注意が必要である。
        新プライマリ(<m-b>昇格したスタンバイ</m-b>)の方が過去の状態の場合、そこに進んでしまった旧プライマリを組み込んでも、
        新プライマリから適切なWALレコードが取得できないため、レプリケーションを適用できない。<br>
        新プライマリ、新スタンバイでそれぞれWALの適用位置を確認し、矛盾がある場合はベースバックアップを取得して再構築を行う。
        または、コマンド<m-b>pg_rewind</m-b>を用いて、差分のみを解消する手段もある。
        このコマンドを使用する場合、postgresql.confのパラメータ<m-b>wal_log_hints</m-b>をonにするか、クラスタ初期化時に<m-b>データチェックサム</m-b>を有効化する必要がある。
        また、<m-b>スーパユーザ</m-b>権限と<m-b>replication</m-b>権限が必要となる。
    </p>

    <h3>コンフリクトの緩和策</h3>
    <p>
        コンフリクトが発生すると、デフォルトで<m-b>30秒</m-b>の間スタンバイのWAL適用が待機されるが、この時間が致命的なシステムにおいてはパラメータを調整する必要がある。
        WAL適用の待機時間を設定するパラメータは、次のものがある。
    </p>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>
                    <nobr>最小単位</nobr>
                </th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>max_standby_archive_delay</m-b></td>
                <td><m-b>ms</m-b></td>
                <td>スタンバイがアーカイブファイルを適用している最中に発生したコンフリクトの待ち時間</td>
            </tr>
            <tr>
                <td><m-b>max_standby_streaming_delay</m-b></td>
                <td><m-b>ms</m-b></td>
                <td>スタンバイがプライマリから受け取ったWALを適用している際に発生したコンフリクトの待ち時間</td>
            </tr>
        </tbody>
    </table>
    <p>
        また、VACUUMやHOTによる行データ削除と参照処理がコンフリクトする場合、次のパラメータを調整する。
    </p>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>設定先</th>
                <th>
                    <nobr>デフォルト値</nobr>
                </th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>vacuum_defer_cleanup_age</m-b></td>
                <td><m-b>プライマリ</m-b></td>
                <td><m-b>0</m-b></td>
                <td>
                    行データ削除をどの程度遅らせるかを、トランザクション数で指定する<br>
                    デフォルト設定では、プライマリは即座にVACUUMやHOTによる行データの削除を行う。
                </td>
            </tr>
            <tr>
                <td><m-b>hot_standby_feedback</m-b></td>
                <td><m-b>スタンバイ</m-b></td>
                <td><m-b>off</m-b></td>
                <td>
                    スタンバイがプライマリに対してトランザクションに関する情報を送信するかの設定<br>
                    onに設定することで、パラメータ<m-b>wal_receiver_status_interval</m-b>毎に、トランザクションに関する情報を送信する。
                    このパラメータを設定したうえでスタンバイのトランザクションが閉じずに残存してしまうと、
                    プライマリで不要な行が急激に増えてしまうため注意が必要である。
                </td>
            </tr>
        </tbody>
    </table>
    <p>
        これらのパラメータを設定した場合、WAL領域の使用率が上昇する。
        WAL領域の使用率を調整する場合、パラメータ<m-b>wal_keep_size</m-b>(デフォルト値:<m-b>0</m-b>)を指定する。
        このパラメータはスタンバイが必要とする可能性のあるWALファイルを保持するため、保持する容量を<m-b>MB</m-b>単位で指定する。
        多くの場合、max_wal_sizeが適切に設定されていれば問題にはならないが、細かい調整が必要な場合にはチューニングポイントとなる。<br>
        また、<m-b>レプリケーションスロット</m-b>とパラメータ<m-b>maz_slot_wal_keep_size</m-b>(デフォルト値:<m-b>-1</m-b>)でも同様の制御が可能である。
    </p>

    <h2>12章 論理レプリケーション</h2>
    <p>
        論理レプリケーションとは、PostgreSQL10で導入されたレプリケーション機能である。
        <m-b>データベースクラスタ</m-b>全体を対象とするストリーミングレプリケーションとは異なり、<m-b>テーブル</m-b>や<m-b>操作</m-b>を対象に
        レプリケーション構成を取ることが可能である。
    </p>

    <h3>論理レプリケーションの仕組み</h3>
    <p>
        ストリーミングレプリケーションと同様に、<m-b>WAL</m-b>を転送することで実現されている。
        基盤となっている技術としては、次がある。
    </p>
    <ul>
        <li><m-b>ロジカルデコーディング</m-b></li>
        <li><m-b>バックグラウンドワーカ</m-b></li>
    </ul>
    <h4>論理レプリケーションの制限事項</h4>
    <p>
        論理レプリケーションの出力プラグインとして、<m-b>pgoutput</m-b>が使用される。
        このモジュールは<m-b>DML</m-b>と<m-b>TRUNCATE</m-b>のみに対応していて、その他の処理は基本的にレプリケーションすることができない。
        また、<m-b>UPDATE</m-b>と<m-b>DELETE</m-b>については、事前に<m-b>REPLICA IDENTITY</m-b>を設定する必要がある。
        これは、外部システムで更新/削除する行を特定するために利用するキーで、テーブル単位で指定する。
        ALTER TABLE文で指定する場合、次のように指定する。
    </p>
    <pre><code>
ALTER TABLE テーブル名 <m-b>REPLICA IDENTITY 設定値</m-b>;
    </code></pre>
    <p>
        設定値としては、次表に示すキーワードを指定できる。
    </p>
    <table>
        <thead>
            <tr>
                <th>キーワード</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>DEFAULT</m-b></td>
                <td>主キー</td>
            </tr>
            <tr>
                <td><m-b>USING INDEX インデックス名</m-b></td>
                <td>指定したインデックス(<m-b>ユニーク</m-b>かつ<m-b>NOT NULL</m-b>)</td>
            </tr>
            <tr>
                <td><m-b>FULL</m-b></td>
                <td>行全体をキーとする</td>
            </tr>
            <tr>
                <td><m-b>NOTHING</m-b></td>
                <td>キーを使用しない</td>
            </tr>
        </tbody>
    </table>

    <h3>パブリケーションとサブスクリプション</h3>
    <p>
        ストリーミングレプリケーションでは、送信/受信の役割が明確のため、プライマリ/スタンバイという呼び方をするが、
        論理レプリケーションでは各サーバで読み込みと書き込みを行うため、<m-b>パブリッシャ</m-b>/<m-b>サブスクライバ</m-b>という呼び方をする。<br>
        パブリッシャが公開(<m-b>パブリケーション</m-b>)する情報を、サブスクライバが購読(<m-b>サブスクリプション</m-b>)することで、レプリケーションを実現する。
        パブリッシャとして<m-b>walsender</m-b>プロセスを、サブスクライバとして<m-b>logical replication worker</m-b>プロセスを起動する。
        これらのプロセスを起動するため、次表のようなパラメータを設定する。
        なお、ストリーミングレプリケーションと同様に、<m-b>パブリッシャ</m-b>側のpostgresql.confのパラメータ<m-b>synchronous_standby_names</m-b>に<m-b>サブスクリプション名</m-b>を指定することで、
        同期モードで論理レプリケーションできる。
    </p>
    <h4>パブリッシャの設定</h4>
    <table>
        <thead>
            <tr>
                <th>ファイル</th>
                <th>パラメータ</th>
                <th>設定値</th>
                <th>デフォルト値</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="3">postgresql.conf</td>
                <td><m-b>wal_level</m-b></td>
                <td><m-b>logical</m-b></td>
                <td><m-b>replica</m-b></td>
            </tr>
            <tr>
                <td><m-b>max_replication_slots</m-b></td>
                <td><m-b>2以上</m-b></td>
                <td><m-b>10</m-b></td>
            </tr>
            <tr>
                <td><m-b>max_wal_senders</m-b></td>
                <td><m-b>2以上</m-b></td>
                <td><m-b>10</m-b></td>
            </tr>
            <tr>
                <td><m-b>pg_hba.conf</m-b></td>
                <td colspan="3">
                    <m-b>サブスクライバ</m-b>からの接続を許可
                </td>
            </tr>
            <tr>
                <td>コマンド</td>
                <td colspan="3">
                    公開するテーブルの指定<br>
                    すべてのテーブルを公開する場合:<m-b>CREATE PUBLICATION パブリケーション名 FOR ALL TABLES;</m-b>
                </td>
            </tr>
        </tbody>
    </table>
    <h4>サブスクライバの設定</h4>
    <table>
        <thead>
            <tr>
                <th>ファイル</th>
                <th>パラメータ</th>
                <th>設定値</th>
                <th>デフォルト値</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="4">postgresql.conf</td>
                <td><m-b>max_replication_slots</m-b></td>
                <td><m-b>1以上</m-b></td>
                <td><m-b>10</m-b></td>
            </tr>
            <tr>
                <td><m-b>max_sync_workers_per_subscription</m-b></td>
                <td><m-b>1以上</m-b></td>
                <td><m-b>2</m-b></td>
            </tr>
            <tr>
                <td><m-b>max_logical_replication_workers</m-b></td>
                <td><m-b>2以上</m-b></td>
                <td><m-b>4</m-b></td>
            </tr>
            <tr>
                <td><m-b>max_worker_processes</m-b></td>
                <td><m-b>3以上</m-b></td>
                <td><m-b>8</m-b></td>
            </tr>
            <tr>
                <td>コマンド</td>
                <td colspan="3">
                    接続情報及び購読する公開情報の指定<br>
                    <m-b>CREATE SUBSCRIPTION サブスクリプション名<br>CONNECTION 接続情報 PUBLICATION パブリケーション名;</m-b>
                </td>
            </tr>
        </tbody>
    </table>

    <h3>可能なレプリケーション構成</h3>
    <p>
        論理レプリケーションは、ストリーミングレプリケーションと同じく<m-b>1:n</m-b>の<m-b>マルチサブスクライバ</m-b>構成や
        <m-b>カスケード</m-b>構成を取ることができる。
        また、<m-b>n:1</m-b>で複数のデータベースからレプリケーションしたり、双方向の構成を取ることもできる。
        双方向の場合、<m-b>コンフリクト</m-b>のリスクがあるため注意が必要となる。<br>
        論理レプリケーションは、メジャーバージョンが異なるデータベース間であっても行うことができる。
        そのため、<m-b>メジャーバージョンアップ</m-b>の手法として活用が期待できる。
    </p>

    <h3>レプリケーションの状況確認</h3>
    <p>
        ストリーミングレプリケーションと同様に、次の手順で動作確認ができる。
    </p>
    <ul>
        <li><m-b>サーバログ</m-b>の確認</li>
        <li><m-b>プロセス</m-b>の確認</li>
        <li><m-b>レプリケーション遅延</m-b>の確認</li>
    </ul>

    <h3>論理レプリケーションの管理</h3>
    <p>
        論理レプリケーションでは、いずれのサーバも読み書きできる状態にあるため、故障時の昇格は必要ない。
        同期モードの場合、パラメータ<m-b>synchronous_standby_names</m-b>の編集やリロードが必要だが、非同期モードの場合はそれも必要ない。
        ただし、<m-b>レプリケーションスロット</m-b>の対応が必要となる。<br>
        論理レプリケーションの整合性を保つため、サブスクリプションを開始する時点(<m-b>CREATE SUBSCRIPTION</m-b>を実行する時点)で、
        自動的に<m-b>レプリケーションスロット</m-b>が作成される。
        作成されたレプリケーションスロットの情報は、<m-b>pg_replication_slots</m-b>ビューで確認できる。
        また、PostgreSQL14では、<m-b>pg_stat_replication_slots</m-b>ビューが追加され、管理がしやすくなっている。<br>
        サブスクライバが故障した場合、レプリケーションスロットによって<m-b>パブリッシャ</m-b>側の<m-b>WAL</m-b>領域にログが残る。
        復旧に時間が要する状況でこのログを削除したい場合、<m-b>pg_drop_replication_slot</m-b>関数でレプリケーションスロットを削除し、
        <m-b>pg_create_replication_slots</m-b>関数でレプリケーションスロットを作成する手順を取る。
    </p>

    <h3>論理レプリケーションの設定手順まとめ</h3>
    <h4>サーバ情報</h4>
    <ul>
        <li>パブリッシャ</li>
        <ul>
            <li>ホスト名: pub</li>
            <li>IPアドレス: 172.31.12.110</li>
            <li>対象データベース名: testdb</li>
            <li>対象テーブル名: testtbl(i int primary key, j int)</li>
        </ul>
        <li>サブスクライバ</li>
        <ul>
            <li>ホスト名: sub</li>
            <li>IPアドレス: 172.31.6.21</li>
        </ul>
    </ul>
    <h4>設定手順</h4>
    <ol>
        <li>
            <b>パブリッシャの設定</b>
            <h5>postgresql.conf</h5>
            <pre><code>
wal_level = <m-b>'logical'</m-b>
max_replication_slots = 10
max_wal_senders = 10
            </code></pre>
            <h5>pg_hba.conf</h5>
            <pre><code>
<m-b>host testdb postgres 172.31.6.21/32 trust</m-b>
            </code></pre>
        </li>
        <li>
            <b>パブリッシャ側でパブリケーションを作成</b><br>
            <pre><code>
psql testdb -c "<m-b>CREATE PUBLICATION mypub FOR TABLE testtbl</m-b>"
            </code></pre>
        </li>
        <li>
            <b>サブスクライバの設定</b>
            <h5>postgresql.conf</h5>
            <pre><code>
max_replication_slots = 10
<m-b>max_sync_workers_per_subscription</m-b> = 2
<m-b>max_logical_replication_workers</m-b> = 4
<m-b>max_worker_processes</m-b> = 8
            </code></pre>
        </li>
        <li>
            <b>サブスクライバでデータベースとテーブルを作成</b><br>
            <pre><code>
<m-b>createdb testdb</m-b>
psql testdb -c "CREATE TABLE testtbl(i int primary key, j int)"
            </code></pre>
        </li>
        <li>
            <b>サブスクライバでサブスクリプションを作成</b><br>
            <pre><code>
psql testdb -c "<m-b>CREATE SUBSCRIPTION mysub CONNECTION 'dbname=testdb host=pub' PUBLICATION mypub</m-b>"
            </code></pre>
        </li>
        <li>
            <b>動作確認</b><br>
            <p>
                <m-b>ログ</m-b>や<m-b>pg_stat_replication</m-b>ビュー、<m-b>pg_stat_replication_slots</m-b>ビュー、
                <m-b>pg_stat_subscription</m-b>ビュー、<m-b>walsender</m-b>プロセス、<m-b>logical replication worker</m-b>プロセス
                などの確認を行う。
            </p>
        </li>
    </ol>

    <h3>論理レプリケーションの運用</h3>
    <p>
        論理レプリケーションでは、サブスクリプション側でもデータ更新が可能なため、<m-b>コンフリクト</m-b>が発生する可能性がある。
        これが発生すると、<m-b>サーバログ</m-b>が出力され<m-b>レプリケーションは停止</m-b>する。
        この解決方法は、次の2つが考えられる。
    </p>
    <ol>
        <li>
            <b>サブスクライバ側でコンフリクトしたデータを<m-b>削除</m-b>する</b><br>
            ログなどを参照し、該当する行を削除する。
        </li>
        <li>
            <b>サブスクライブ側の操作をサブスクライバ側で<m-b>スキップ</m-b>する</b><br>
            サブスクライバ側で、コンフリクトが発生したパブリッシャの<m-b>サーバ名</m-b>と、スキップ後の<m-b>LSN</m-b>を指定し、
            関数<m-b>pg_replication_origin_advance</m-b>を実行する。
            パブリッシャのサーバ名は、ビュー<m-b>pg_replication_origin_status</m-b>のカラム<m-b>external_id</m-b>の値を参照する。
            スキップ後のLSNは、一度パブリッシャにアクセスし、関数<m-b>pg_current_wal_lsn</m-b>などで取得する。
        </li>
    </ol>

    <h2>13章 オンライン物理バックアップ</h2>

    <h3>オンライン物理バックアップの仕組み</h3>
    <p>
        オンライン物理バックアップでは、関数<m-b>pg_start_backup</m-b>と<m-b>pg_stop_backup</m-b>で静止点を作って、ベースバックアップを取得する。
        また、定期的にWALファイルをWAL領域から<m-b>アーカイブ</m-b>領域に転送するように、パラメータ<m-b>archive_command</m-b>を設定する。
    </p>

    <h3>pg_basebackupコマンドのメリット</h3>
    <p>
        pg_basebackupコマンドを用いることで、関数<m-b>pg_start_backup</m-b>と<m-b>pg_stop_backup</m-b>のみでは実現が面倒ないくつかの機能を利用できる。
        例えば、NW送信量のチューニング(オプション<m-b>--max-rate</m-b>)や進捗状況の確認(オプション<m-b>--progress</m-b>)を指定できる。<br>
        PostgreSQL11からは、データファイルの<m-b>チェックサム</m-b>を用いて、完全性を高めることができる。
        データファイルに破損があると、コマンド実行時にエラーが発生する。
    </p>

    <h3>関数pg_start_backupの処理内容</h3>
    <ol>
        <li><m-b>共有メモリ</m-b>上のステータスを「バックアップ中」にする</li>
        <li>WALを<m-b>スイッチ</m-b>する</li>
        <li><m-b>チェックポイント</m-b>を発行し、そのLSNを保持する</li>
        <li>3.のLSNを元にWALファイル名を特定し、<m-b>backup_label</m-b>ファイルに書き出す</li>
        <li>LSNを返却する</li>
    </ol>
    <p>
        1.は、複数のベースアップ取得が行われないようにするための措置である。
        一方、pg_basebackupコマンド内では1.の処理がないため、pg_basebackupコマンドと並行して複数のベースバックアップが取得できる。(<m-b>非排他モード</m-b>)
        関数pg_start_badkupでは、第3引数<m-b>exclusive</m-b>でこれを制御できる。
        PostgreSQL14以降では、非排他モードの利用が推奨されている。<br>
        また、関数pg_start_badkupの第2引数で、<m-b>チェックポイント</m-b>の挙動を制御できる。
        trueを指定した場合、リソースやI/O処理をフル活用し、処理をできる限り早く行う。
        falseを指定した場合、リソースやI/O処理をフル活用せず、実行時間は増えるが処理の負荷を軽減する。
        やむを得ずサービス稼働中にバックアップを取得する必要があるときなどは、<m-b>false</m-b>で実行する。
    </p>

    <h3>関数pg_stop_backupの処理内容</h3>
    <ol>
        <li><m-b>共有メモリ</m-b>上のステータスを元に戻す</li>
        <li>ファイル<m-b>backup_label</m-b>を読み込み、LSNを取得する</li>
        <li>2.のLSNを含む<m-b>WALレコード</m-b>を書き出す</li>
        <li>WALを<m-b>スイッチ</m-b>する</li>
        <li><m-b>バックアップ履歴ファイル</m-b>を書き出す</li>
        <li>4.と5.のWALファイルがアーカイブされるのを待機する</li>
        <li>3.のWALレコードの書き出し位置(LSN)を返却する</li>
    </ol>

    <h3>WALアーカイブの流れ</h3>
    <p>
        <m-b>WALバッファ</m-b>が<m-b>16MB</m-b>でいっぱいになる、もしくはWALの<m-b>スイッチ</m-b>が発生すると、WALはアーカイブされる。
        このとき、ディレクトリ<m-b>pg_wal/archive_status</m-b>配下に、
        対象のWALファイルをアーカイブしてもよいことを示す<m-b>[WALファイル名].ready</m-b>というファイルが生成される。
        アーカイバプロセスは、次のタイミングでこのファイルの存在を確認し、ファイルが存在すれば
        パラメータ<m-b>archive_command</m-b>で定義したコマンドを実行する。
    </p>
    <ul>
        <li><m-b>60秒</m-b>間隔(パラメータ<m-b>archive_timeout</m-b>が指定されている場合)</li>
        <li><m-b>PostgreSQLの停止時</m-b></li>
    </ul>
    <p>
        アーカイブが完了したファイルは、<m-b>[WALファイル名].done</m-b>にリネームされる。
        オンライン物理バックアップからリカバリを行う際は、アーカイブファイルは必要不可欠となる。
        ビュー<m-b>pg_stat_archiver</m-b>を確認したり、ディレクトリ<m-b>arvhive_status</m-b>を直接確認するのもよい。
    </p>

    <h3>PITRの仕組み</h3>
    <h4>リカバリの流れ</h4>
    <ol>
        <li><m-b>pg_control</m-b>ファイルを読み込む</li>
        <li><m-b>postgresql.conf</m-b>を読み込む(PostgreSQL11以前は<m-b>recovery.conf</m-b>)</li>
        <li><m-b>backup_label</m-b>を読み込む</li>
        <li><m-b>pg_control</m-b>を更新し、<m-b>backup_label</m-b>を削除する</li>
        <li>必要な<m-b>WALレコード</m-b>を繰り返し適用する</li>
    </ol>
    <p>
        2.で読み込むパラメータは、<m-b>restore_command</m-b>、<m-b>recovery_target_time</m-b>などである。<br>
        3.でLSNを読み取れない場合、<m-b>pg_control</m-b>の情報を元にリカバリを開始する。<br>
        4.で、ファイルbackup_labelは<m-b>backup_label.old</m-b>にリネームされる。
    </p>
    <h4>pg_controlファイル</h4>
    <p>
        リカバリ時に参照されるpg_controlファイルは、ディレクトリ<m-b>grobal</m-b>配下に格納されている。
        バイナリファイルのため、コマンド<m-b>pg_controldata</m-b>を用いて内容を確認する。
        リカバリで用いられる<m-b>Latest checkpointing location</m-b>や<m-b>Minimum recovery ending location</m-b>、
        現在のデータベースクラスタの状況を示す<m-b>Database cluster status</m-b>など、PostgreSQLの運用に関する情報をプロパティとして持つ。
    </p>
    <h4>リカバリで設定する3つの項目</h4>
    <ol>
        <li><m-b>スタンバイサーバ</m-b>の設定</li>
        <li><m-b>アーカイブリカバリ</m-b>の設定</li>
        <li><m-b>リカバリ対象</m-b>の設定</li>
    </ol>
    <h4>アーカイブリカバリの設定</h4>
    <p>
        アーカイブリカバリの設定では、3つのパラメータを設定する。<br>
        1つ目は、再適用するWALファイルをアーカイブ領域からオンラインWAL領域にリストアするためのコマンドである<m-b>restore_command</m-b>である。
        このコマンドでは、次のエスケープ文字が使用できる。
    </p>
    <table>
        <thead>
            <tr>
                <th>
                    <nobr>エスケープ文字</nobr>
                </th>
                <th>意味</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>%p</m-b></td>
                <td>データベースクラスタから対象のWALファイルまでの相対パス</td>
            </tr>
            <tr>
                <td><m-b>%f</m-b></td>
                <td>対象のWALファイル名</td>
            </tr>
            <tr>
                <td><m-b>%r</m-b></td>
                <td>リカバリ中のリスタートポイントのWALレコードを含むWALファイル名</td>
            </tr>
        </tbody>
    </table>
    <p>
        2つ目は、リカバリ中のリスタートポイントのたびに実行するコマンドである<m-b>arvhive_cleanup_command</m-b>である。
        不要なアーカイブファイルを消去する目的で使用する。
        エスケープ文字<m-b>%r</m-b>を使用でき、コマンド<m-b>pg_archivecleanup</m-b>と併用して、アーカイブファイルを削除することができる。
    </p>
    <h4>リカバリ対象の設定</h4>
    <p>
        どの時点までリカバリするかを指定できる。
        次のパラメータを設定することができる。
    </p>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>recovery_target_action</m-b></td>
                <td>リカバリ完了後の動作を指定できる</td>
            </tr>
            <tr>
                <td><m-b>recovery_target_timeline</m-b></td>
                <td>任意のタイムライン上の特定の状態を指定する</td>
            </tr>
            <tr>
                <td><m-b>recovery_target</m-b></td>
                <td><m-b>immediate</m-b>というキーワードを指定すると、整合性が取れたタイミングでリカバリを停止する</td>
            </tr>
            <tr>
                <td><m-b>recovery_target_lsn</m-b></td>
                <td>指定したLSNでリカバリを停止する</td>
            </tr>
            <tr>
                <td><m-b>recovery_target_time</m-b></td>
                <td>指定した時間でリカバリを停止する</td>
            </tr>
            <tr>
                <td><m-b>recovery_target_xid</m-b></td>
                <td>指定したトランザクションIDでリカバリを停止する</td>
            </tr>
            <tr>
                <td><m-b>recovery_target_inclusive</m-b></td>
                <td>
                    true(デフォルト値):
                    <m-b>recovery_target_lsn</m-b>、<m-b>recovery_target_time</m-b>、<m-b>recovery_target_xid</m-b>
                    に指定した値を含んだ場合にリカバリを停止する。<br>
                    false: <m-b>recovery_target_lsn</m-b>、<m-b>recovery_target_time</m-b>、<m-b>recovery_target_xid</m-b>
                    に指定した値を含まない場合にリカバリを停止する。
                </td>
            </tr>
            <tr>
                <td><m-b>recovery_target_name</m-b></td>
                <td>
                    リカバリを停止したいターゲット名(任意の文字列)を指定する<br>
                    任意の文字列は、関数<m-b>pg_create_restore_point</m-b>で事前に設定できる。
                    この関数は、WALレコードとして任意の文字列を埋め込む処理を行う。
                    このため、コマンド<m-b>pg_waldump</m-b>で埋め込んだ文字列を確認できる。
                </td>
            </tr>
        </tbody>
    </table>

    <h3>バックアップ/リカバリの運用手順</h3>
    <h4>最新の状態へリカバリする場合に必要なもの</h4>
    <ul>
        <li><m-b>ベースバックアップ</m-b></li>
        <li><m-b>アーカイブWAL</m-b></li>
        <li><m-b>停止直前までのWAL</m-b></li>
    </ul>
    <h4>バックアップ手順</h4>
    <ol>
        <li>
            <b>postgresql.confの修正</b>
            <pre><code>
<m-b>archive_mode</m-b> = on
<m-b>archive_command</m-b> = 'cp <m-b>%p</m-b> アーカイブ領域パス/<m-b>%f</m-b>'
            </code></pre>
        </li>
        <li>
            <b>ベースバックアップの取得</b>
            <p>
                関数<m-b>pg_start_backup</m-b>、<m-b>pg_stop_backup</m-b>を実行する。
                関数pg_stop_backupの処理が完了すると、カラム<m-b>lsn</m-b>、<m-b>labelfile</m-b>、<m-b>spcmapfile</m-b>の値が出力される。
                このうち、カラム<m-b>labelfile</m-b>の値はファイル<m-b>backup_label</m-b>に保存される。
                また、カラム<m-b>spcmapfile</m-b>に値があれば、ファイル<m-b>tablespace_map</m-b>に保存される。
            </p>
        </li>
    </ol>
    <h4>リカバリ手順</h4>
    <ol>
        <li>
            <b>WALファイルの退避</b>
            <pre><code>
cp -r <m-b>${PGDATA}/pg_wal</m-b> 退避先パス
            </code></pre>
        </li>
        <li>
            <b>ベースバックアップのリストア</b>
            <pre><code>
rsync -av ベースバックアップパス/* <m-b>${PGDATA}</m-b>
            </code></pre>
        </li>
        <li>
            <b>退避したWALファイルをリストア</b>
            <pre><code>
cp 退避先パス/* <m-b>${PGDATA}/pg_wal/</m-b>
            </code></pre>
        </li>
        <li>
            <b>postgresql.confの修正</b>
            <pre><code>
<m-b>restore_command</m-b> = 'cp アーカイブ領域パス/<m-b>%f</m-b> %p'
            </code></pre>
        </li>
        <li>
            <b>ファイル<m-b>recovery.signal</m-b>を作成する</b>
            <pre><code>
touch <m-b>${PGDATA}/recovery.signal</m-b>
            </code></pre>
        </li>
        <li>
            <b>リカバリを実行する</b>
            <pre><code>
<m-b>pg_ctl start</m-b>
            </code></pre>
        </li>
    </ol>

    <h2>14章 死活監視と正常動作の監視</h2>

    <h3>サーバの死活監視</h3>
    <p>
        一般的に<m-b>ping</m-b>コマンドを使用する。
        このコマンドは、正常に通信できる場合に<m-b>0</m-b>を、通信に異常がある場合に<m-b>1</m-b>を戻す。
        なお、サーバは起動していてもネットワークインターフェイスの障害等でコマンドは失敗する場合があるため、注意が必要。
    </p>

    <h3>PostgreSQLの死活監視</h3>
    <h4>主なPostgreSQLの死活監視の方法</h4>
    <ul>
        <li>OSのコマンド<m-b>ps</m-b>を用いる</li>
        <li>PostgreSQLが提供するコマンド<m-b>pg_isready</m-b>を用いる</li>
    </ul>
    <h4>コマンドpsを用いる方法</h4>
    <pre><code>
ps <m-b>faxww</m-b> | <m-b>grep postgres</m-b>
    </code></pre>
    <h4>コマンドpg_isreadyを用いる方法</h4>
    <h5>コマンドの戻り値</h5>
    <table>
        <thead>
            <tr>
                <th>戻り値</th>
                <th>状態</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>0</m-b></td>
                <td>正常に動作している</td>
            </tr>
            <tr>
                <td><m-b>1</m-b></td>
                <td>アクセスできない(権限なし、起動中など)</td>
            </tr>
            <tr>
                <td><m-b>2</m-b></td>
                <td>起動していない</td>
            </tr>
            <tr>
                <td><m-b>3</m-b></td>
                <td>コマンドのエラー</td>
            </tr>
        </tbody>
    </table>
    <h5>リモートでコマンドを実行する場合</h5>
    <pre><code>
pg_isready <m-b>-h ホスト名 -p 5432 -d データベース名</m-b>
    </code></pre>

    <h3>サーバの正常動作の監視</h3>
    <h4>主に使用するコマンド</h4>
    <table>
        <thead>
            <tr>
                <th>コマンド</th>
                <th>概要</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>vmstat</m-b></td>
                <td>サーバ全体の仮想メモリやCPU、ディスクI/Oの統計情報を確認</td>
            </tr>
            <tr>
                <td><m-b>sar</m-b></td>
                <td>CPU、メモリ、ネットワーク、ディスクI/Oの負荷状況を確認</td>
            </tr>
            <tr>
                <td><m-b>netstat</m-b></td>
                <td>通信中のTCP/IP通信の利用状況を確認</td>
            </tr>
            <tr>
                <td><m-b>iostat</m-b></td>
                <td>CPU利用率とI/Oデバイスの使用状況を確認</td>
            </tr>
        </tbody>
    </table>

    <h3>PostgreSQLの正常動作の監視 - 負荷情報の統計に関するパラメータ</h3>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>
                    <nobr>デフォルト値</nobr>
                </th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>track_activities</m-b></td>
                <td><m-b>on</m-b></td>
                <td>各セッションで実行中のコマンドに関する情報と、そのコマンドの実行開始時刻の収集を有効にする</td>
            </tr>
            <tr>
                <td><m-b>track_counts</m-b></td>
                <td><m-b>on</m-b></td>
                <td>データベースの活動についての統計情報の収集を有効にする</td>
            </tr>
        </tbody>
    </table>

    <h3>PostgreSQLの正常動作の監視 - 負荷状況の統計に関するビュー</h3>
    <table>
        <thead>
            <tr>
                <th>ビュー</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>pg_stat_database</m-b></td>
                <td>
                    データベースごとの統計情報を扱うビュー<br>
                    <m-b>コミット</m-b>/<m-b>ロールバック</m-b>の回数、<m-b>キャッシュヒット率</m-b>、<m-b>デッドロック発生回数</m-b>などを確認できる。
                </td>
            </tr>
            <tr>
                <td><m-b>pg_stat_user_tables</m-b></td>
                <td>
                    各テーブルに対するアクセスの統計情報を扱うビュー
                </td>
            </tr>
            <tr>
                <td><m-b>pg_statio_user_tables</m-b></td>
                <td>
                    各テーブルに対するI/Oの統計情報を扱うビュー
                </td>
            </tr>
            <tr>
                <td><m-b>pg_statio_user_indexes</m-b></td>
                <td>
                    各インデックスに対するI/Oの統計情報を扱うビュー
                </td>
            </tr>
            <tr>
                <td><m-b>pg_stat_activity</m-b></td>
                <td>
                    バックエンドプロセスに関する統計情報を扱うビュー
                </td>
            </tr>
            <tr>
                <td><m-b>pg_locks</m-b></td>
                <td>
                    ロック待ちを起こしているプロセスなどの情報を扱うビュー
                </td>
            </tr>
        </tbody>
    </table>

    <h3>pg_stat_databaseで扱う代表的な情報</h3>
    <table>
        <thead>
            <tr>
                <th>カラム</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>xact_commit</m-b></td>
                <td>コミット回数</td>
            </tr>
            <tr>
                <td><m-b>xact_rollback</m-b></td>
                <td>ロールバック回数</td>
            </tr>
            <tr>
                <td><m-b>blks_read</m-b></td>
                <td>共有バッファ以外からデータ読み込みを行った回数</td>
            </tr>
            <tr>
                <td><m-b>blks_hit</m-b></td>
                <td>共有バッファからデータ読み込みを行った回数</td>
            </tr>
        </tbody>
    </table>

    <h3>pg_stat_user_tablesで扱う代表的な情報</h3>
    <table>
        <thead>
            <tr>
                <th>カラム</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>seq_scan</m-b></td>
                <td>シーケンシャルスキャンの実施回数</td>
            </tr>
            <tr>
                <td><m-b>last_seq_scan</m-b></td>
                <td>最後にシーケンシャルスキャンが発生したタイムスタンプ</td>
            </tr>
            <tr>
                <td><m-b>idx_scan</m-b></td>
                <td>インデックススキャンの実施回数</td>
            </tr>
            <tr>
                <td><m-b>last_idx_scan</m-b></td>
                <td>最後にインデックススキャンが発生したタイムスタンプ</td>
            </tr>
            <tr>
                <td><m-b>seq_tup_read</m-b></td>
                <td>読み取りが行われた行数</td>
            </tr>
            <tr>
                <td><m-b>n_tup_ins</m-b></td>
                <td>挿入回数</td>
            </tr>
            <tr>
                <td><m-b>n_tup_upd</m-b></td>
                <td>更新回数</td>
            </tr>
            <tr>
                <td><m-b>n_tup_del</m-b></td>
                <td>削除回数</td>
            </tr>
            <tr>
                <td><m-b>n_tup_hot_upd</m-b></td>
                <td>HOTによる更新回数</td>
            </tr>
            <tr>
                <td><m-b>n_live_tup</m-b></td>
                <td>有効な行数</td>
            </tr>
            <tr>
                <td><m-b>n_dead_tup</m-b></td>
                <td>不要な行数</td>
            </tr>
            <tr>
                <td><m-b>last_autovacuum</m-b></td>
                <td>最後に自動バキュームが実行されたタイムスタンプ</td>
            </tr>
            <tr>
                <td><m-b>last_autoanalyze</m-b></td>
                <td>最後に自動アナライズが実行されたタイムスタンプ</td>
            </tr>
        </tbody>
    </table>

    <h3>pg_stat_activityで扱う代表的な情報</h3>
    <table>
        <thead>
            <tr>
                <th>カラム</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>datname</m-b></td>
                <td>接続しているデータベース名</td>
            </tr>
            <tr>
                <td><m-b>backend_start</m-b></td>
                <td>プロセスが起動したタイムスタンプ</td>
            </tr>
            <tr>
                <td><m-b>xact_start</m-b></td>
                <td>トランザクションが開始したタイムスタンプ</td>
            </tr>
            <tr>
                <td><m-b>query_start</m-b></td>
                <td>クエリを発行したタイムスタンプ</td>
            </tr>
            <tr>
                <td><m-b>wati_event_type</m-b></td>
                <td>処理待ちの状態</td>
            </tr>
            <tr>
                <td><m-b>wait_event</m-b></td>
                <td>処理待ちが発生した待機イベント</td>
            </tr>
            <tr>
                <td><m-b>state</m-b></td>
                <td>プロセスの状態</td>
            </tr>
            <tr>
                <td><m-b>query_id</m-b></td>
                <td>最後に実行したクエリの識別子</td>
            </tr>
            <tr>
                <td><m-b>query</m-b></td>
                <td>最後に実行したクエリのSQL文</td>
            </tr>
            <tr>
                <td><m-b>backend_type</m-b></td>
                <td>
                    プロセスの種別<br>
                    対象のプロセスがバックエンドプロセスの場合<m-b>client backend</m-b>、
                    上記以外の場合<m-b>プロセス名</m-b>が表示される。
                </td>
            </tr>
        </tbody>
    </table>

    <h3>pg_stat_activityのカラムstatが取る値</h3>
    <table>
        <thead>
            <tr>
                <th>キーワード</th>
                <th>状態</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>active</m-b></td>
                <td>問い合わせ実行中</td>
            </tr>
            <tr>
                <td><m-b>idle</m-b></td>
                <td>トランザクション外でコマンド待ち</td>
            </tr>
            <tr>
                <td><m-b>idle in transaction</m-b></td>
                <td>トランザクション内でコマンド待ち</td>
            </tr>
            <tr>
                <td><m-b>idle in transaction (aborted)</m-b></td>
                <td>トランザクション内でエラー発生後、コマンド待ち</td>
            </tr>
            <tr>
                <td><m-b>fastpath function call</m-b></td>
                <td>関数呼び出し中(古い仕様のためあまり見ない)</td>
            </tr>
            <tr>
                <td><m-b>disabled</m-b></td>
                <td>無効(<m-b>track_activities</m-b>がoffで設定されている)</td>
            </tr>
        </tbody>
    </table>

    <h3>pg_locksが扱う情報</h3>
    <table>
        <thead>
            <tr>
                <th>キーワード</th>
                <th>状態</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>mode</m-b></td>
                <td>ロックモードの名称</td>
            </tr>
            <tr>
                <td><m-b>granted</m-b></td>
                <td>ロックを保持している場合true、ロック待ちの場合false</td>
            </tr>
            <tr>
                <td><m-b>waitstart</m-b></td>
                <td>ロック待ちになった際のタイムスタンプ</td>
            </tr>
        </tbody>
    </table>

    <h2>15章 テーブルメンテナンス</h2>

    <h3>VACUUMによるメンテナンス</h3>
    <h4>バキュームの主な役割</h4>
    <ul>
        <li><m-b>不要領域の再利用</m-b></li>
        <li><m-b>トランザクションIDの周回問題の回避</m-b></li>
    </ul>
    <h4>VACUUMの処理手順</h4>
    <ol>
        <li>各テーブルの<m-b>ページ</m-b>を先頭から走査する</li>
        <li><m-b>VM</m-b>(<m-b>Visibility Map</m-b>)を確認して不要行を含むなら3.の処理に、なければ次のページを走査する</li>
        <li>対象ページの全行を走査して不要行の情報を抽出する</li>
        <li>全ページを走査後、不要行が抽出されていれば対象テーブルの<m-b>インデックス</m-b>をメンテナンスし、不要行を削除する</li>
        <li>削除した行の情報をもとに<m-b>FSM</m-b>(<m-b>Free Space Map</m-b>)を更新する</li>
    </ol>
    <h4>VACUUMコマンドのオプション</h4>
    <table>
        <thead>
            <tr>
                <th>オプション</th>
                <th>効果</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>DISABLE_PAGE_SKIPPING</m-b></td>
                <td>
                    VMのチェックを無効化する<br>
                    VMが不整合な状態になっている可能性がある場合に指定する。
                </td>
            </tr>
            <tr>
                <td><m-b>SKIP_LOCKED</m-b></td>
                <td>
                    テーブルが他のトランザクションからロックされている場合に、スキップする
                </td>
            </tr>
            <tr>
                <td><m-b>INDEX_CLEANUP</m-b></td>
                <td>
                    不要行が少ない場合、インデックスのVACUUMはスキップされる仕様だが、1行でも不要行があれば削除を強制する
                </td>
            </tr>
            <tr>
                <td><m-b>PARALLEL</m-b></td>
                <td>
                    インデックスのVACUUMを最大N並列で実行する<br>
                    1つのテーブルに複数のインデックスが付与されている場合に効果がある。
                </td>
            </tr>
        </tbody>
    </table>

    <h3>Visibility Mapについて</h3>
    <p>
        VM(Visibility Map)は、テーブルの可視性の判断および<m-b>FREEZE処理</m-b>の判断に使用される補助データである。
        テーブルの1ページの状態を<m-b>2ビット</m-b>で管理する。
        ページ内のデータが完全に可視の場合<m-b>下位1ビットが1</m-b>、一部でも不可視の場合<m-b>下位1ビットが0</m-b>となる。
        VACUUM処理では、VMの情報をもとに処理するページを絞ることで負荷の軽減を図っている。<br>
        また、ページ内のデータが完全にFREEZE処理済みの場合<m-b>上位1ビットが1</m-b>、一部でも未処理の場合<m-b>上位1ビットが0</m-b>となる。
        これにより、FREEZE処理の負荷の軽減を図っている。
        滅多に更新されない巨大なテーブルに対しては、大きな効果がある。
    </p>

    <h3>Free Space Mapについて</h3>
    <p>
        FSM(Free Space Map)は、テーブルの<m-b>空き領域</m-b>の大きさを管理する補助データである。
        1ページの空き領域量を<m-b>1バイト</m-b>で管理する。
        これにより、空き領域の大きさを<m-b>256段階</m-b>に分けて管理している。
        各ページの空き容量を調べる場合、contribモジュールの関数<m-b>pg_freespacemap</m-b>が使用できる。
    </p>

    <h3>トランザクションID周回問題の回避</h3>
    <p>
        PostgreSQLで実行される更新トランザクションには、トランザクションID(XID)が付与される。
        また、テーブルにデータを格納する際に実行されたトランザクションを区別できるように、XIDが<m-b>行ヘッダ</m-b>に<m-b>xmin</m-b>として格納される。
        トランザクションは、自身のXIDと行が持つXIDを比較して、可視/不可視の判定を行う。<br>
        しかし、XIDは<m-b>32ビット</m-b>(=約<m-b>40億</m-b>)で管理されていて、周回する。
        XIDが周回したとき、周回して小さな値のXIDを持つトランザクションは、大きな値のXIDを持つ行を参照できない現象が起こる。
        これを<m-b>XID周回問題</m-b>という。<br>
        回避策は、VACUUM中の全行を走査する処理において、各行の<m-b>age</m-b>(XIDの差分)を求め、必要に応じて<m-b>FREEZE処理</m-b>を行うことである。
        これは、<m-b>xmin</m-b>を特殊なXIDである<m-b>2</m-b>に上書きし、すべてのトランザクションから可視とする処理である。
        この処理もI/O負荷が高いため、VMを利用して負荷を軽減する仕組みがある。<br>
        FREEZE処理を行う場合、次のような方法がある。
    </p>
    <ul>
        <li>VACUUM実行時にオプション<m-b>FREEZE</m-b>を付与する</li>
        <li>
            VACUUM関連のパラメータ<m-b>autovacuum_freeze_min_age</m-b>、<m-b>autovacuum_freeze_max_age</m-b>、<m-b>autovacuum_freeze_table_age</m-b>で制御する
        </li>
    </ul>
    <p>
        なお、現在のXIDより<m-b>5000万</m-b>以上古いXIDは、<m-b>VACUUM</m-b>時に回収されるため、基本的には意識しなくてもよい。
        ただ、更新をほとんど行わないテーブルであれば、登録後にVACUUM FREEZEを行うことで運用中に発生するFREEZE処理の負荷を回避できる。<br>
        通常のVACUUMはトランザクション処理の妨げとならないよう間欠的に実行されるが、XIDが上限に近づくとFREEZE処理を優先する。
        上限にどの程度近づくと動作が切り替わるのかは、次のパラメータで制御する。
    </p>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>デフォルト値</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>vacuum_failsafe_age</m-b></td>
                <td><m-b>16億</m-b></td>
                <td>FREEZE処理を優先するrelfrozenxidの閾値</td>
            </tr>
            <tr>
                <td><m-b>vacuum_multixact_failsafe_age</m-b></td>
                <td><m-b>1億5000万</m-b></td>
                <td>VACUUMがテーブルの積極的なスキャンを行うrelminmxidの閾値</td>
            </tr>
        </tbody>
    </table>
    <p>
        周回問題に到達するまでに利用可能な残りのXIDが一定の数を下回ると、<m-b>警告メッセージ</m-b>を出力する。
        この閾値は、PostgreSQL13までは<m-b>1100万</m-b>、PostgreSQL14では<m-b>4000万</m-b>である。
    </p>
    <h4>現在のトランザクションのXIDを確認するSQL</h4>
    <pre><code>
SELECT <m-b>txid_current()</m-b>;
    </code></pre>
    <h4>各テーブルに含まれる最も古いXIDから現在のXIDの差分を取得するSQL</h4>
    <pre><code>
SELECT relname, <m-b>age(relfrozenxid)</m-b> FROM pg_class WHERE relkind = 'r';
    </code></pre>

    <h3>自動バキュームによるメンテナンス</h3>
    <h4>自動バキュームの設定に関する主なパラメータ</h4>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>
                    <nobr>デフォルト値</nobr>
                </th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>autovacuum</m-b></td>
                <td><m-b>on</m-b></td>
                <td>自動バキュームを実行するか</td>
            </tr>
            <tr>
                <td><m-b>log_autovacuum_min_duration</m-b></td>
                <td><m-b>-1</m-b></td>
                <td>
                    自動バキュームが指定した時間を超過した場合にログを出力<br>
                    単位:ミリ秒、無効:-1、すべて:0
                </td>
            </tr>
            <tr>
                <td><m-b>autovacuum_max_workers</m-b></td>
                <td><m-b>3</m-b></td>
                <td>同時に実行する自動バキューム処理のワーカ数</td>
            </tr>
            <tr>
                <td><m-b>autovacuum_naptime</m-b></td>
                <td><m-b>1min</m-b></td>
                <td>自動バキュームが必要なテーブルのチェックを行う間隔</td>
            </tr>
            <tr>
                <td><m-b>autovacuum_vacuum_threshold</m-b></td>
                <td><m-b>50</m-b></td>
                <td>
                    自動バキュームの起動に関する閾値<br>
                    指定行数以上の更新・削除が発生した場合に起動する。
                </td>
            </tr>
            <tr>
                <td><m-b>autovacuum_vacuum_insert_threshold</m-b></td>
                <td><m-b>1000</m-b></td>
                <td>
                    INSERT時の自動バキュームの起動に関する閾値<br>
                    指定行数以上の挿入が発生した場合に起動する。
                </td>
            </tr>
            <tr>
                <td><m-b>autovacuum_vacuum_scale_factor</m-b></td>
                <td><m-b>0.2</m-b></td>
                <td>
                    自動バキュームの起動に関する割合<br>
                    デフォルトの場合、テーブルの20%が更新・削除された場合に起動する。
                </td>
            </tr>
            <tr>
                <td><m-b>autovacuum_vacuum_insert_scale_factor</m-b></td>
                <td><m-b>0.2</m-b></td>
                <td>
                    INSERT時の自動バキュームの起動に関する割合<br>
                    デフォルトの場合、テーブルの20%が挿入された場合に起動する。
                </td>
            </tr>
            <tr>
                <td><m-b>autovacuum_vacuum_cost_delay</m-b></td>
                <td><m-b>2</m-b></td>
                <td>
                    自動バキュームの実行間隔<br>
                    ms単位、-1指定時は<m-b>vacuum_cost_delay</m-b>の設定に従う。PostgreSQL11以前のデフォルト値は<m-b>20</m-b>。
                </td>
            </tr>
            <tr>
                <td><m-b>autovacuum_vacuum_cost_limit</m-b></td>
                <td><m-b>-1</m-b></td>
                <td>
                    自動バキュームの1回あたりのコスト上限<br>
                    自動バキュームワーカが並列に実行されている場合、各ワーカに均等にコストを振り分ける。
                    -1指定時は、<m-b>vacuum_cost_limit</m-b>の設定に従う。
                </td>
            </tr>
            <tr>
                <td><m-b>autovacuum_work_mem</m-b></td>
                <td><m-b>-1</m-b></td>
                <td>
                    自動バキュームワーカごとの最大メモリ数<br>
                    -1指定時は、<m-b>maintenance_work_mem</m-b>の設定に従う。
                </td>
            </tr>
        </tbody>
    </table>
    <h4>自動バキュームが開始する条件</h4>
    <ul>
        <li>
            autovacuum_naptimeで指定した時間ごとに、更新/削除された件数が
            <m-b>autovacuum_vacuum_threshold + autovacuum_vacuum_scale_factor * テーブルの行数</m-b>
            を超過した場合
        </li>
        <li>
            autovacuum_naptimeで指定した時間ごとに、挿入された件数が<m-b>autovacuum_vacuum_insert_threshold +
                autovacuum_vacuum_insert_scale_factor * テーブルの行数</m-b>
            を超過した場合
        </li>
    </ul>
    <h4>テーブルごとに自動バキュームを停止するSQL</h4>
    <pre><code>
<m-b>ALTER TABLE 対象テーブル SET (autovacuum_enabled = off)</m-b>;
    </code></pre>

    <h3>自動バキュームの進捗状況確認</h3>
    <h4>pg_stat_progress_vacuumビューの情報</h4>
    <table>
        <thead>
            <tr>
                <th>カラム</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>pid</m-b></td>
                <td>自動バキュームワーカのプロセスID</td>
            </tr>
            <tr>
                <td><m-b>datname</m-b></td>
                <td>接続するデータベース名</td>
            </tr>
            <tr>
                <td><m-b>relid</m-b></td>
                <td>バキューム対象のテーブルのOID</td>
            </tr>
            <tr>
                <td><m-b>phase</m-b></td>
                <td>バキューム処理のフェーズ</td>
            </tr>
            <tr>
                <td><m-b>heap_blks_scanned</m-b></td>
                <td>スキャンされたヒープブロック数</td>
            </tr>
            <tr>
                <td><m-b>heap_blks_vacuumed</m-b></td>
                <td>バキューム処理されたヒープブロック数</td>
            </tr>
            <tr>
                <td><m-b>index_vacuum_count</m-b></td>
                <td>完了したインデックスバキュームサイクル数</td>
            </tr>
        </tbody>
    </table>
    <h4>自動バキュームの進捗状況のフェーズ</h4>
    <table>
        <thead>
            <tr>
                <th>フェーズ</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>initializing</m-b></td>
                <td>自動バキュームの初期化中</td>
            </tr>
            <tr>
                <td><m-b>scanning heap</m-b></td>
                <td>自動バキュームがテーブルのヒープデータをスキャン中</td>
            </tr>
            <tr>
                <td><m-b>vacuuming indexes</m-b></td>
                <td>テーブルに付与されたインデックスのバキューム中</td>
            </tr>
            <tr>
                <td><m-b>vacuuming heap</m-b></td>
                <td>ヒープデータのバキューム中</td>
            </tr>
            <tr>
                <td><m-b>cleaning up indexes</m-b></td>
                <td>インデックスの整理中</td>
            </tr>
            <tr>
                <td><m-b>truncating heap</m-b></td>
                <td>データのないヒープページの切り詰め中</td>
            </tr>
            <tr>
                <td><m-b>performing final cleanup</m-b></td>
                <td>FSMのバキュームとテーブル統計情報の更新中</td>
            </tr>
        </tbody>
    </table>

    <h3>VACUUM FULLによるメンテナンス</h3>
    <h4>VACUUMが機能しないケース</h4>
    <p>
        <m-b>LongTransaction</m-b>が存在している場合はVACUUMが機能しない。
        これは、トランザクションを開始後、コミットもロールバックもせずに長時間存在しているトランザクションである。
        VACUUMによる再利用やFREEZE処理は、現在流れている最も若いXIDよりも<m-b>前のXIDを持つ</m-b>行が対象となる。
        そのため、LongTransactionの開始後に更新/削除された行はバキューム処理がされない。
    </p>
    <h4>LongTransactionの確認/終了方法</h4>
    <p>
        LongTransactionを確認する場合、ビュー<m-b>pg_stat_activity</m-b>を確認する。
        カラム<m-b>state</m-b>の値が<m-b>idele in transaction</m-b>となっている行のうち、カラム<m-b>xact_start</m-b>の値が大幅に古いプロセスは、
        LongTransactionの疑いがある。
        この場合、カラム<m-b>pid</m-b>からプロセスを特定し、関数<m-b>pg_cancel_backend()</m-b>や<m-b>pg_terminate_backend()</m-b>などでプロセスを終了する。
    </p>
    <h4>VACUUM FULL実行時の注意点</h4>
    <p>
        VACUUMとは異なり、VACUUM FULL実行時はテーブルに対し<m-b>ACCESS EXCLUSIVE</m-b>モードのロックを取得するため、テーブルに対する<m-b>参照/更新</m-b>が待たされる。<br>
        VACUUM FULLは次の順で処理が行われる。
    </p>
    <ol>
        <li>テーブルのデータを<m-b>1行</m-b>ずつ取得し、<m-b>別の新しいテーブル</m-b>に格納する</li>
        <li>新しいテーブルに<m-b>インデックス</m-b>を作成する</li>
        <li>テーブルを<m-b>入れ替える</m-b></li>
    </ol>
    <p>
        このため、有効な行のみを新しいテーブルに格納し、不要領域は一切存在しなくなる。
        ただし、一時的に対象テーブルと新しいテーブルが同時に作成されるため、容量不足で完遂できなことがある。<br>
        テーブルメンテナンスは、自動バキュームや定期的なバキュームを行っていれば問題になることはないことを心がける。
    </p>
    <h4>VACUUM FULLの進捗状況確認</h4>
    <p>
        PostgreSQL12からVACUUM FULLの進捗状況も確認できるようになった。
        ビュー<m-b>pg_stat_progress_cluster</m-b>で確認できる。
        これは、<m-b>CLUSTER</m-b>コマンドの進捗状況も確認できる。
    </p>

    <h3>pg_stat_progress_clusterビューの情報</h3>
    <table>
        <thead>
            <tr>
                <th>カラム</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>pid</m-b></td>
                <td>バックエンドのプロセスID</td>
            </tr>
            <tr>
                <td><m-b>datname</m-b></td>
                <td>接続するデータベース名</td>
            </tr>
            <tr>
                <td><m-b>relid</m-b></td>
                <td>クラスタ対象のテーブルのOID</td>
            </tr>
            <tr>
                <td><m-b>phase</m-b></td>
                <td>クラスタ処理のフェーズ</td>
            </tr>
            <tr>
                <td><m-b>heap_tuples_scanned</m-b></td>
                <td>スキャンされたヒープタプル数</td>
            </tr>
            <tr>
                <td><m-b>heap_tuples_written</m-b></td>
                <td>書き込みが行われたヒープタプル数</td>
            </tr>
            <tr>
                <td><m-b>heap_blks_total</m-b></td>
                <td>テーブル内のヒープブロックの総数</td>
            </tr>
            <tr>
                <td><m-b>heap_blks_scanned</m-b></td>
                <td>スキャンされたヒープブロック数</td>
            </tr>
        </tbody>
    </table>

    <h3>VACUUM FULLの進捗状況のフェーズ</h3>
    <table>
        <thead>
            <tr>
                <th>フェーズ</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>initializing</m-b></td>
                <td>VACUUM FULL/CLUSTERの初期化中</td>
            </tr>
            <tr>
                <td><m-b>seq scanning heap</m-b></td>
                <td>シーケンシャルスキャンを用いてテーブルのヒープデータをスキャン中</td>
            </tr>
            <tr>
                <td><m-b>index scanning heap</m-b></td>
                <td>インデックススキャンを用いてテーブルのヒープデータをスキャン中</td>
            </tr>
            <tr>
                <td><m-b>sorting tuples</m-b></td>
                <td>インデックスに基づいてタプルデータをソート中</td>
            </tr>
            <tr>
                <td><m-b>writing new heap</m-b></td>
                <td>ソートしたタプルを新しいヒープデータとして書き込み中</td>
            </tr>
            <tr>
                <td><m-b>swapping relation files</m-b></td>
                <td>新しいヒープデータをテーブルに関連付け中</td>
            </tr>
            <tr>
                <td><m-b>rebuilding index</m-b></td>
                <td>インデックスの再構築中</td>
            </tr>
            <tr>
                <td><m-b>performing final cleanup</m-b></td>
                <td>古いヒープデータなどのクリーンアップ中</td>
            </tr>
        </tbody>
    </table>

    <h3>テーブル統計情報の更新</h3>
    <p>
        <m-b>プランナ</m-b>がより良い実行計画を作成するには、テーブルの更新に合わせて<m-b>統計情報</m-b>も更新する必要がある。
    </p>
    <h4>テーブル統計情報に関する主な設定</h4>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>デフォルト値</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>default_statistics_target</m-b></td>
                <td><m-b>100</m-b></td>
                <td>テーブル統計情報を保持するエントリ数</td>
            </tr>
            <tr>
                <td><m-b>autovacuum_analyze_threshold</m-b></td>
                <td><m-b>50</m-b></td>
                <td>テーブル統計情報実行の閾値</td>
            </tr>
            <tr>
                <td><m-b>autovacuum_analyze_scale_factor</m-b></td>
                <td><m-b>0.1</m-b></td>
                <td>テーブル統計情報実行に関する割合</td>
            </tr>
        </tbody>
    </table>
    <h4>pg_stat_progress_analyzeビューの情報</h4>
    <table>
        <thead>
            <tr>
                <th>カラム</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>pid</m-b></td>
                <td>バックエンドのプロセスID</td>
            </tr>
            <tr>
                <td><m-b>datname</m-b></td>
                <td>接続するデータベース名</td>
            </tr>
            <tr>
                <td><m-b>relid</m-b></td>
                <td>クラスタ対象のテーブルのOID</td>
            </tr>
            <tr>
                <td><m-b>phase</m-b></td>
                <td>クラスタ処理のフェーズ</td>
            </tr>
            <tr>
                <td><m-b>sample_blks_total</m-b></td>
                <td>サンプルされるヒープブロックの総数</td>
            </tr>
            <tr>
                <td><m-b>sample_blks_scanned</m-b></td>
                <td>スキャンされたヒープブロック数</td>
            </tr>
        </tbody>
    </table>
    <h4>統計情報の粒度</h4>
    <p>
        統計情報の粒度は、システムのデフォルト値としてはパラメータ<m-b>default_statistics_target</m-b>で設定される。
        この数値を増加すると、データ分布の複雑なテーブルでも精度の高い統計情報が取得可能となるが、統計情報の生成と保存コストが増加する。
        テーブルごとの特定のカラムに統計情報を設定したい場合、次のコマンドを使用する。
    </p>
    <pre><code>
<m-b>ALTER TABLE テーブル名 ALTER COLUMN カラム名 SET STATISTICS 粒度の値</m-b>;
    </code></pre>

    <h2>16章 インデックスメンテナンス</h2>

    <h3>インデックスメンテナンスが必要な状況</h3>
    <h4>インデックスへのアクセス性能が低下する主な原因</h4>
    <ul>
        <li>インデックスファイルの<m-b>肥大化</m-b></li>
        <li>インデックスファイルの<m-b>断片化</m-b></li>
        <li>インデックスファイルの<m-b>クラスタ性の欠落</m-b></li>
    </ul>
    <h4>インデックスファイルの肥大化</h4>
    <p>
        インデックスの肥大化は、システムカタログ<m-b>pg_class</m-b>のカラム<m-b>relpages</m-b>(ページ数)と<m-b>reltuples</m-b>(行数)の関係から確認することができる。
    </p>
    <h4>インデックスファイルの断片化</h4>
    <p>
        インデックスの断片化は、contribモジュールの<m-b>pgstattuple</m-b>に含まれる関数<m-b>psstatindex</m-b>で確認することができる。
        インデックス名を引数に渡し、結果のカラム<m-b>leaf_fragmentation</m-b>にリーフページの断片化の状況が出力される。
    </p>
    <h4>クラスタ性の欠落</h4>
    <p>
        クラスタ性とは、テーブルデータの物理的な<m-b>配置順序</m-b>のことを指す。
        テーブルデータの並びは、インデックスの並びに近いとより効果的に検索ができる。
        クラスタ性の欠落とは、運用している間にテーブルデータの物理的な配置順序が、頻繁に利用されるインデックスの並びと乖離する状況を指す。
        この場合、インデックススキャン時に参照する<m-b>ページ数</m-b>が増加し、I/O性能が低下する。<br>
        これを確認する場合、ビュー<m-b>pg_stats</m-b>のカラム<m-b>correlation</m-b>を参照する。
        このカラムは<m-b>-1</m-b>から<m-b>1</m-b>の値を取り、<m-b>ANALYZE</m-b>実行時にサンプリングされる。
        次表に示す状態を表す。
    </p>
    <table>
        <thead>
            <tr>
                <th>値</th>
                <th>状態</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>-1</td>
                <td><m-b>降順に揃っている</m-b></td>
            </tr>
            <tr>
                <td>0</td>
                <td><m-b>ランダム</m-b></td>
            </tr>
            <tr>
                <td>1</td>
                <td><m-b>昇順に揃っている</m-b></td>
            </tr>
        </tbody>
    </table>

    <h3>インデックスファイルの肥大化の予防</h3>
    <p>
        インデックスファイルをなるべく肥大化させないためには、<m-b>バキューム</m-b>処理を実行する。
        この処理にはインデックスメンテナンスの処理が含まれているため、<m-b>自動バキューム</m-b>を行う設定にしていれば、運用上問題になることはない。
    </p>

    <h3>インデックスファイルの断片化の改善</h3>
    <p>
        インデックスの断片化によりファイルサイズが増加する場合、<m-b>REINDEX</m-b>コマンドによりインデックスを再定義する。
        REINDEXを実行すると、<m-b>ACCESS EXCLUSIVE</m-b>レベルのロックを取得し、テーブルへの更新ができなくなる。
        これを避けたい場合、オプション<m-b>CONCURRENTLY</m-b>を付与することで、一時的に別のインデックスを作成し対象のテーブルをロックしない。
    </p>
    <h4>対象のインデックスのみ再定義する場合</h4>
    <pre><code>
<m-b>REINDEX (VERBOSE) INDEX インデックス名</m-b>;
    </code></pre>
    <h4>対象のテーブル上のインデックスをすべて再定義する場合</h4>
    <pre><code>
<m-b>REINDEX (VERBOSE) TABLE テーブル名</m-b>;
    </code></pre>
    <h4>対象のスキーマ上のインデックスをすべて再定義する場合</h4>
    <pre><code>
<m-b>REINDEX (VERBOSE) SCHEMA スキーマ名</m-b>;
    </code></pre>
    <h4>対象のデータベース上のインデックスをすべて再定義する場合</h4>
    <pre><code>
<m-b>REINDEX (VERBOSE) DATABASE データベース名</m-b>;
    </code></pre>
    <h4>対象のデータベース上のシステムカタログのインデックスをすべて再定義する場合</h4>
    <pre><code>
<m-b>REINDEX (VERBOSE) SYSTEM データベース名</m-b>;
    </code></pre>
    <h4>テーブルロックを取得せずに、対象のテーブル上のインデックスをすべて再定義する場合</h4>
    <pre><code>
<m-b>REINDEX (VERBOSE) TABLE CONCURRENTLY テーブル名</m-b>;
    </code></pre>

    <h3>クラスタ性の欠落の改善</h3>
    <p>
        クラスタ性を復活させる場合、<m-b>CLUSTER</m-b>コマンドを使用する。
        このコマンド実行時の基準となるインデックスは<m-b>テーブル</m-b>ごとに定義されていて、psqlのメタコマンド<m-b>\d</m-b>などで確認できる。
        また、一度<m-b>USING</m-b>句でインデックスを指定してこのコマンドを実行すると、システムカタログに保存され、次回以降は<m-b>USING</m-b>句で指定する必要がなくなる。
    </p>
    <h4>クラスタ性を復活させるコマンド例</h4>
    <pre><code>
<m-b>CLUSTER テーブル名 USING インデックス名</m-b>;
    </code></pre>
    <h4>テーブルに対し明示的にクラスタを登録するコマンド例</h4>
    <pre><code>
<m-b>ALTER TABLE テーブル名 CLUSTER ON インデックス名</m-b>;
    </code></pre>
    <h4>テーブルに対し明示的にクラスタを解除するコマンド例</h4>
    <pre><code>
<m-b>ALTER TABLE テーブル名 SET WITHOUT CLUSTER</m-b>;
    </code></pre>

    <h3>CLUSTER実行時の注意点</h3>
    <p>
        PostgreSQLでは、クラスタ性を保つインデックスは定義できない。
        そのため、運用していく中でクラスタ性は損なわれるため、定期的なメンテナンスのオペレーションが必要である。<br>
        なお、CLUSTER実行時には<m-b>REINDEX</m-b>も実行されるので、断片化とクラスタ性の改善を同時に実行する場合は、<m-b>CLUSTER</m-b>コマンドを実行すればよい。
        CLUSTERの処理は<m-b>VACUUM FULL</m-b>の処理とほとんど同じであり、次の点に注意する。
    </p>
    <ul>
        <li>一時的に<m-b>対象テーブル*2 + インデックス</m-b>と同程度の容量が必要となる</li>
        <li><m-b>テーブル</m-b>に対し<m-b>ACCESS EXCLUSIVE</m-b>レベルのロックを取得する</li>
    </ul>

    <h3>CREATE INDEXやCLUSTERコマンドの進捗確認</h3>
    <table>
        <thead>
            <tr>
                <th>コマンド</th>
                <th>確認するビュー</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>CREATE INDEX</td>
                <td><m-b>pg_stat_progress_create_index</m-b></td>
            </tr>
            <tr>
                <td>CLUSTER</td>
                <td><m-b>pg_stat_progress_cluster</m-b></td>
            </tr>
        </tbody>
    </table>

    <h3>インデックスオンリースキャンの利用</h3>
    <p>
        インデックスのみを使用しテーブルデータを確認せずに検索する仕組みを、<m-b>インデックスオンリースキャン</m-b>という。
        これは、テーブルデータではなく<m-b>VM</m-b>を確認する仕組みとなっている。
        テーブルデータを取得していないことを確認する場合、コマンド<m-b>EXPLAIN</m-b>にオプション<m-b>ANALYZE</m-b>、<m-b>BUFFERS</m-b>を付与して実行する。
        このとき、項目<m-b>Heap Fetches</m-b>にはテーブルを参照した回数が出力され、インデックスのみを参照する場合は値が<m-b>0</m-b>となる。<br>
        インデックスオンリースキャンは、得られる効果も大きいが、利用できる条件が厳しい側面もある。
        PostgreSQL14時点で、使用できるインデックスの種類は<m-b>B-tree</m-b>、<m-b>GiST</m-b>、<m-b>SP-GiST</m-b>のみである。
    </p>

    <h2>17章 実行計画の取得/解析</h2>

    <h3>最適な実行計画が選択されない</h3>
    <p>
        PostgreSQLは実行計画を作成するとき、自動バキュームやANALYZEコマンドで取得する<m-b>統計情報</m-b>と、ページや行単位の演算にかかるコスト値を用いる。
        ただし、これによって算出される実行計画は、必ずしも最適なものとは限らない。
        PostgreSQLが原因になることもあれば、アプリケーションやミドルウェア、ハードウェアのリソース不足などが原因となることもある。
    </p>

    <h3>PostgreSQLが原因で最適な実行計画が選択されない</h3>
    <h4>コスト基準値の設定</h4>
    <p>
        PostgreSQLは、<m-b>ハードディスクへのアクセス</m-b>が最も高コストの処理と判定する。
        推定の基準となるコストは、パラメータ<m-b>random_page_cost</m-b>と<m-b>seq_page_cost</m-b>で設定される。
        デフォルト値は、<m-b>HDD</m-b>の利用を前提とし、それぞれ<m-b>4.0</m-b>、<m-b>1.0</m-b>となっている。
        これらは、使用するディスクによってチューニングする。(特に、<m-b>SSD</m-b>を使用する場合)
    </p>
    <h4>統計情報の取得頻度</h4>
    <p>
        バッチ処理など、短時間に大量のトランザクションを処理すると、<m-b>統計情報</m-b>が実データと乖離する場合がある。
        これを用いて生成される実行計画も、適切に算出されない場合があることに注意する。
    </p>
    <h4>統計情報の取得粒度</h4>
    <p>
        取得する統計情報の数は、デフォルトで<m-b>30000</m-b>件に固定されている。
        これよりもはるかに多くのデータがある場合、デフォルトのサンプリング数では不足している可能性がある。
        統計情報の数を増やすことで実行計画の精度をあげることを検討する。
        ただし、統計情報の取得コストが増加することに注意する。
    </p>

    <h3>EXECUTEコマンドのオプション</h3>
    <table>
        <thead>
            <tr>
                <th>オプション</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>ANALYZE</m-b></td>
                <td>実際にクエリを実行して、実行計画と実処理時間の両方を取得する</td>
            </tr>
            <tr>
                <td><m-b>VERBOSE</m-b></td>
                <td>
                    実行計画の各ノードが出力する列名の情報を追加で出力する<br>
                    また、PostgreSQL14からは、<m-b>Query Identifier</m-b>(<m-b>クエリ識別子</m-b>)も出力する。
                    これをログやシステムビューに表示することで、多角的にクエリ分析を行える。
                </td>
            </tr>
            <tr>
                <td><m-b>COSTS</m-b></td>
                <td>デフォルトで有効になっていて、各ノードの初期コスト/総コストと、統計情報に保存されているテーブルの平均行長/行数を出力する</td>
            </tr>
            <tr>
                <td><m-b>SETTINGS</m-b></td>
                <td>
                    postgresql.confやテーブルに設定しているパラメータの情報を追加で表示する<br>
                    デフォルト値から変更されていて、実行計画の作成に影響のあるパラメータの情報が出力される。
                </td>
            </tr>
            <tr>
                <td><m-b>BUFFERS</m-b></td>
                <td><m-b>ANALYZE</m-b>オプションと共に指定し、共有バッファから読み込んだページ数とディスクから読み込んだページ数を出力する</td>
            </tr>
            <tr>
                <td><m-b>WAL</m-b></td>
                <td><m-b>ANALYZE</m-b>オプションと共に指定し、クエリ実行時に作成されるWALの情報を出力する</td>
            </tr>
            <tr>
                <td><m-b>TIMING</m-b></td>
                <td><m-b>ANALYZE</m-b>オプションと共に指定し、各ノードの処理時間を出力する(<m-b>ANALYZE</m-b>オプション指定時のデフォルト動作)</td>
            </tr>
            <tr>
                <td><m-b>SUMMARY</m-b></td>
                <td>実行計画の作成時間を表示する(<m-b>ANALYZE</m-b>オプション指定時のデフォルト動作)</td>
            </tr>
            <tr>
                <td><m-b>FORMAT</m-b></td>
                <td>
                    出力フォーマットを指定する<br>
                    デフォルト設定は<m-b>TEXT形式</m-b>であり、他にも<m-b>XML形式</m-b>、<m-b>JSON形式</m-b>、<m-b>YAML形式</m-b>をサポートする。
                </td>
            </tr>
        </tbody>
    </table>

    <h3>ANALYZEコマンド</h3>
    <p>
        ANALYZEコマンドは、指定したテーブルの<m-b>統計情報</m-b>を取得するSQLコマンドである。
        統計情報は、システムカタログの<m-b>pg_statistic</m-b>に保存される。<br>
        PostgreSQLは、デフォルトで<m-b>自動バキューム</m-b>の実行時にも統計情報を取得する。
        手動でANALYZEコマンドを実行するよりも、自動バキュームに任せる方が負荷をかけずに住むため、通常は自動バキュームを有効にする。
        なお、統計情報はサンプリングによって取得されるため、数行の更新では統計情報の更新は不要であり、大量の更新が発生した場合にANALYZEコマンドによる手動実行を行う。
    </p>

    <h3>ANALYZEコマンドのオプション</h3>
    <table>
        <thead>
            <tr>
                <th>オプション</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>VERBOSE</m-b></td>
                <td>ANALYZEコマンドの詳細な進捗情報を表示する</td>
            </tr>
            <tr>
                <td><m-b>SKIP_LOCKED</m-b></td>
                <td>ロックの開放待ちを行わず、対象テーブルの統計情報取得をスキップする</td>
            </tr>
        </tbody>
    </table>

    <h3>統計情報取得に関するパラメータ</h3>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th>デフォルト値</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>autovacuum</m-b></td>
                <td><m-b>on</m-b></td>
                <td>
                    統計情報を自動で収集するか<br>
                    CREATE TABLE、ALTER TABLEでテーブルごとに指定する場合、<m-b>autovacuum_enabled</m-b>で指定する。
                </td>
            </tr>
            <tr>
                <td><m-b>autovacuum_analyze_threshold</m-b></td>
                <td><m-b>50</m-b></td>
                <td>自動バキュームを実行する条件として、更新された行数の閾値</td>
            </tr>
            <tr>
                <td><m-b>autovacuum_analyze_scale_factor</m-b></td>
                <td><m-b>0.1</m-b></td>
                <td>自動バキュームを実行する条件として、更新された行数のテーブル行数に対する比率の閾値</td>
            </tr>
            <tr>
                <td><m-b>default_statistics_target</m-b></td>
                <td><m-b>100</m-b></td>
                <td>統計情報のサンプリング数(設定値×300行)</td>
            </tr>
        </tbody>
    </table>

    <h3>システムカタログ pg_statistic とシステムビュー pg_stats </h3>
    <p>
        収集した統計情報は、自動/手動を問わず<m-b>pg_statistic</m-b>に格納される。
        このテーブルでは、列ごとに統計情報が格納され、<m-b>プランナ</m-b>がコストを計算する際に使用する。
        このテーブルを参照できるのは、<m-b>スーパーユーザ</m-b>のみである。
        一般ユーザは<m-b>pg_stats</m-b>を参照することができ、同じ列ごとの統計情報が表示される。
    </p>
    <h4>pg_statisticの主な項目</h4>
    <table>
        <thead>
            <tr>
                <th>カラム</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>starelid</m-b></td>
                <td>対象のテーブルのoid</td>
            </tr>
            <tr>
                <td><m-b>staattnum</m-b></td>
                <td>対象カラムに紐づく番号</td>
            </tr>
            <tr>
                <td><m-b>stainherit</m-b></td>
                <td>
                    当該の統計情報が継承テーブルのデータを含むかどうか<br>
                    継承テーブルを持つテーブルの場合、2つの統計情報が作成される(プランナは問い合わせによって2つの統計情報を使い分けている)
                </td>
            </tr>
            <tr>
                <td><m-b>stanullfrac</m-b></td>
                <td>NULL値である列の割合</td>
            </tr>
            <tr>
                <td><m-b>stawidth</m-b></td>
                <td>非NULL値による平均列長</td>
            </tr>
            <tr>
                <td><m-b>stadistinct</m-b></td>
                <td>カーディナリティ</td>
            </tr>
        </tbody>
    </table>

    <h3>実行計画を自動生成する拡張モジュール auto_explain</h3>
    <p>
        拡張モジュール<m-b>auto_explain</m-b>を有効にすることで、クエリ実行時に自動で実行計画を<m-b>テキスト</m-b>形式で出力する。(デフォルト設定)
        これは、内部的な構造を出力するオーバヘッドが発生するため、特に大量のクエリを実行する際には性能低下のリスクがあるため注意する。
    </p>
    <h4>yumでauto_explainをインストールする方法</h4>
    <pre><code>
yum install <m-b>postgresql14-contrib</m-b>
    </code></pre>
    <h4>postgresql.confでauto_explainを有効にするときの記述</h4>
    <pre><code>
<m-b>shared_proload_libraries</m-b> = <m-b>auto_explain</m-b>
    </code></pre>
    <h4>SQLコマンドでauto_explainを有効にするときのクエリ</h4>
    <pre><code>
<m-b>LOAD 'auto_explain'</m-b>;
    </code></pre>
    <h4>auto_explainで使用可能なオプション</h4>
    <table>
        <thead>
            <tr>
                <th>オプション名</th>
                <th>設定値</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>log_min_duration</m-b></td>
                <td><m-b>ミリ秒</m-b></td>
                <td>
                    ログ出力を行うクエリの最小実行時間<br>
                    デフォルト(<m-b>-1</m-b>)は何もログ出力をしない。
                    <m-b>0</m-b>はすべてのログを出力する。
                </td>
            </tr>
            <tr>
                <td><m-b>log_analyze</m-b></td>
                <td><m-b>true/false</m-b></td>
                <td>
                    EXPLAIN ANALYZEと同様のログを出力するか<br>
                    trueに設定すると、ログ表示にかかるコストが増加する。
                </td>
            </tr>
            <tr>
                <td><m-b>log_buffers</m-b></td>
                <td><m-b>true/false</m-b></td>
                <td>
                    EXPLAIN (ANALYZE BUFFERS)と同様のログを出力するか
                </td>
            </tr>
            <tr>
                <td><m-b>log_wal</m-b></td>
                <td><m-b>true/false</m-b></td>
                <td>
                    EXPLAIN (ANALYZE true, WAL true)同様のログを出力するか
                </td>
            </tr>
            <tr>
                <td><m-b>log_timing</m-b></td>
                <td><m-b>true/false</m-b></td>
                <td>
                    EXPLAIN (ANALYZE, TIMING on)と同様のログを出力するか<br>
                    trueに設定すると、ログ表示にかかるコストが増加する。
                </td>
            </tr>
            <tr>
                <td><m-b>log_triggers</m-b></td>
                <td><m-b>true/false</m-b></td>
                <td>
                    トリガ実行の統計を出力するか<br>
                    <m-b>log_analyze</m-b>がtrueの場合にのみ有効である。
                </td>
            </tr>
            <tr>
                <td><m-b>sample_rate</m-b></td>
                <td><m-b>0~1の実数</m-b></td>
                <td>
                    ログを出力する割合<br>
                    デフォルトは<m-b>1</m-b>である。
                </td>
            </tr>
            <tr>
                <td><m-b>log_verbose</m-b></td>
                <td><m-b>true/false</m-b></td>
                <td>
                    EXPLAIN VERBOSEと同様のログを出力するか
                </td>
            </tr>
            <tr>
                <td><m-b>log_settings</m-b></td>
                <td><m-b>true/false</m-b></td>
                <td>
                    EXPLAIN (SETTING true)と同様のログを出力するか
                </td>
            </tr>
            <tr>
                <td><m-b>log_format</m-b></td>
                <td><m-b>text</m-b>/<m-b>xml</m-b>/<m-b>json</m-b>/<m-b>yaml</m-b></td>
                <td>
                    ログ出力のフォーマット
                </td>
            </tr>
            <tr>
                <td><m-b>log_nested_statements</m-b></td>
                <td><m-b>true/false</m-b></td>
                <td>
                    EXPLAINコマンドではサポートされていない特殊なオプション<br>
                    trueに設定すると、入れ子状のクエリに対する実行計画を表示する。
                </td>
            </tr>
        </tbody>
    </table>
    <p>
        なお、auto_explainのオプションは、ファイル<m-b>postgresql.conf</m-b>でプレフィックス<m-b>auto_explain.</m-b>を付与して指定する。
    </p>

    <h3>拡張統計情報</h3>
    <p>
        PostgreSQLにおける統計情報は、テーブル内のカラムごとに統計値が取得される。
        しかしこれだけでは、<m-b>WHERE</m-b>句や<m-b>GROUP BY</m-b>句を用いて複数の列の組み合わせで絞り込みを行う場合などに、
        実行計画で正確な推定がされない場合がある。<br>
        このように、カラム個別の統計情報だけでは読み取れないデータの特徴を実行計画に反映するための仕組みが<m-b>拡張統計情報</m-b>である。
        これを用いると、カラムの組み合わせで統計情報を作成できる。
        作成に用いるコマンドは<m-b>CREATE STATISTICS</m-b>である。
        作成された拡張統計情報はシステムカタログ<m-b>pg_statistic_ext_data</m-b>に保存される。
    </p>
    <h4>拡張統計情報の種別</h4>
    <table>
        <thead>
            <tr>
                <th>種別</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>ndistinct</m-b></td>
                <td>
                    列値の重複度合いに関する統計を有効にする<br>
                    複数のカラムのバリエーションを取得する
                </td>
            </tr>
            <tr>
                <td><m-b>dependencies</m-b></td>
                <td>
                    関数的依存統計を有効にする<br>
                    他のカラムに対する関連性の強さを<m-b>0~1</m-b>の範囲で表す。
                </td>
            </tr>
            <tr>
                <td><m-b>mcv</m-b></td>
                <td>カラムの組み合わせにおける最頻値の統計取得を有効にする</td>
            </tr>
        </tbody>
    </table>

    <h3>実行計画の構造</h3>
    <p>
        実行計画は、処理する単位を<m-b>ノード</m-b>と呼び、階層構造を形成する。
        テキスト形式で表示する実行計画は、1行目に<m-b>ルートノード</m-b>が出力され、
        順に<m-b>-></m-b>の記号と<m-b>インデント</m-b>によって階層ごとのノードが出力される。
        問い合わせの実行は<m-b>最も深い</m-b>階層のノードから実行され、ルートノードの処理は最後に実行される。
    </p>

    <h3>スキャン系ノード</h3>
    <p>
        データを取り出すスキャン系ノードには、<m-b>シーケンシャルスキャン</m-b>と<m-b>インデックススキャン</m-b>がある。
        スキャン系ノードは、通常<m-b>最も深い</m-b>階層に現れ、最初に実行されるノードである。
    </p>
    <h4>スキャン系ノードの種別</h4>
    <table>
        <thead>
            <tr>
                <th>ノード名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>Seq Scan</m-b></td>
                <td>テーブル全体を順番にスキャンする</td>
            </tr>
            <tr>
                <td><m-b>Index Scan</m-b></td>
                <td>テーブルに付与されたインデックスを用いてその順にスキャンする</td>
            </tr>
            <tr>
                <td><m-b>Index Only Scan</m-b></td>
                <td>テーブルに付与されたインデックスのみを用いてスキャンする</td>
            </tr>
            <tr>
                <td><m-b>Bitmap Scan</m-b></td>
                <td>テーブルに付与されたインデックスからビットマップを作成してスキャンする</td>
            </tr>
            <tr>
                <td><m-b>Foreign Scan</m-b></td>
                <td>外部表に対してスキャンする</td>
            </tr>
            <tr>
                <td><m-b>Function Scan</m-b></td>
                <td>組み込み関数やユーザ定義関数を実行する</td>
            </tr>
        </tbody>
    </table>

    <h3>結合ノード</h3>
    <p>
        結合ノードは<m-b>2つ</m-b>の実行結果の集合を求めるものであり、<m-b>1つ</m-b>の結果を返す。
    </p>
    <table>
        <thead>
            <tr>
                <th>ノード名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>Nested Loop</m-b></td>
                <td>
                    外側テーブル1行のデータに対して内側テーブルすべて評価する<br>
                    このとき、<m-b>Join Filter</m-b>で評価される。
                    <m-b>二重</m-b>ループになるため、ループ回数が増えるほど効率は悪くなる。
                </td>
            </tr>
            <tr>
                <td><m-b>Hash Join</m-b></td>
                <td>
                    内側テーブルのハッシュを作成し、ハッシュに基づいて外側テーブルを評価する<br>
                    ハッシュを作成するため、先に内側テーブルをスキャンしてから外側テーブルをスキャンする。
                    最初にハッシュを作成するためのオーバヘッドが発生するが、内側テーブルのサイズが<m-b>小さく</m-b>、外側テーブルのサイズが<m-b>大きい</m-b>場合などに有効となる。
                </td>
            </tr>
            <tr>
                <td><m-b>Merge Join</m-b></td>
                <td>
                    結合条件でソートされたテーブルを順に評価する<br>
                    2つのテーブルを結合キーでソートし、順番に突き合わせることで評価する。
                    結合キーでソートされた状態が前提のため、事前にソート処理が必要である。
                    ソート処理のオーバヘッドが大きいことが課題となるが、あらかじめソート済みのデータを結合する際は有効である。
                    また、<m-b>大きな</m-b>テーブル同士の結合で、<m-b>ハッシュ</m-b>がメモリに収まらないような場合に有効である。
                </td>
            </tr>
        </tbody>
    </table>

    <h3>データを加工するノード</h3>
    <table>
        <thead>
            <tr>
                <th>ノード名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>Limit</m-b></td>
                <td>明示的に上限を要求する場合に作成される</td>
            </tr>
            <tr>
                <td><m-b>Result</m-b></td>
                <td>プランナが実行計画を組み上げる上で必要に応じて追加する</td>
            </tr>
        </tbody>
    </table>

    <h3>その他のノード</h3>
    <table>
        <thead>
            <tr>
                <th>
                    <nobr>ノード名</nobr>
                </th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>Sort</m-b></td>
                <td>
                    スキャン結果をソートする<br>
                    ノードにはソートに用いる<m-b>カラム名</m-b>が表示され、<m-b>DESC</m-b>の場合はそれも表示される。
                    また、ソートの方法(<m-b>クイックソート</m-b>/<m-b>外部ソート</m-b>)も表示される。
                </td>
            </tr>
            <tr>
                <td><m-b>Incremental Sort</m-b></td>
                <td>スキャン結果のソート時にインデックスを用いることでソートに用いるメモリを削減し、1件目の結果取得を高速化する</td>
            </tr>
            <tr>
                <td><m-b>Hash</m-b></td>
                <td>スキャン結果からハッシュを取得する</td>
            </tr>
            <tr>
                <td><m-b>Aggregate</m-b></td>
                <td>スキャン結果をsum()やavg()などの演算で集約する</td>
            </tr>
            <tr>
                <td><m-b>HashAggregate</m-b></td>
                <td>スキャン結果からハッシュを作成しその結果で集約する</td>
            </tr>
            <tr>
                <td><m-b>Append</m-b></td>
                <td>
                    スキャン結果に別のスキャン結果を追加する<br>
                    また、複数<m-b>パーティション</m-b>で実行された検索結果をマージする。
                </td>
            </tr>
            <tr>
                <td><m-b>BitmapAnd</m-b></td>
                <td>複数のビットマップスキャンの結果の積を取得する</td>
            </tr>
            <tr>
                <td><m-b>BitmapOr</m-b></td>
                <td>複数のビットマップスキャンの結果の和を取得する</td>
            </tr>
            <tr>
                <td><m-b>Modify Table</m-b></td>
                <td>INSERT/UPDATE/DELETEなどの更新系SQLにEXPLAINを発行したときの特殊なノード</td>
            </tr>
            <tr>
                <td><m-b>Materialize</m-b></td>
                <td>スキャン結果を一時的にファイルに書き出す</td>
            </tr>
            <tr>
                <td><m-b>Gather</m-b></td>
                <td>並列に実行したスキャン結果を集約する</td>
            </tr>
        </tbody>
    </table>

    <h3>パラレルクエリ</h3>
    <p>
        パラレルクエリとは、複数のCPUを並列に実行するような<m-b>実行計画</m-b>のことを指す。
        PostgreSQL9.6で導入され、バージョンごとに対応するノードも増えている。
    </p>
    <h4>パラレルクエリに関するノード</h4>
    <table>
        <thead>
            <tr>
                <th>
                    <nobr>ノード名</nobr>
                </th>
                <th>
                    <nobr>導入<br>バージョン</nobr>
                </th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>Parallel Seq Scan</m-b></td>
                <td>9.6</td>
                <td>テーブルスキャンを並列実行する</td>
            </tr>
            <tr>
                <td><m-b>Parallel Index Scan</m-b></td>
                <td>10</td>
                <td>インデックススキャンを並列実行する</td>
            </tr>
            <tr>
                <td><m-b>Parallel Index Only Scan</m-b></td>
                <td>10</td>
                <td>インデックスオンリースキャンを並列実行する</td>
            </tr>
            <tr>
                <td><m-b>Parallel Bitmap Heap Scan</m-b></td>
                <td>10</td>
                <td>ビットマップスキャンを並列実行する</td>
            </tr>
            <tr>
                <td><m-b>Nested Loop</m-b></td>
                <td>9.6</td>
                <td>外側テーブル1行のデータに対して、内側テーブルをN並列で評価する</td>
            </tr>
            <tr>
                <td><m-b>Parallel Hash Join</m-b></td>
                <td>9.6</td>
                <td>内側テーブルのハッシュを作成し、ハッシュに基づいて外側テーブルを並列に評価する</td>
            </tr>
            <tr>
                <td><m-b>Merge Join</m-b></td>
                <td>10</td>
                <td>結合条件でソートされたテーブルを、各プロセスが分担して並列に評価する</td>
            </tr>
            <tr>
                <td><m-b>Finalize Aggregate</m-b></td>
                <td>9.6</td>
                <td>並列処理する各プロセスが生成した部分的な結果を1つに集約する</td>
            </tr>
            <tr>
                <td><m-b>Partial Aggregate</m-b></td>
                <td>9.6</td>
                <td>並列処理する各プロセスの処理結果を一時的・部分的に集約する</td>
            </tr>
            <tr>
                <td><m-b>Gather</m-b></td>
                <td>9.6</td>
                <td>並列実行した処理結果を集約する</td>
            </tr>
            <tr>
                <td><m-b>Gather Merge</m-b></td>
                <td>10</td>
                <td>処理のソートが必要な場合に、並列に実行した処理結果をマージしながら集約する</td>
            </tr>
            <tr>
                <td><m-b>Parallel Append</m-b></td>
                <td>11</td>
                <td>並列実行された複数のスキャン結果を統合する</td>
            </tr>
        </tbody>
    </table>

    <h3>パラレルクエリのチューニングパラメータ</h3>
    <p>
        パラレルクエリを使用するために特別な設定は不要だが、設定パラメータに基づいてPostgreSQLが判断して使用するため、制御はできない。
        そのため、適切にパラレルクエリを使用したい場合、ユーザがパラメータをチューニングする必要がある。
    </p>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th><nobr>デフォルト値</nobr></th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>parallel_setup_cost</m-b></td>
                <td><m-b>1000</m-b></td>
                <td>
                    パラレルワーカプロセスを起動する閾値となるコスト<br>
                    <m-b>seq_page_cost</m-b>に対する相対的なコストを指定する。
                </td>
            </tr>
            <tr>
                <td><m-b>parallel_tuple_cost</m-b></td>
                <td><m-b>0.1</m-b></td>
                <td>
                    1タプルをあるワーカプロセスから別のワーカプロセスにコピーする閾値となるコスト<br>
                    <m-b>seq_page_cost</m-b>に対する相対的なコストを指定する。
                </td>
            </tr>
            <tr>
                <td><m-b>min_parallel_table_scan_size</m-b></td>
                <td><m-b>8MB</m-b></td>
                <td>テーブルスキャンを並列処理するための下限のテーブルサイズ</td>
            </tr>
            <tr>
                <td><m-b>min_parallel_index_scan_size</m-b></td>
                <td><m-b>512kB</m-b></td>
                <td>インデックススキャンを並列処理するための下限のインデックスサイズ</td>
            </tr>
            <tr>
                <td><m-b>force_parallel_mode</m-b></td>
                <td><m-b>off</m-b></td>
                <td>性能によらず強制的に並列処理の実行計画を作成するかどうか</td>
            </tr>
            <tr>
                <td><m-b>max_worker_processes</m-b></td>
                <td><m-b>8</m-b></td>
                <td>システムがサポートするバックグラウンドプロセスの上限</td>
            </tr>
            <tr>
                <td><m-b>max_parallel_workers</m-b></td>
                <td><m-b>8</m-b></td>
                <td>パラレルクエリ用にシステムがサポートするワーカ数の上限</td>
            </tr>
            <tr>
                <td><m-b>max_parallel_workers_per_gather</m-b></td>
                <td><m-b>2</m-b></td>
                <td>
                    GatherまたはGather Mergeノード1つに対して起動できるパラレルクエリのワーカ数の上限<br>
                    <m-b>max_worker_processes</m-b>が上限数となる。
                </td>
            </tr>
            <tr>
                <td><m-b>max_parallel_maintenance_workers</m-b></td>
                <td><m-b>2</m-b></td>
                <td>CREATE INDEXとVACUUMが利用するワーカプロセス数の上限</td>
            </tr>
            <tr>
                <td><m-b>parallel_leader_participation</m-b></td>
                <td><m-b>on</m-b></td>
                <td>
                    並列処理にリーダプロセスも参加するかどうか<br>
                    <m-b>on</m-b>にすると、並列度は上がるがリーダプロセスが担当する処理が終わるまで次のノードに結果を返せず、クエリ全体の処理時間が早まるとは限らない。
                </td>
            </tr>
        </tbody>
    </table>

    <h3>各ノードで表示される共通項目</h3>
    <table>
        <thead>
            <tr>
                <th>表示項目</th>
                <th>項目名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="2"><m-b>cost=X.XX..Y.YY</m-b></td>
                <td><m-b>始動コスト</m-b>(X.XX)</td>
                <td>1県目のデータを返却できるようになるまでにかかるコスト</td>
            </tr>
            <tr>
                <td><m-b>総コスト</m-b>(Y.YY)</td>
                <td>すべてのデータを返却するまでにかかるコスト</td>
            </tr>
            <tr>
                <td><m-b>width=XXX</m-b></td>
                <td><m-b>行長</m-b></td>
                <td>ノードが返却する1行当たりの平均の行の長さ</td>
            </tr>
            <tr>
                <td><m-b>rows=YYY</m-b></td>
                <td><m-b>行数</m-b></td>
                <td>ノードが返却する行数</td>
            </tr>
        </tbody>
    </table>

    <h3>処理コストの見積もり</h3>
    <p>
        シーケンシャルスキャンのようなノードは始動コストが<m-b>0</m-b>になるが、インデックススキャンなどは事前の処理があるため異なる。
        また<m-b>ソート</m-b>や<m-b>ハッシュ</m-b>などのノードは、事前処理ですべてのデータを読み込むため、始動コストは<m-b>大きく</m-b>なる。<br>
        総コストは、すべての<m-b>下位</m-b>ノードの処理を実行するコストであり、<m-b>下位</m-b>ノードのコストは<m-b>上位</m-b>ノードのコストに加算される。
        始動コストが大きいことは必ずしも問題でなく、総コストがどの程度増加するかが重要となる。<br>
        行長は、テーブルを構成するカラムのデータ型の長さを足し合わせたものとなる。
        integer型のカラムが2つのテーブルであれば、行長は<m-b>8</m-b>となる。
        text型のように長さが不定のカラムを含む場合、<m-b>統計情報</m-b>を収集していないと妥当な値が表示されない。
        また、行数は総コストを求めるうえで重要な指標となるが、これも<m-b>統計情報</m-b>を収集していないと正確な値が算出できない。
    </p>
    <h4>行長を確認するSQLクエリ</h4>
    <pre><code>
SELECT tablename, attname, <m-b>avg_width</m-b> FROM <m-b>pg_stats</m-b> WHERE tablename = 'テーブル名';
    </code></pre>
    <h4>行数を確認するSQLクエリ</h4>
    <pre><code>
SELECT relname, <m-b>reltuples</m-b> FROM <m-b>pg_class</m-b> WHERE relname = 'テーブル名';
    </code></pre>

    <h3>処理コストの見積もりに関するパラメータ</h3>
    <table>
        <thead>
            <tr>
                <th>パラメータ</th>
                <th><nobr>デフォルト値</nobr></th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>seq_page_cost</m-b></td>
                <td><m-b>1.0</m-b></td>
                <td>
                    ディスクからシーケンシャルアクセスで1ページ分のデータ(<m-b>8192バイト</m-b>)を読み込むためのコスト<br>
                    このパラメータは、他のコスト算出用のパラメータの基準となる相対値である。
                    そのため、基本的に<m-b>1.0</m-b>で設定すればよい。
                </td>
            </tr>
            <tr>
                <td><m-b>random_page_cost</m-b></td>
                <td><m-b>4.0</m-b></td>
                <td>ディスクからランダムアクセスで1ページ分のデータを読み込むためのコスト</td>
            </tr>
            <tr>
                <td><m-b>cpu_tuple_cost</m-b></td>
                <td><m-b>0.01</m-b></td>
                <td>ヒープデータ1行当たりのCPU処理にかかるコスト</td>
            </tr>
            <tr>
                <td><m-b>cpu_index_tuple_cost</m-b></td>
                <td><m-b>0.005</m-b></td>
                <td>インデックスデータ1行当たりのCPU処理にかかるコスト</td>
            </tr>
            <tr>
                <td><m-b>cpu_operator_cost</m-b></td>
                <td><m-b>0.0025</m-b></td>
                <td>WHERE句等で比較演算1回にかかるコスト</td>
            </tr>
            <tr>
                <td><m-b>parallel_setup_cost</m-b></td>
                <td><m-b>1000</m-b></td>
                <td>パラレルワーカのプロセス起動・各種初期化を行うコスト</td>
            </tr>
            <tr>
                <td><m-b>parallel_tuple_cost</m-b></td>
                <td><m-b>0.1</m-b></td>
                <td>1行分のデータをワーカプロセスから別のワーカプロセスにコピーするコスト</td>
            </tr>
            <tr>
                <td><m-b>effectvie_cache_size</m-b></td>
                <td><m-b>4GB</m-b></td>
                <td>
                    ディスクアクセス時のキャッシュヒット率を予想するための、PostgreSQLが利用していると仮定するメモリサイズ<br>
                    このパラメータのみ、<m-b>se_page_cost</m-b>の相対値とは異なる。
                    サーバ上にPostgreSQL以外に動作するアプリケーションがない場合、物理メモリの<m-b>50%</m-b>程度を指定するとよい。
                    この設定値を大きくしたからと言って、実際に確保されるメモリに変動はなく、あくまでキャッシュヒット率からディスクアクセス発生率を推定するための値である。
                </td>
            </tr>
        </tbody>
    </table>

    <h2>18章 パフォーマンスチューニング</h2>

    <h2>その他調査まとめ</h2>

    <h3>関数の変動性分類</h3>
    <p>
        すべての関数は変動性区分を持ち、CREATE FUNCTIONコマンドで指定することができる。
        変動性に関する分類は、オプティマイザによる処理の最適化に影響する。<br>
        変動性の区分は次のものがある。
    </p>
    <table>
        <thead>
            <tr>
                <th>区分</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>VOLATILE</m-b></td>
                <td>
                    データベースの変更を含む、すべてを行うことができる。
                    また、同一引数で呼び出したとしても異なる結果を返すことがある。
                </td>
            </tr>
            <tr>
                <td><m-b>STABLE</m-b></td>
                <td>
                    データベースを変更することができない。
                    また、単一の文内ですべての行に対して同一の引数を渡した場合に同一の結果を返すことが保証される。
                </td>
            </tr>
            <tr>
                <td><m-b>IMMUTABLE</m-b></td>
                <td>
                    データベースを変更することができない。
                    また、同一引数に対する呼び出しは常に同一の結果となる。
                </td>
            </tr>
        </tbody>
    </table>
    <blockquote>
        <a href="https://www.postgresql.jp/docs/9.2/xfunc-volatility.html" target="_blank">
            35.6. 関数の変動性分類
        </a>
    </blockquote>

    <h3>テーブルサイズの取得</h3>
    <p>
        テーブルサイズ(テーブルで使用されるディスク領域)を取得するシステム管理関数は、<m-b>pg_relation_size</m-b>である。
        テーブル名またはテーブルの<m-b>oid</m-b>を引数に渡す。<br>
        ビューを引数に指定した場合、結果は<m-b>0</m-b>となる。
    </p>

    <h3>WALの修正</h3>
    <p>
        WALが壊れてしまうとPostgreSQLは読みだすWALが分からなくなり、起動ができなくなる。
        このような場合、<m-b>pg_resetwal</m-b>コマンドを用いて修復ができる。
        このコマンドは、正常な位置でWALが読み書きできるようにPostgreSQL内部の制御情報を修正する。
    </p>
    <blockquote>
        <a href="https://www.postgresql.jp/docs/12/app-pgresetwal.html" target="_blank">
            pg_resetwal
        </a>
    </blockquote>

    <h3>contribモジュール</h3>
    <p>
        限られたユーザ向けであったり、実験的すぎたりして、PostgreSQL本体に取り込まれていないモジュールのこと。
        contribモジュールは<m-b>contrib</m-b>ディレクトリに格納されている。
    </p>
    <blockquote>
        <a href="https://www.postgresql.jp/document/15/html/contrib.html" target="_blank">
            付録F 追加で提供されるモジュール
        </a>
    </blockquote>

    <h3>LSNとWALファイル名</h3>
    <p>
        次にWALファイルを書き出すLSNは、関数<m-b>pg_current_wal_insert_lsn</m-b>で取得できる。
        また、具体的なWALファイル名は、関数<m-b>pg_walfile_name</m-b>で取得できる。
        この関数は、引数にLSNの文字列を渡すため、組み合わせて使用する。
    </p>
    <blockquote>
        <a href="https://www.postgresql.jp/document/10/html/functions-admin.html" target="_blank">
            9.26. システム管理関数
        </a>
    </blockquote>

    <h3>PostgreSQLのソートについて</h3>
    <p>
        PostgreSQLでは、メモリ上で実行できる場合は<m-b>クイックソート</m-b>を行い、できない場合はソート結果を外部に出力する<m-b>外部ソート</m-b>を使用する。
        後者は、問い合わせが遅くなる要因の一つであり、<m-b>作業メモリ</m-b>のサイズが小さい場合に起こる現象である。
        問い合わせを実行してみるまで、どちらでソートされるかは分からない。
    </p>

    <script src="./asset/dexie.min.js"></script>
    <script src="./asset/jquery-3.7.1.slim.min.js"></script>
    <script src="./asset/script.js"></script>
</body>

</html>
