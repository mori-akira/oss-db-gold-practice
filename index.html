<!DOCTYPE html>
<html dir="ltr" lang="ja">

<head>
    <meta charset="utf-8">
    <title>OSS-DB Gold Practice</title>
    <meta name="author" content="Moriaki Kogure">
    <link rel="stylesheet" href="./asset/style.css">
    <link rel="icon" href="./asset/favicon.ico">
</head>

<body>
    <h1>OSS-DB Gold Practice</h1>

    <h4>
        以下書籍の内容まとめ + 調査したことまとめ
    </h4>
    <blockquote>
        <a href="https://gihyo.jp/book/2022/978-4-297-13206-4" target="_blank">
            ［改訂3版］内部構造から学ぶPostgreSQL ― 設計・運用計画の鉄則
        </a>
    </blockquote>

    <h2>2章 アーキテクチャの基本</h2>

    <h3>プロセスの構成</h3>
    <table>
        <thead>
            <tr>
                <th>プロセス名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>マスタサーバ</mask-block></td>
                <td>最初に起動される親プロセス</td>
            </tr>
            <tr>
                <td><mask-block>ロガー</mask-block></td>
                <td>サーバログを書き出す</td>
            </tr>
            <tr>
                <td><mask-block>チェックポインタ</mask-block></td>
                <td>すべてのダーティページをデータファイルに書き出す</td>
            </tr>
            <tr>
                <td><mask-block>ライタ</mask-block></td>
                <td>共有バッファの内容をデータファイルに書き出す</td>
            </tr>
            <tr>
                <td><mask-block>WALライタ</mask-block></td>
                <td>WALバッファの内容をWALファイルに書き出す</td>
            </tr>
            <tr>
                <td><mask-block>自動バキュームランチャ</mask-block></td>
                <td>設定に従って自動バキュームワーカを起動する</td>
            </tr>
            <tr>
                <td><mask-block>自動バキュームワーカ</mask-block></td>
                <td>設定に従って自動バキューム処理を行う</td>
            </tr>
            <tr>
                <td><mask-block>統計情報コレクタ</mask-block></td>
                <td>データベースの活動状況に関する統計情報を収集する</td>
            </tr>
            <tr>
                <td><mask-block>バックグラウンドワーカ</mask-block></td>
                <td>ロジカルレプリケーション用、またはユーザ定義のワーカ</td>
            </tr>
            <tr>
                <td><mask-block>バックエンドプロセス</mask-block></td>
                <td>クライアントからの接続要求に対して起動され、クエリを処理する</td>
            </tr>
            <tr>
                <td><mask-block>パラレルワーカ</mask-block></td>
                <td>パラレルスキャン実行時に起動され、クエリを処理する</td>
            </tr>
        </tbody>
    </table>

    <h3>共有メモリ域</h3>
    <table>
        <thead>
            <tr>
                <th>メモリ名</th>
                <th>物理名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>共有バッファ</mask-block></td>
                <td><mask-block>shared_buffers</mask-block></td>
                <td>テーブルやインデックスのデータをキャッシュする領域</td>
            </tr>
            <tr>
                <td><mask-block>WALバッファ</mask-block></td>
                <td><mask-block>wal_buffers</mask-block></td>
                <td>ディスクに書き込まれていないトランザクションログをキャッシュする領域</td>
            </tr>
            <tr>
                <td><mask-block>空き領域マップ</mask-block></td>
                <td><mask-block>Free Space Map</mask-block></td>
                <td>テーブル上の利用可能な領域を示す情報を扱う領域</td>
            </tr>
            <tr>
                <td><mask-block>可視性マップ</mask-block></td>
                <td><mask-block>Visibility Map</mask-block></td>
                <td>テーブルのデータが可視であるか否かを管理する情報を扱う領域</td>
            </tr>
        </tbody>
    </table>

    <h3>プロセスメモリ</h3>
    <table>
        <thead>
            <tr>
                <th>メモリ名</th>
                <th>物理名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>作業メモリ</mask-block></td>
                <td><mask-block>work_mem</mask-block></td>
                <td>クエリ実行時に行われる、並び替えとハッシュテーブル操作のために使われる領域</td>
            </tr>
            <tr>
                <td><mask-block>メンテナンス用作業メモリ</mask-block></td>
                <td><mask-block>maintenance_work_mem</mask-block></td>
                <td>バキューム、インデックス作成、外部キー作成などの、データベースメンテナンスの操作で使用する領域</td>
            </tr>
            <tr>
                <td><mask-block>一時バッファ</mask-block></td>
                <td><mask-block>temp_buffers</mask-block></td>
                <td>バックエンドプロセス毎に作成される一時テーブルにアクセスするときに用いるメモリ領域</td>
            </tr>
        </tbody>
    </table>

    <h3>主なディレクトリ</h3>
    <table>
        <thead>
            <tr>
                <th>ディレクトリ名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>base</mask-block></td>
                <td>データベースごとに作成される、識別子(oid)を示す数字で名づけられるディレクトリ</td>
            </tr>
            <tr>
                <td><mask-block>global</mask-block></td>
                <td>データベースクラスタで共有するテーブルを保有するディレクトリ</td>
            </tr>
            <tr>
                <td><mask-block>pg_wal</mask-block></td>
                <td>WALファイルを格納するディレクトリ</td>
            </tr>
            <tr>
                <td><mask-block>pg_xact</mask-block></td>
                <td>トランザクションのコミット状態を管理するファイルが格納されるディレクトリ</td>
            </tr>
            <tr>
                <td><mask-block>pg_tblspc</mask-block></td>
                <td>テーブル空間として作成されたディレクトリへのシンボリックリンクを格納するディレクトリ</td>
            </tr>
        </tbody>
    </table>

    <h3>主なファイル</h3>
    <table>
        <thead>
            <tr>
                <th>ファイル</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>PG_VERSION</mask-block></td>
                <td>PostgreSQLのメジャーバージョンが書き込まれるテキストファイル</td>
            </tr>
            <tr>
                <td><mask-block>テーブルファイル</mask-block></td>
                <td>
                    テーブルデータの実態が格納されているファイル<br>
                    <mask-block>8192</mask-block>バイトの<mask-block>ページ</mask-block>と呼ばれる単位で構成される。
                </td>
            </tr>
            <tr>
                <td><mask-block>インデックスファイル</mask-block></td>
                <td>
                    インデックスの情報が格納されているファイル<br>
                    <mask-block>8192</mask-block>バイトの<mask-block>ページ</mask-block>と呼ばれる単位で構成される。
                </td>
            </tr>
            <tr>
                <td><mask-block>TOASTファイル</mask-block></td>
                <td>
                    テーブル内に長大な行を格納する場合に生成される特殊なファイル<br>
                    このファイルが作られるとき、テーブルの格納領域には<mask-block>oid</mask-block>が格納される。
                </td>
            </tr>
            <tr>
                <td><mask-block>Free Space Mapファイル</mask-block></td>
                <td>
                    空き領域を追跡するための情報が格納されたファイル<br>
                    ファイル名は、「テーブル/インデックスのoid_<mask-block>fsm</mask-block>」となる。
                </td>
            </tr>
            <tr>
                <td><mask-block>Visibility Mapファイル</mask-block></td>
                <td>
                    テーブルの可視性を管理するファイル<br>
                    ファイル名は、「テーブルのoid_<mask-block>vm</mask-block>」となる。
                </td>
            </tr>
            <tr>
                <td><mask-block>WALファイル</mask-block></td>
                <td>
                    PostgreSQLに対して行われた更新操作を記録するファイル<br>
                    ファイルは固定サイズで、initdbやpg_ctlコマンド等を用いてクラスタを作成する際に指定する。<br>
                    デフォルトサイズは<mask-block>16MB</mask-block>である。
                </td>
            </tr>
            <tr>
                <td><mask-block>postgresql.conf</mask-block></td>
                <td>PostgreSQL全体の動作を設定するファイル</td>
            </tr>
            <tr>
                <td><mask-block>pg_hba.conf</mask-block></td>
                <td>クライアントからの接続を管理する設定ファイル</td>
            </tr>
            <tr>
                <td><mask-block>postmaster.pid</mask-block></td>
                <td>PostgreSQLの稼働中に作成されるロックファイル</td>
            </tr>
        </tbody>
    </table>

    <h2>3章 各種設定ファイルと基本設定</h2>

    <h3>PostgreSQLの設定ファイル</h3>
    <table>
        <thead>
            <tr>
                <th>ファイル名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><mask-block>postgresql.conf</mask-block></td>
                <td>PostgreSQL全体の動作を制御する</td>
            </tr>
            <tr>
                <td><mask-block>pg_hba.conf</mask-block></td>
                <td>クライアントからの接続を制御する</td>
            </tr>
            <tr>
                <td><mask-block>pg_ident.conf</mask-block></td>
                <td>ident認証およびGSSAPI認証で使用する</td>
            </tr>
            <tr>
                <td><mask-block>recovery.conf</mask-block></td>
                <td>アーカイブリカバリ用の設定ファイル</td>
            </tr>
            <tr>
                <td><mask-block>pg_service.conf</mask-block></td>
                <td>libpqライブラリの接続情報をサービスとしてまとめて管理する設定ファイル</td>
            </tr>
        </tbody>
    </table>

    <h3>設定ファイルで設定できる型</h3>
    <table>
        <thead>
            <tr>
                <th>型名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>論理型(boolean)</m-b></td>
                <td>
                    真偽値<br>
                    <m-b>on/off</m-b>、<m-b>true/false</m-b>、<m-b>yes/no</m-b>、<m-b>1/0</m-b>を指定できる。<br>
                    大文字と小文字を区別しない。
                </td>
            </tr>
            <tr>
                <td><m-b>浮動小数点型(floating point)</m-b></td>
                <td>小数点を含む数値</td>
            </tr>
            <tr>
                <td><m-b>整数型(integer)</m-b></td>
                <td>
                    小数点を含まない数値<br>
                    PostgreSQL12以降は、整数型の項目にも小数値を指定できる。その場合、最も近い整数値に丸められる。
                </td>
            </tr>
            <tr>
                <td><m-b>文字型(string)</m-b></td>
                <td>
                    任意の文字列<br>
                    空白を含む場合は<m-b>単一引用符</m-b>で囲む必要がある。(含まない場合は囲む必要はない)<br>
                    値に単一引用符を含む場合は、<m-b>二重引用符</m-b>または<m-b>逆引用符</m-b>で囲む。
                </td>
            </tr>
            <tr>
                <td><m-b>列挙型(enum)</m-b></td>
                <td>限定された値の集合</td>
            </tr>
        </tbody>
    </table>

    <h3>単位を指定する文字</h3>
    <table>
        <thead>
            <tr>
                <th>指定対象</th>
                <th>指定する文字</th>
                <th>意味</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="5">メモリ</td>
                <td><m-b>B</m-b></td>
                <td>バイト</td>
            </tr>
            <tr>
                <td><m-b>kB</m-b></td>
                <td>キロバイト</td>
            </tr>
            <tr>
                <td><m-b>MB</m-b></td>
                <td>メガバイト</td>
            </tr>
            <tr>
                <td><m-b>GB</m-b></td>
                <td>ギガバイト</td>
            </tr>
            <tr>
                <td><m-b>TB</m-b></td>
                <td>テラバイト</td>
            </tr>
            <tr>
                <td rowspan="5">時間</td>
                <td><m-b>ms</m-b></td>
                <td>ミリ秒</td>
            </tr>
            <tr>
                <td><m-b>s</m-b></td>
                <td>秒</td>
            </tr>
            <tr>
                <td><m-b>min</m-b></td>
                <td>分</td>
            </tr>
            <tr>
                <td><m-b>h</m-b></td>
                <td>時間</td>
            </tr>
            <tr>
                <td><m-b>d</m-b></td>
                <td>日</td>
            </tr>
        </tbody>
    </table>

    <h3>pg_hba.confの接続方式に指定できるキーワード</h3>
    <table>
        <thead>
            <tr>
                <th>キーワード</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>local</m-b></td>
                <td>Unixドメインソケットを使用する接続方式</td>
            </tr>
            <tr>
                <td><m-b>host</m-b></td>
                <td>
                    TCP/IPを利用した接続方式<br>
                    SSL通信の有無は問わない。
                </td>
            </tr>
            <tr>
                <td><m-b>hostssl</m-b></td>
                <td>SSLを用いた通信方式</td>
            </tr>
            <tr>
                <td><m-b>hostnossl</m-b></td>
                <td>SSLを用いない通信方式</td>
            </tr>
            <tr>
                <td><m-b>hostgssenc</m-b></td>
                <td>TCP/IPを使用し、かつGSSAPI通信を使用した接続方式</td>
            </tr>
            <tr>
                <td><m-b>hostnogssenc</m-b></td>
                <td>TCP/IPを使用し、かつGSSAPI通信を使用しない接続方式</td>
            </tr>
        </tbody>
    </table>

    <h3>pg_hba.confの接続データベースに指定できるキーワード</h3>
    <table>
        <thead>
            <tr>
                <th>キーワード</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>all</m-b></td>
                <td>すべてのデータベースへの接続に対応する</td>
            </tr>
            <tr>
                <td><m-b>sameuser</m-b></td>
                <td>指定したユーザと同名のデータベースへの接続に対応する</td>
            </tr>
            <tr>
                <td><m-b>samerole</m-b></td>
                <td>指定したユーザが所属するロールと同名のデータベースへの接続に対応する</td>
            </tr>
            <tr>
                <td><m-b>replication</m-b></td>
                <td>レプリケーション接続に対応する</td>
            </tr>
            <tr>
                <td><m-b>@ファイルパス</m-b></td>
                <td>
                    データベース名を含むファイルを指定する<br>
                    pg_hba.confファイルが存在するディレクトリからの相対パス、または絶対パスで指定する。
                </td>
            </tr>
        </tbody>
    </table>

    <h3>特殊な名前のデータベース名/ユーザ名について</h3>
    <p>
        PostgreSQLでは、データベース名やユーザ名に<code>all</code>などの予約語を指定することを禁止していない。
        予約語のデータベース名/ユーザ名が存在する場合も、設定ファイルに予約語を指定した場合の挙動は変わらない。
        設定ファイルで予約語のデータベース名/ユーザ名を指定する場合、<m-b>二重引用符</m-b>を用いることができる。
    </p>

    <h3>pg_hba.confの認証方式に指定できるキーワード</h3>
    <table>
        <thead>
            <tr>
                <th>種別</th>
                <th>キーワード</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="2">無条件</td>
                <td><m-b>trust</m-b></td>
                <td>接続を無条件で許可する</td>
            </tr>
            <tr>
                <td><m-b>reject</m-b></td>
                <td>接続を無条件で拒否する</td>
            </tr>
            <tr>
                <td rowspan="3">パスワード認証</td>
                <td><m-b>md5</m-b></td>
                <td>
                    md5暗号化によるパスワード認証を行う<br>
                    主に、scram-sha-256による暗号化が使用できない環境で使用する。
                </td>
            </tr>
            <tr>
                <td><m-b>password</m-b></td>
                <td>
                    平文によるパスワード認証を行う<br>
                    非推奨
                </td>
            </tr>
            <tr>
                <td><m-b>scram-sha-256</m-b></td>
                <td>
                    scram-sha-256暗号化によるパスワード認証を行う<br>
                    パスワード認証方式で推奨される認証方式
                </td>
            </tr>
            <tr>
                <td><m-b>GSSAPI認証</m-b></td>
                <td><m-b>gss</m-b></td>
                <td>
                    GSSAPIによる認証を行う<br>
                    <m-b>Linux</m-b>環境かつTCP/IP接続でのみ使用できる。
                </td>
            </tr>
            <tr>
                <td><m-b>SSPI認証</m-b></td>
                <td><m-b>sspi</m-b></td>
                <td>
                    sspiによる認証を行う<br>
                    <m-b>Windows</m-b>環境でのみ使用できる。
                </td>
            </tr>
            <tr>
                <td><m-b>Ident認証</m-b></td>
                <td><m-b>ident</m-b></td>
                <td>
                    クライアントOSの<m-b>ユーザ名</m-b>をidentサーバから入手してデータベース接続ユーザ名として使用する
                </td>
            </tr>
            <tr>
                <td><m-b>Peer認証</m-b></td>
                <td><m-b>peer</m-b></td>
                <td>
                    OSの<m-b>ユーザ名</m-b>をカーネルから入手してデータベース接続ユーザ名として使用する
                </td>
            </tr>
            <tr>
                <td><m-b>LDAP認証</m-b></td>
                <td><m-b>ldap</m-b></td>
                <td>
                    パスワード認証のためにLDAPサーバを使用する
                </td>
            </tr>
            <tr>
                <td><m-b>RADIUS認証</m-b></td>
                <td><m-b>radius</m-b></td>
                <td>
                    パスワード認証のためにRADIUSサーバを使用する
                </td>
            </tr>
            <tr>
                <td><m-b>証明書認証</m-b></td>
                <td><m-b>cert</m-b></td>
                <td>
                    SSLクライアント証明書を使った認証を行う
                </td>
            </tr>
            <tr>
                <td><m-b>PAM認証</m-b></td>
                <td><m-b>pam</m-b></td>
                <td>
                    パスワード認証のためにPAMを使用する
                </td>
            </tr>
            <tr>
                <td><m-b>BSD認証</m-b></td>
                <td><m-b>bsd</m-b></td>
                <td>
                    OSによって提供されたBSD認証サービスを使用する
                </td>
            </tr>
        </tbody>
    </table>

    <h3>pg_ident.confの使い方</h3>
    <p>
        マッピング名を<code>foo_ident</code>、OSユーザ名を<code>foo</code>、マッピングするデータベース名を<code>user1</code>とするとき、
        pg_ident.confは次のように記述する。
    </p>
    <h4>pg_ident.conf</h4>
    <pre><code>
# map-name system-user-name database-user-name
<m-b>foo_ident</m-b> <m-b>foo</m-b> <m-b>user1</m-b>
    </code></pre>
    <p>また、ident認証で上記のマッピングを使用する場合、pg_hba.confには次のように記述する。</p>
    <h4>pg_hba.conf</h4>
    <pre><code>
# TYPE DATABASE USER METHOD
host all all 192.168.10.0/24 <m-b>ident map=foo_indent</m-b>
    </code></pre>

    <h2>4章 処理/制御の基本</h2>

    <h3>問い合わせ処理の流れ</h3>
    <table>
        <thead>
            <tr>
                <th>処理名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>パーサ</m-b></td>
                <td>
                    問い合わせのはじめに、字句解析と構文解析を行う処理<br>
                    字句解析では、OSSである<m-b>flex</m-b>を用いて処理を行い、
                    <m-b>./backend/parser/scan.l</m-b>というファイルにルールを定義する。<br>
                    構文解析では、OSSである<m-b>bison</m-b>を用いて処理を行い、
                    <m-b>./backend/parser/gram.y</m-b>というファイルにルールを定義する。<br>
                    字句解析と構文解析に成功した場合、<m-b>問い合わせツリー</m-b>という構造を生成し、次の処理へと渡す。
                </td>
            </tr>
            <tr>
                <td><m-b>リライタ</m-b></td>
                <td>
                    SQLを実行するデータベースにルールが定義されている場合に、そのルールを参照して問い合わせツリーを書き換える処理<br>
                    PostgreSQLのビューは、このルールを用いて実現されている。
                </td>
            </tr>
            <tr>
                <td><m-b>プランナ/オプティマイザ</m-b></td>
                <td>問い合わせツリーをもとに最適な実行計画を生成する処理</td>
            </tr>
            <tr>
                <td><m-b>エグゼキュータ</m-b></td>
                <td>実行計画に従って必要な行の集合を抽出する処理</td>
            </tr>
        </tbody>
    </table>

    <h3>トランザクションの特性</h3>
    <table>
        <thead>
            <tr>
                <th>特性</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>原子性(Atomicity)</m-b></td>
                <td>処理の最小単位を定義し、それらの処理がすべて実行されたか、まったく実行されないかのどちらかの結果となること</td>
            </tr>
            <tr>
                <td><m-b>一貫性(Consistency)</m-b></td>
                <td>トランザクションの開始及び終了時点で、業務として規定された整合性を満たすこと</td>
            </tr>
            <tr>
                <td><m-b>独立性(Isolation)</m-b></td>
                <td>作業中のトランザクションによる更新は、確定するまで他のトランザクションから不可視となること</td>
            </tr>
            <tr>
                <td><m-b>永続性(Durability)</m-b></td>
                <td>確定したトランザクションの結果は永続的に保存されること</td>
            </tr>
        </tbody>
    </table>

    <h3>トランザクション分離レベル</h3>
    <table>
        <thead>
            <tr>
                <th>分離レベル</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>READ UNCOMMITED</m-b></td>
                <td>
                    別トランザクションのコミットされていないデータが参照される可能性がある<br>
                    PostgreSQLにおいてはこの実装は存在せず、指定しても<m-b>READ COMMITED</m-b>として扱われる。
                </td>
            </tr>
            <tr>
                <td><m-b>READ COMMITED</m-b></td>
                <td>
                    問い合わせを実行する直前までにコミットされたデータのみを参照する<br>
                    PostgreSQLにおいては、デフォルトの分離レベルとなる。
                </td>
            </tr>
            <tr>
                <td><m-b>REPEATABLE READ</m-b></td>
                <td>トランザクションが開始する直前までにコミットされたデータのみを参照する</td>
            </tr>
            <tr>
                <td><m-b>SERIALIZABLE</m-b></td>
                <td>並列実行された複数のトランザクションの実行であっても、逐次的に扱われたものと同じ結果を要求する</td>
            </tr>
        </tbody>
    </table>

    <h3>分離レベルが不十分な場合に起きる事象</h3>
    <table>
        <thead>
            <tr>
                <th>事象</th>
                <th>抑止できる分離レベル</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>ダーティリード</m-b></td>
                <td><m-b>READ COMMITED</m-b></td>
                <td>
                    同時に実行されている他のトランザクションが書き込んだ、コミット前のデータを読み込んでしまうこと
                </td>
            </tr>
            <tr>
                <td><m-b>反復不能読み取り</m-b></td>
                <td><m-b>REPEATABLE READ</m-b></td>
                <td>
                    同一トランザクション内で複数回読み取りを行い、その結果が別トランザクションの更新の影響で変わってしまうこと
                </td>
            </tr>
            <tr>
                <td><m-b>ファントムリード</m-b></td>
                <td><m-b>SERIALIZABLE</m-b></td>
                <td>
                    同一トランザクション内で複数回読み取りを行い、その結果が別トランザクションの挿入の影響で変わってしまうこと
                </td>
            </tr>
        </tbody>
    </table>

    <h3>ロックモード一覧</h3>
    <table>
        <thead>
            <tr>
                <th>ロックモード</th>
                <th>獲得タイミング</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>ACCESS SHARE</m-b></td>
                <td>
                    <ul>
                        <li>SELECT</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>ROW SHARE</m-b></td>
                <td>
                    <ul>
                        <li>SELECT FOR UPDATE</li>
                        <li>SELECT FOR SHARE</li>
                        <li>SELECT FOR NO KEY UPDATE</li>
                        <li>SELECT FOR KEY SHARE</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>ROW EXCLUSIVE</m-b></td>
                <td>
                    <ul>
                        <li>INSERT</li>
                        <li>UPDATE</li>
                        <li>DELETE</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>SHARE UPDATE EXCLUSIVE</m-b></td>
                <td>
                    <ul>
                        <li>VACUUM</li>
                        <li>ANALYZE</li>
                        <li>CREATE INDEX CONCURRENTLY</li>
                        <li>ALTER TABLE(SET STATISTICS)</li>
                        <li>SET(attr = value)</li>
                        <li>RESET(attr = value)</li>
                        <li>VALIDATE CONSTRAINT</li>
                        <li>CLUSTER ON</li>
                        <li>SET WITHOUT CLUSTER</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>SHARE</m-b></td>
                <td>
                    <ul>
                        <li>CREATE INDEX</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><m-b>SHARE ROW EXCLUSIVE</m-b></td>
                <td>
                    同一セッション内での競合を防ぐためのロックモード<br>
                    明示的にこのロックモードを獲得するコマンドはない。
                </td>
            </tr>
            <tr>
                <td><m-b>EXCLUSIVE</m-b></td>
                <td>
                    明示的にこのロックモードを獲得するコマンドはない。
                </td>
            </tr>
            <tr>
                <td><m-b>ACCESS EXCLUSIVE</m-b></td>
                <td>
                    <ul>
                        <li>ALTER TABLE</li>
                        <li>DROP TABLE</li>
                        <li>TRUNCATE</li>
                        <li>REINDEX</li>
                        <li>CLUSTER</li>
                        <li>VACUUM FULL</li>
                        <li>LOCK TABLE</li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>

    <h3>同時実行制御</h3>
    <p>
        PostgreSQLでは、<m-b>追記型アーキテクチャ</m-b>というアーキテクチャを採用することで、
        <m-b>MVCC(Multi Version Concurrency Control)</m-b>と呼ばれる同時実行制御を実現している。
        追記型アーキテクチャとは、データ更新時にデータを直接書き換えるのではなく、
        トランザクションごとに発行されるID(<m-b>XID</m-b>)をテーブルの各行に保持することで、
        トランザクションごとのデータを保持する仕組みである。<br>
        追記型アーキテクチャの仕様上、不要となるレコードが発生するが、これを整理する処理が<m-b>バキューム</m-b>であり、
        更新前の古いレコードを<m-b>空き領域マップ</m-b>に記録することで、再利用可能とする。<br>
        以前のPostgreSQLではこのバキューム処理の運用が重要な課題となっていたが、PostgreSQL8.3で採用された<m-b>HOT(Heap Only Tuple)</m-b>や、
        自動バキューム機能の強化により、バキューム処理を意識する必要がなくなった。
    </p>

    <h2>5章 テーブル設計</h2>

    <h3>文字型</h3>
    <table>
        <thead>
            <tr>
                <th>型名</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    <m-b>character varying(n)</m-b>、
                    <m-b>varchar(n)</m-b>
                </td>
                <td>上限n文字まで格納可能な可変長データ型</td>
            </tr>
            <tr>
                <td>
                    <m-b>character(n)</m-b>、
                    <m-b>char(n)</m-b>
                </td>
                <td>
                    上限n文字までを格納可能な固定長データ型<br>
                    格納時にn文字に満たない場合は<m-b>末尾</m-b>に空白を付与して格納する。
                    検索時にも空白が付与された結果が取得される。
                </td>
            </tr>
            <tr>
                <td><m-b>text</m-b></td>
                <td>上限指定なしの可変長データ型(最大<m-b>1GB</m-b>まで格納可能)</td>
            </tr>
        </tbody>
    </table>
    <p>
        データ格納時に、次のルールに従ってヘッダ情報が付与される。
    </p>
    <ul>
        <li>文字列長が<m-b>126バイト</m-b>以下の場合、ヘッダ情報として<m-b>1バイト</m-b>使用する</li>
        <li>文字列長が<m-b>127バイト</m-b>以上の場合、ヘッダ情報として<m-b>4バイト</m-b>使用する</li>
        <li>
            非常に長い文字列の(テーブル内に格納される値が<m-b>2kB</m-b>を超える)場合、<m-b>TOAST領域</m-b>に分割して格納される<br>
            特に要件が無ければ、PostgreSQLにおいて文字型として用いることが推奨される。
        </li>
    </ul>

    <h3>char型に対する文字列操作の注意点</h3>
    <p>
        char型の文字列を文字列関数や文字列操作演算子で扱う場合、空白の扱いが異なる場合があるため注意が必要である。<br>
        例えば、char(8)のカラム<code>c</code>と、varchar(8)のカラム<code>v</code>をもつテーブル<code>example</code>に対し、
        concat関数と||演算子を用いた結合では次のような差が生まれる。
    </p>
    <h4>exampleテーブルのレコード</h4>
    <pre><code>
SELECT * FROM example;
    </code></pre>
    <h4>結果</h4>
    <pre><code>
  c |  v
----+-----
hoge|fuga

(1 rows)
    </code></pre>
    <h4>concat関数を用いた場合</h4>
    <pre><code>
SELECT concat(c, v) FROM example;
    </code></pre>
    <h4>結果</h4>
    <pre><code>
  concat
----------
<m-b>hoge    fuga</m-b>

(1 rows)
    </code></pre>
    <h4>||演算子を用いた場合</h4>
    <pre><code>
SELECT c || v FROM example;
    </code></pre>
    <h4>結果</h4>
    <pre><code>
  concat
----------
<m-b>hogefuga</m-b>

(1 rows)
    </code></pre>

    <h3>数値型</h3>
    <table>
        <thead>
            <tr>
                <th>型名</th>
                <th>
                    <nobr>格納サイズ</nobr><br>(バイト)
                </th>
                <th>説明</th>
                <th>範囲</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>smallint</m-b></td>
                <td><m-b>2</m-b></td>
                <td>整数データ型</td>
                <td>-32768~32767</td>
            </tr>
            <tr>
                <td><m-b>integer</m-b></td>
                <td><m-b>4</m-b></td>
                <td>整数データ型</td>
                <td>-2147483648~2147483647</td>
            </tr>
            <tr>
                <td><m-b>bigint</m-b></td>
                <td><m-b>8</m-b></td>
                <td>整数データ型</td>
                <td>-9223372036854775808~9223372036854775807</td>
            </tr>
            <tr>
                <td><m-b>decimal</m-b></td>
                <td>可変長</td>
                <td>正確な精度を保持する(小数も指定可)</td>
                <td>整数部は131072桁まで、小数部は16383桁まで</td>
            </tr>
            <tr>
                <td><m-b>numeric</m-b></td>
                <td>可変長</td>
                <td>正確な精度を保持する(小数も指定可)</td>
                <td>整数部は131072桁まで、小数部は16383桁まで</td>
            </tr>
            <tr>
                <td><m-b>real</m-b></td>
                <td><m-b>4</m-b></td>
                <td colspan="2">
                    <m-b>6</m-b>桁の精度を持つ不正確なデータ型(小数も指定可)<br>
                    IEEE規格754の形式で格納する。
                </td>
            </tr>
            <tr>
                <td><m-b>double precision</m-b></td>
                <td><m-b>8</m-b></td>
                <td colspan="2">
                    <m-b>15</m-b>桁の精度を持つ不正確なデータ型(小数も指定可)<br>
                    IEEE規格754の形式で格納する。
                </td>
            </tr>
            <tr>
                <td><m-b>smallserial</m-b></td>
                <td><m-b>2</m-b></td>
                <td rowspan="3" colspan="2">
                    連番型<br>
                    内部にシーケンスを作成し、デフォルト値としてシーケンスから払い出された値を設定する。
                </td>
            </tr>
            <tr>
                <td><m-b>serial</m-b></td>
                <td><m-b>4</m-b></td>
            </tr>
            <tr>
                <td><m-b>bigserial</m-b></td>
                <td><m-b>8</m-b></td>
            </tr>
        </tbody>
    </table>

    <h3>日付/時刻データ型</h3>
    <table>
        <thead>
            <tr>
                <th>型名</th>
                <th>
                    <nobr>格納サイズ</nobr><br>(バイト)
                </th>
                <th>説明</th>
                <th>範囲</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>timestamp [without timezone]</m-b></td>
                <td><m-b>8</m-b></td>
                <td>日付と時刻を保持する<br>(タイムゾーンなし)</td>
                <td>紀元前4713年~西暦294276年</td>
            </tr>
            <tr>
                <td><m-b>timestamp with time zone</m-b></td>
                <td><m-b>8</m-b></td>
                <td>日付と時刻を保持する<br>(タイムゾーンあり)</td>
                <td>紀元前4713年~西暦294276年</td>
            </tr>
            <tr>
                <td><m-b>date</m-b></td>
                <td><m-b>4</m-b></td>
                <td>日付を保持する</td>
                <td>紀元前4713年~西暦5874897年</td>
            </tr>
            <tr>
                <td><m-b>time [without timezone]</m-b></td>
                <td><m-b>8</m-b></td>
                <td>時刻を保持する</td>
                <td>00:00:00~24:00:00</td>
            </tr>
            <tr>
                <td><m-b>time with time zone</m-b></td>
                <td><m-b>12</m-b></td>
                <td>時刻を保持する</td>
                <td>00:00:00+1459~24:00:00-1459</td>
            </tr>
            <tr>
                <td><m-b>interval [fields]</m-b></td>
                <td><m-b>16</m-b></td>
                <td>時間間隔を保持する</td>
                <td>-178000000年~178000000年</td>
            </tr>
        </tbody>
    </table>

    <h3>タイムゾーンの指定方式</h3>
    <table>
        <thead>
            <tr>
                <th>指定方式</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>正式名</m-b>の指定</td>
                <td>
                    大文字/小文字を区別しない。<br>
                    対象の一覧は、システムカタログの<m-b>pg_timezone_names</m-b>ビューから確認できる。
                </td>
            </tr>
            <tr>
                <td><m-b>略称</m-b>の指定</td>
                <td>
                    大文字/小文字を区別しない。<br>
                    対象の一覧は、システムカタログの<m-b>pg_timezone_names</m-b>ビュー、
                    または<m-b>pg_timezone_abbrevs</m-b>ビューから確認できる。
                </td>
            </tr>
            <tr>
                <td><m-b>オフセット</m-b>の指定</td>
                <td>
                    略称とオフセットを指定する。
                </td>
            </tr>
        </tbody>
    </table>

    <h3>バイナリ列データ型</h3>
    <p>
        バイナリ列データ型を扱う場合は、基本的に<m-b>bytea</m-b>型を使用するが、
        格納するデータサイズが非常に大きい場合や、データの一部のみを書き換える使い方を想定する場合、
        <m-b>ラージオブジェクト</m-b>の使用を検討する。
        bytea型では、<m-b>1GB</m-b>までしか格納できないが、ラージオブジェクトでは<m-b>4TB</m-b>まで格納できる。
        性能の観点から、格納するデータ量が<m-b>100kB</m-b>までの場合はbytea型を、
        それ以上の場合はラージオブジェクトを使用することが推奨されている。
    </p>

    <h3>ラージオブジェクトについて</h3>
    <p>
        ラージオブジェクトは管理方法やアクセス方法がbytea型とは根本的に異なる。
        テーブル定義上は、ラージオブジェクトへのポインタとなる<m-b>oid</m-b>の列を定義する。<br>
        ラージオブジェクトの実体は、システムカタログの<m-b>pg_largeobject</m-b>にある。
        ここでは、<m-b>2kB</m-b>のチャンクに分割して格納されている。<br>
        また、ラージオブジェクトのメタ情報を扱うシステムカタログとして、<m-b>pg_largeobject_metadata</m-b>がある。
        ここでは、所有者やアクセス権限を管理する。
    </p>

    <h3>JSON型とJSONB型について</h3>
    <p>
        PostgreSQL9.4より、JSON型のみでなくJSONB型が追加された。
        JSON型とJSONB型はどちらもJSONデータを扱うデータ型だが、格納方法に違いがある。
        JSONB型では、JSON演算を高速にするため<m-b>バイナリ</m-b>形式に変換されて格納される。
        このため、挿入処理は<m-b>JSON型</m-b>の方が、演算子を用いた検索処理は<m-b>JSONB型</m-b>の方が高速となる。
        用途に応じて使い分ける。
    </p>

    <h3>型名のエイリアス</h3>
    <p>
        PostgreSQLでは、異なる名称で同じ意味を示すデータ型がいくつか存在する。<br>
        例えば、数値型では、<m-b>int2</m-b>(smallintと同義)、<m-b>int4</m-b>(integherと同義)、
        <m-b>int8</m-b>(bigintと同義)、<m-b>decimal</m-b>(numericと同義)、<m-b>float</m-b>(double precisionと同義)
        などがある。<br>
        なお、PostgreSQLのシステムカタログ(<m-b>pg_type.typename</m-b>)上では、SQL標準規定でない型名が定義されている場合がある。
        しかしその場合でも、psqlの<code>\d</code>メタコマンド等で列情報を確認すると、SQL標準規定の型名で表示される。
        これは、<m-b>pg_catalog.format_type()</m-b>で変換を行っているためである。
    </p>

    <h3>外部キー制約について</h3>
    <h4>参照先の削除/更新時の動作指定</h4>
    <p>
        外部キー制約を指定する際、参照先のレコードを削除/更新するときの動作を、
        それぞれ<m-b>ON DELETE</m-b>句、<m-b>ON UPDATE</m-b>句で指定することができる。
        指定できる具体的な操作は、次の表の通り。
    </p>
    <table>
        <thead>
            <tr>
                <th>キーワード</th>
                <th>説明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><m-b>CASCADE</m-b></td>
                <td>参照先のレコードが削除されたとき、伴って参照しているレコードも削除する</td>
            </tr>
            <tr>
                <td><m-b>RESTRICT</m-b></td>
                <td>
                    参照するレコードが残っている状態で、参照先のレコードが削除されることを防ぐ<br>
                    削除処理が行われたタイミングでエラーが発生する。
                </td>
            </tr>
            <tr>
                <td><m-b>NO ACTION</m-b></td>
                <td>
                    参照するレコードが残っている状態で、参照先のレコードが削除されても何もしない<br>
                    ただし、これは同一トランザクション内の後続処理で整合性が取られることを前提としている。
                    トランザクションがコミットされたタイミングで外部キーの整合性がとれていない場合、エラーが発生しトランザクションはロールバックされる。
                </td>
            </tr>
            <tr>
                <td><m-b>SET NULL</m-b></td>
                <td>参照先のレコードが削除されたとき、参照しているレコードの外部キー列にNULLを設定する</td>
            </tr>
            <tr>
                <td><m-b>SET DEFAULT</m-b></td>
                <td>
                    参照先のレコードが削除されたとき、参照しているレコードの外部キー列にデフォルト値を設定する<br>
                    ただし、デフォルト値が外部キー制約を満たさない場合、エラーが発生する。
                </td>
            </tr>
        </tbody>
    </table>
    <h4>外部キー制約の注意点</h4>
    <p>
        外部キー制約を用いる場合、次の2点に注意する必要がある。<br>
        1点目は、外部キーには暗黙的な<m-b>インデックス</m-b>が設定されないため、明示的に<m-b>インデックス</m-b>を作成する必要があることである。
        参照先の列が主キーの場合でも、参照元の外部キー列で暗黙的にインデックスが作成されることはない。<br>
        2点目は、テーブル間で外部キーの<m-b>型</m-b>を一致させることである。
        通常、異なる型で外部キーを作成することはできないが、<m-b>型変換</m-b>や<m-b>関数</m-b>を用いることで異なる型の外部キーを設定することも可能である。
    </p>

    <h3>生成列について</h3>

    <script src="./asset/script.js"></script>
</body>

</html>